validName = (name) ->
  unless name
    debug "not a name %j", name
    return false
  n = name.trim()
  if not n or n.charAt(0) is "." or not n.match(/^[a-zA-Z0-9]/) or n.match(/[\/\(\)&\?#\|<>@:%\s\\\*'"!~`]/) or n.toLowerCase() is "node_modules" or n isnt encodeURIComponent(n) or n.toLowerCase() is "favicon.ico"
    debug "not a valid name %j", name
    return false
  n
npa = (arg) ->
  assert.equal typeof arg, "string"
  arg = arg.trim()
  res = new Result
  res.raw = arg
  res.scope = null
  
  # See if it's something like foo@...
  nameparse = arg.match(nameAt)
  debug "nameparse", nameparse
  if nameparse and validName(nameparse[3]) and (not nameparse[2] or validName(nameparse[2]))
    res.name = (nameparse[1] or "") + nameparse[3]
    res.scope = "@" + nameparse[2]  if nameparse[2]
    arg = arg.substr(nameparse[0].length)
  else
    res.name = null
  res.rawSpec = arg
  res.spec = arg
  urlparse = url.parse(arg)
  debug "urlparse", urlparse
  
  # windows paths look like urls
  # don't be fooled!
  if isWindows and urlparse and urlparse.protocol and urlparse.protocol.match(/^[a-zA-Z]:$/)
    debug "windows url-ish local path", urlparse
    urlparse = {}
  return parseUrl(res, arg, urlparse)  if urlparse.protocol
  
  # parse git stuff
  # parse tag/range/local/remote
  if maybeGitHubShorthand(arg)
    res.type = "github"
    res.spec = arg
    return res
  
  # at this point, it's not a url, and not github
  # If it's a valid name, and doesn't already have a name, then assume
  # $name@"" range
  #
  # if it's got / chars in it, then assume that it's local.
  if res.name
    version = semver.valid(arg, true)
    range = semver.validRange(arg, true)
    
    # foo@...
    if version
      res.spec = version
      res.type = "version"
    else if range
      res.spec = range
      res.type = "range"
    else if slashRe.test(arg)
      parseLocal res, arg
    else
      res.type = "tag"
      res.spec = arg
  else
    p = arg.match(parseName)
    if p and validName(p[2]) and (not p[1] or validName(p[1]))
      res.type = "range"
      res.spec = "*"
      res.rawSpec = ""
      res.name = arg
      res.scope = "@" + p[1]  if p[1]
    else
      parseLocal res, arg
  res
parseLocal = (res, arg) ->
  
  # turns out nearly every character is allowed in fs paths
  throw new Error("Invalid Path: " + JSON.stringify(arg))  if /\0/.test(arg)
  res.type = "local"
  res.spec = path.resolve(arg)
  return
maybeGitHubShorthand = (arg) ->
  
  # Note: This does not fully test the git ref format.
  # See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html
  #
  # The only way to do this properly would be to shell out to
  # git-check-ref-format, and as this is a fast sync function,
  # we don't want to do that.  Just let git fail if it turns
  # out that the commit-ish is invalid.
  # GH usernames cannot start with . or -
  /^[^@%\/\s\.-][^@%\/\s]*\/[^@\s\/%]+(?:#.*)?$/.test arg
parseUrl = (res, arg, urlparse) ->
  
  # check the protocol, and then see if it's git or not
  switch urlparse.protocol
    when "git:", "git+http:", "git+https:", "git+rsync:", "git+ftp:", "git+ssh:", "git+file:"
      res.type = "git"
      res.spec = arg.replace(/^git\+/, "")
    when "http:", "https:"
      res.type = "remote"
      res.spec = arg
    when "file:"
      res.type = "local"
      res.spec = urlparse.pathname
    else
      throw new Error("Unsupported URL Type: " + arg)
  res
Result = ->
  new Result  unless this instanceof Result
url = require("url")
assert = require("assert")
util = require("util")
semver = require("semver")
path = require("path")
module.exports = npa
isWindows = process.platform is "win32" or global.FAKE_WINDOWS
slashRe = (if isWindows then /\\|\// else /\//)
parseName = /^(?:@([^\/]+?)\/)?([^\/]+?)$/
nameAt = /^(@([^\/]+?)\/)?([^\/]+?)@/
debug = (if util.debuglog then util.debuglog("npa") else (if /\bnpa\b/i.test(process.env.NODE_DEBUG or "") then ->
  console.error "NPA: " + util.format.apply(util, arguments).split("\n").join("\nNPA: ")
  return
 else ->
))
Result::name = null
Result::type = null
Result::spec = null
Result::raw = null
