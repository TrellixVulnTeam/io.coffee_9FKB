md5hex = ->
  hash = crypto.createHash("md5")
  ii = 0

  while ii < arguments.length
    hash.update "" + arguments[ii]
    ++ii
  hash.digest "hex"
getTmpname = (filename) ->
  filename + "." + md5hex(__filename, process.pid, ++invocations)
WriteStream = (path, options) ->
  options = {}  unless options
  return new WriteStream(path, options)  unless this instanceof WriteStream
  @__atomicTarget = path
  @__atomicChown = options.chown
  @__atomicDidStuff = false
  @__atomicTmp = getTmpname(path)
  fs.WriteStream.call this, @__atomicTmp, options
  return
cleanup = (er) ->
  fs.unlink @__atomicTmp, (->
    fs.WriteStream::emit.call this, "error", er
    return
  ).bind(this)
  return
cleanupSync = (er) ->
  try
    fs.unlinkSync @__atomicTmp
  finally
    return fs.WriteStream::emit.call(this, "error", er)
  return

# When we *would* emit 'close' or 'finish', instead do our stuff

# We handle emitting finish and close after the rename.
atomicDoStuff = (cb) ->
  throw new Error("Already did atomic move-into-place")  if @__atomicDidStuff
  @__atomicDidStuff = true
  if @__atomicChown
    uid = @__atomicChown.uid
    gid = @__atomicChown.gid
    fs.chown @__atomicTmp, uid, gid, ((er) ->
      return cb(er)  if er
      moveIntoPlace.call this, cb
      return
    ).bind(this)
  else
    moveIntoPlace.call this, cb
  return
moveIntoPlace = (cb) ->
  
  # emit finish, and then close on the next tick
  # This makes finish/close consistent across Node versions also.
  fs.rename @__atomicTmp, @__atomicTarget, ((er) ->
    cb er
    fs.WriteStream::emit.call this, "finish"
    process.nextTick (->
      fs.WriteStream::emit.call this, "close"
      return
    ).bind(this)
    return
  ).bind(this)
  return
fs = require("graceful-fs")
util = require("util")
crypto = require("crypto")
invocations = 0
module.exports = WriteStream
util.inherits WriteStream, fs.WriteStream
WriteStream::emit = (ev) ->
  return cleanupSync(this)  if ev is "error"
  return fs.WriteStream::emit.apply(this, arguments)  if ev isnt "close" and ev isnt "finish"
  if ev is "close" or ev is "finish"
    unless @__atomicDidStuff
      atomicDoStuff.call this, ((er) ->
        cleanup.call this, er  if er
        return
      ).bind(this)
  return
