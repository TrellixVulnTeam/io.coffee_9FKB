# vim: set softtabstop=16 shiftwidth=16:

# put more stuff on here to customize.
readJson = (file, log_, strict_, cb_) ->
  log = undefined
  strict = undefined
  cb = undefined
  i = 1

  while i < arguments.length - 1
    if typeof arguments[i] is "boolean"
      strict = arguments[i]
    else log = arguments[i]  if typeof arguments[i] is "function"
    i++
  log = ->  unless log
  cb = arguments[arguments.length - 1]
  c = readJson.cache.get(file)
  if c
    cb = cb.bind(null, null, c)
    return process.nextTick(cb)
  cb = ((orig) ->
    (er, data) ->
      readJson.cache.set file, data  if data
      orig er, data
  )(cb)
  readJson_ file, log, strict, cb
  return
readJson_ = (file, log, strict, cb) ->
  fs.readFile file, "utf8", (er, d) ->
    parseJson file, er, d, log, strict, cb
    return

  return
stripBOM = (content) ->
  
  # Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
  # because the buffer-to-string conversion in `fs.readFileSync()`
  # translates it to FEFF, the UTF-16 BOM.
  content = content.slice(1)  if content.charCodeAt(0) is 0xfeff
  content
parseJson = (file, er, d, log, strict, cb) ->
  if er and er.code is "ENOENT"
    indexjs file, er, log, strict, cb
    return
  return cb(er)  if er
  try
    d = JSON.parse(stripBOM(d))
  catch er
    d = parseIndex(d)
    return cb(parseError(er, file))  unless d
  extras file, d, log, strict, cb
  return
indexjs = (file, er, log, strict, cb) ->
  return cb(er)  if path.basename(file) is "index.js"
  index = path.resolve(path.dirname(file), "index.js")
  fs.readFile index, "utf8", (er2, d) ->
    return cb(er)  if er2
    d = parseIndex(d)
    return cb(er)  unless d
    extras file, d, log, strict, cb
    return

  return
extras = (file, data, log_, strict_, cb_) ->
  then = (er) ->
    return  if errState
    return cb(errState = er)  if er
    return  if --n > 0
    final file, data, log, strict, cb
    return
  log = undefined
  strict = undefined
  cb = undefined
  i = 2

  while i < arguments.length - 1
    if typeof arguments[i] is "boolean"
      strict = arguments[i]
    else log = arguments[i]  if typeof arguments[i] is "function"
    i++
  log = ->  unless log
  cb = arguments[i]
  set = readJson.extraSet
  n = set.length
  errState = null
  set.forEach (fn) ->
    fn file, data, then_
    return

  return
scriptpath = (file, data, cb) ->
  return cb(null, data)  unless data.scripts
  k = Object.keys(data.scripts)
  k.forEach scriptpath_, data.scripts
  cb null, data
  return
scriptpath_ = (key) ->
  s = this[key]
  
  # This is never allowed, and only causes problems
  return delete this[key]  if typeof s isnt "string"
  spre = /^(\.[\/\\])?node_modules[\/\\].bin[\\\/]/
  this[key] = this[key].replace(spre, "")  if s.match(spre)
  return
gypfile = (file, data, cb) ->
  dir = path.dirname(file)
  s = data.scripts or {}
  return cb(null, data)  if s.install or s.preinstall
  glob "*.gyp",
    cwd: dir
  , (er, files) ->
    return cb(er)  if er
    gypfile_ file, data, files, cb
    return

  return
gypfile_ = (file, data, files, cb) ->
  return cb(null, data)  unless files.length
  s = data.scripts or {}
  s.install = "node-gyp rebuild"
  data.scripts = s
  data.gypfile = true
  cb null, data
serverjs = (file, data, cb) ->
  dir = path.dirname(file)
  s = data.scripts or {}
  return cb(null, data)  if s.start
  glob "server.js",
    cwd: dir
  , (er, files) ->
    return cb(er)  if er
    serverjs_ file, data, files, cb
    return

  return
serverjs_ = (file, data, files, cb) ->
  return cb(null, data)  unless files.length
  s = data.scripts or {}
  s.start = "node server.js"
  data.scripts = s
  cb null, data
authors = (file, data, cb) ->
  return cb(null, data)  if data.contributors
  af = path.resolve(path.dirname(file), "AUTHORS")
  fs.readFile af, "utf8", (er, ad) ->
    
    # ignore error.  just checking it.
    return cb(null, data)  if er
    authors_ file, data, ad, cb
    return

  return
authors_ = (file, data, ad, cb) ->
  ad = ad.split(/\r?\n/g).map((line) ->
    line.replace(/^\s*#.*$/, "").trim()
  ).filter((line) ->
    line
  )
  data.contributors = ad
  cb null, data
gitDescription = (file, data, cb) ->
  return cb(null, data)  if data.description
  dir = path.dirname(file)
  
  # just cuz it'd be nice if this file mattered...
  gitDesc = path.resolve(dir, ".git/description")
  fs.readFile gitDesc, "utf8", (er, desc) ->
    desc = desc.trim()  if desc
    data.description = desc  if not er and desc isnt defDesc
    cb null, data

  return
readmeDescription = (file, data) ->
  return cb(null, data)  if data.description
  d = data.readme
  return  unless d
  
  # the first block of text before the first heading
  # that isn't the first line heading
  d = d.trim().split("\n")
  s = 0

  while d[s] and d[s].trim().match(/^(#|$)/)
    s++
  l = d.length
  e = s + 1

  while e < l and d[e].trim()
    e++
  data.description = d.slice(s, e).join(" ").trim()
  return
readme = (file, data, cb) ->
  return cb(null, data)  if data.readme
  dir = path.dirname(file)
  globOpts =
    cwd: dir
    nocase: true
    mark: true

  glob "{README,README.*}", globOpts, (er, files) ->
    return cb(er)  if er
    
    # don't accept directories.
    files = files.filter((file) ->
      not file.match(/\/$/)
    )
    return cb()  unless files.length
    fn = preferMarkdownReadme(files)
    rm = path.resolve(dir, fn)
    readme_ file, data, rm, cb
    return

  return
preferMarkdownReadme = (files) ->
  fallback = 0
  re = /\.m?a?r?k?d?o?w?n?$/i
  i = 0

  while i < files.length
    if files[i].match(re)
      return files[i]
    else fallback = i  if files[i].match(/README$/)
    i++
  
  # prefer README.md, followed by README; otherwise, return
  # the first filename (which could be README)
  files[fallback]
readme_ = (file, data, rm, cb) ->
  rmfn = path.basename(rm)
  fs.readFile rm, "utf8", (er, rm) ->
    
    # maybe not readable, or something.
    return cb()  if er
    data.readme = rm
    data.readmeFilename = rmfn
    cb er, data

  return
mans = (file, data, cb) ->
  m = data.directories and data.directories.man
  return cb(null, data)  if data.man or not m
  m = path.resolve(path.dirname(file), m)
  glob "**/*.[0-9]",
    cwd: m
  , (er, mans) ->
    return cb(er)  if er
    mans_ file, data, mans, cb
    return

  return
mans_ = (file, data, mans, cb) ->
  m = data.directories and data.directories.man
  data.man = mans.map((mf) ->
    path.resolve path.dirname(file), m, mf
  )
  cb null, data
bins = (file, data, cb) ->
  return bins_(file, data, data.bin, cb)  if Array.isArray(data.bin)
  m = data.directories and data.directories.bin
  return cb(null, data)  if data.bin or not m
  m = path.resolve(path.dirname(file), m)
  glob "**",
    cwd: m
  , (er, bins) ->
    return cb(er)  if er
    bins_ file, data, bins, cb
    return

  return
bins_ = (file, data, bins, cb) ->
  m = data.directories and data.directories.bin or "."
  data.bin = bins.reduce((acc, mf) ->
    if mf and mf.charAt(0) isnt "."
      f = path.basename(mf)
      acc[f] = path.join(m, mf)
    acc
  , {})
  cb null, data
githead = (file, data, cb) ->
  return cb(null, data)  if data.gitHead
  dir = path.dirname(file)
  head = path.resolve(dir, ".git/HEAD")
  fs.readFile head, "utf8", (er, head) ->
    return cb(null, data)  if er
    githead_ file, data, dir, head, cb
    return

  return
githead_ = (file, data, dir, head, cb) ->
  unless head.match(/^ref: /)
    data.gitHead = head.trim()
    return cb(null, data)
  headFile = head.replace(/^ref: /, "").trim()
  headFile = path.resolve(dir, ".git", headFile)
  fs.readFile headFile, "utf8", (er, head) ->
    return cb(null, data)  if er or not head
    head = head.replace(/^ref: /, "").trim()
    data.gitHead = head
    cb null, data

  return
final = (file, data, log, strict, cb) ->
  warn = (msg) ->
    return  if typoWarned[pId]
    log "package.json", pId, msg  if log
    return
  pId = makePackageId(data)
  try
    normalizeData data, warn, strict
  catch error
    return cb(error)
  typoWarned[pId] = true
  readJson.cache.set file, data
  cb null, data
  return
makePackageId = (data) ->
  name = cleanString(data.name)
  ver = cleanString(data.version)
  name + "@" + ver
cleanString = (str) ->
  (if (not str or typeof (str) isnt "string") then "" else str.trim())

# /**package { "name": "foo", "version": "1.2.3", ... } **/
parseIndex = (data) ->
  data = data.split(/^\/\*\*package(?:\s|$)/m)
  return null  if data.length < 2
  data = data[1]
  data = data.split(/\*\*\/$/m)
  return null  if data.length < 2
  data = data[0]
  data = data.replace(/^\s*\*/g, "")
  try
    return JSON.parse(data)
  catch er
    return null
  return
parseError = (ex, file) ->
  e = new Error("Failed to parse json\n" + ex.message)
  e.code = "EJSONPARSE"
  e.file = file
  e
try
  fs = require("graceful-fs")
catch er
  fs = require("fs")
module.exports = readJson
LRU = require("lru-cache")
readJson.cache = new LRU(max: 1000)
path = require("path")
glob = require("glob")
normalizeData = require("normalize-package-data")
readJson.extraSet = [
  gypfile
  serverjs
  scriptpath
  authors
  readme
  mans
  bins
  githead
]
typoWarned = {}
readJson.extras = extras
defDesc = "Unnamed repository; edit this file " + "'description' to name the repository."
