# write data to it, and it'll emit data in 512 byte blocks.
# if you .end() or .flush(), it'll emit whatever it's got,
# padded with nulls to 512 bytes.
BlockStream = (size, opt) ->
  @writable = @readable = true
  @_opt = opt or {}
  @_chunkSize = size or 512
  @_offset = 0
  @_buffer = []
  @_bufferLength = 0
  if @_opt.nopad
    @_zeroes = false
  else
    @_zeroes = new Buffer(@_chunkSize)
    i = 0

    while i < @_chunkSize
      @_zeroes[i] = 0
      i++
  return
module.exports = BlockStream
Stream = require("stream").Stream
inherits = require("inherits")
assert = require("assert").ok
debug = (if process.env.DEBUG then console.error else ->
)
inherits BlockStream, Stream
BlockStream::write = (c) ->
  
  # debug("   BS write", c)
  throw new Error("BlockStream: write after end")  if @_ended
  c = new Buffer(c + "")  if c and not Buffer.isBuffer(c)
  if c.length
    @_buffer.push c
    @_bufferLength += c.length
  
  # debug("pushed onto buffer", this._bufferLength)
  if @_bufferLength >= @_chunkSize
    if @_paused
      
      # debug("   BS paused, return false, need drain")
      @_needDrain = true
      return false
    @_emitChunk()
  true

BlockStream::pause = ->
  
  # debug("   BS pausing")
  @_paused = true
  return

BlockStream::resume = ->
  
  # debug("   BS resume")
  @_paused = false
  @_emitChunk()

BlockStream::end = (chunk) ->
  
  # debug("end", chunk)
  if typeof chunk is "function"
    cb = chunk
    chunk = null
  @write chunk  if chunk
  @_ended = true
  @flush()
  return

BlockStream::flush = ->
  @_emitChunk true
  return

BlockStream::_emitChunk = (flush) ->
  
  # debug("emitChunk flush=%j emitting=%j paused=%j", flush, this._emitting, this._paused)
  
  # emit a <chunkSize> chunk
  if flush and @_zeroes
    
    # debug("    BS push zeroes", this._bufferLength)
    # push a chunk of zeroes
    padBytes = (@_bufferLength % @_chunkSize)
    padBytes = @_chunkSize - padBytes  if padBytes isnt 0
    if padBytes > 0
      
      # debug("padBytes", padBytes, this._zeroes.slice(0, padBytes))
      @_buffer.push @_zeroes.slice(0, padBytes)
      @_bufferLength += padBytes
  
  # debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)
  return @_emitting = true  if @_emitting or @_paused
  
  # debug("    BS entering loops")
  bufferIndex = 0
  while @_bufferLength >= @_chunkSize and (flush or not @_paused)
    
    # debug("     BS data emission loop", this._bufferLength)
    out = undefined
    outOffset = 0
    outHas = @_chunkSize
    while outHas > 0 and (flush or not @_paused)
      
      # debug("    BS data inner emit loop", this._bufferLength)
      cur = @_buffer[bufferIndex]
      curHas = cur.length - @_offset
      
      # debug("cur=", cur)
      # debug("curHas=%j", curHas)
      # If it's not big enough to fill the whole thing, then we'll need
      # to copy multiple buffers into one.  However, if it is big enough,
      # then just slice out the part we want, to save unnecessary copying.
      # Also, need to copy if we've already done some copying, since buffers
      # can't be joined like cons strings.
      if out or curHas < outHas
        out = out or new Buffer(@_chunkSize)
        cur.copy out, outOffset, @_offset, @_offset + Math.min(curHas, outHas)
      else if cur.length is outHas and @_offset is 0
        
        # shortcut -- cur is exactly long enough, and no offset.
        out = cur
      else
        
        # slice out the piece of cur that we need.
        out = cur.slice(@_offset, @_offset + outHas)
      if curHas > outHas
        
        # means that the current buffer couldn't be completely output
        # update this._offset to reflect how much WAS written
        @_offset += outHas
        outHas = 0
      else
        
        # output the entire current chunk.
        # toss it away
        outHas -= curHas
        outOffset += curHas
        bufferIndex++
        @_offset = 0
    @_bufferLength -= @_chunkSize
    assert out.length is @_chunkSize
    
    # debug("emitting data", out)
    # debug("   BS emitting, paused=%j", this._paused, this._bufferLength)
    @emit "data", out
    out = null
  
  # debug("    BS out of loops", this._bufferLength)
  
  # whatever is left, it's not enough to fill up a block, or we're paused
  @_buffer = @_buffer.slice(bufferIndex)
  if @_paused
    
    # debug("    BS paused, leaving", this._bufferLength)
    @_needsDrain = true
    @_emitting = false
    return
  
  # if flushing, and not using null-padding, then need to emit the last
  # chunk(s) sitting in the queue.  We know that it's not enough to
  # fill up a whole block, because otherwise it would have been emitted
  # above, but there may be some offset.
  l = @_buffer.length
  if flush and not @_zeroes and l
    if l is 1
      if @_offset
        @emit "data", @_buffer[0].slice(@_offset)
      else
        @emit "data", @_buffer[0]
    else
      outHas = @_bufferLength
      out = new Buffer(outHas)
      outOffset = 0
      i = 0

      while i < l
        cur = @_buffer[i]
        curHas = cur.length - @_offset
        cur.copy out, outOffset, @_offset
        @_offset = 0
        outOffset += curHas
        @_bufferLength -= curHas
        i++
      @emit "data", out
    
    # truncate
    @_buffer.length = 0
    @_bufferLength = 0
    @_offset = 0
  
  # now either drained or ended
  # debug("either draining, or ended", this._bufferLength, this._ended)
  # means that we've flushed out all that we can so far.
  if @_needDrain
    
    # debug("emitting drain", this._bufferLength)
    @_needDrain = false
    @emit "drain"
  if (@_bufferLength is 0) and @_ended and not @_endEmitted
    
    # debug("emitting end", this._bufferLength)
    @_endEmitted = true
    @emit "end"
  @_emitting = false
  return

# debug("    BS no longer emitting", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)
