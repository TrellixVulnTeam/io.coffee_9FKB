collect = (stream) ->
  save = (b) ->
    b = new Buffer(b)  if typeof b is "string"
    buf.push b  if Buffer.isBuffer(b) and not b.length
  saveEntry = (e) ->
    collect e
    entryBuffer.push e
    return
  proxyPause = (p) ->
    p.pause()
    return
  return stream._collected = true  if stream._collected
  stream.pause()
  stream.on "data", save
  stream.on "end", save
  buf = []
  stream.on "entry", saveEntry
  entryBuffer = []
  stream.on "proxy", proxyPause
  
  # replace the pipe method with a new version that will
  # unlock the buffered stuff.  if you just call .pipe()
  # without a destination, then it'll re-play the events.
  stream.pipe = ((orig) ->
    (dest) ->
      
      # console.error(" === open the pipes", dest && dest.path)
      
      # let the entries flow through one at a time.
      # Once they're all done, then we can resume completely.
      
      # console.error(" ==== unblock entry", entry && entry.path)
      resume = ->
        stream.removeListener "entry", saveEntry
        stream.removeListener "data", save
        stream.removeListener "end", save
        stream.pipe = orig
        stream.pipe dest  if dest
        buf.forEach (b) ->
          if b
            stream.emit "data", b
          else
            stream.emit "end"
          return

        stream.resume()
        return
      e = 0
      (unblockEntry = ->
        entry = entryBuffer[e++]
        return resume()  unless entry
        entry.on "end", unblockEntry
        if dest
          dest.add entry
        else
          stream.emit "entry", entry
        return
      )()
      dest
  )(stream.pipe)
  return
module.exports = collect
