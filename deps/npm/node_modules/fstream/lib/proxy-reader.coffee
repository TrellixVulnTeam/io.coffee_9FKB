# A reader for when we don't yet know what kind of thing
# the thing is.
ProxyReader = (props) ->
  me = this
  throw new Error("ProxyReader must be called as constructor.")  unless me instanceof ProxyReader
  me.props = props
  me._buffer = []
  me.ready = false
  Reader.call me, props
  return
module.exports = ProxyReader
Reader = require("./reader.js")
getType = require("./get-type.js")
inherits = require("inherits")
fs = require("graceful-fs")
inherits ProxyReader, Reader
ProxyReader::_stat = ->
  me = this
  props = me.props
  
  # stat the thing to see what the proxy should be.
  stat = (if props.follow then "stat" else "lstat")
  fs[stat] props.path, (er, current) ->
    type = undefined
    if er or not current
      type = "File"
    else
      type = getType(current)
    props[type] = true
    props.type = me.type = type
    me._old = current
    me._addProxy Reader(props, current)
    return

  return

ProxyReader::_addProxy = (proxy) ->
  me = this
  return me.error("proxy already set")  if me._proxyTarget
  me._proxyTarget = proxy
  proxy._proxy = me
  [
    "error"
    "data"
    "end"
    "close"
    "linkpath"
    "entry"
    "entryEnd"
    "child"
    "childEnd"
    "warn"
    "stat"
  ].forEach (ev) ->
    
    # console.error("~~ proxy event", ev, me.path)
    proxy.on ev, me.emit.bind(me, ev)
    return

  me.emit "proxy", proxy
  proxy.on "ready", ->
    
    # console.error("~~ proxy is ready!", me.path)
    me.ready = true
    me.emit "ready"
    return

  calls = me._buffer
  me._buffer.length = 0
  calls.forEach (c) ->
    proxy[c[0]].apply proxy, c[1]
    return

  return

ProxyReader::pause = ->
  (if @_proxyTarget then @_proxyTarget.pause() else false)

ProxyReader::resume = ->
  (if @_proxyTarget then @_proxyTarget.resume() else false)
