
# Must do this *before* loading the child classes
Reader = (props, currentStat) ->
  me = this
  return new Reader(props, currentStat)  unless me instanceof Reader
  props = path: props  if typeof props is "string"
  me.error "Must provide a path", null, true  unless props.path
  
  # polymorphism.
  # call fstream.Reader(dir) to get a DirReader object, etc.
  # Note that, unlike in the Writer case, ProxyReader is going
  # to be the *normal* state of affairs, since we rarely know
  # the type of a file prior to reading it.
  type = undefined
  ClassType = undefined
  if props.type and typeof props.type is "function"
    type = props.type
    ClassType = type
  else
    type = getType(props)
    ClassType = Reader
  if currentStat and not type
    type = getType(currentStat)
    props[type] = true
    props.type = type
  switch type
    when "Directory"
      ClassType = DirReader
    
    # XXX hard links are just files.
    # However, it would be good to keep track of files' dev+inode
    # and nlink values, and create a HardLinkReader that emits
    # a linkpath value of the original copy, so that the tar
    # writer can preserve them.
    # ClassType = HardLinkReader
    # break
    when "Link", "File"
      ClassType = FileReader
    when "SymbolicLink"
      ClassType = LinkReader
    when "Socket"
      ClassType = SocketReader
    when null
      ClassType = ProxyReader
  return new ClassType(props)  unless me instanceof ClassType
  Abstract.call me
  me.readable = true
  me.writable = false
  me.type = type
  me.props = props
  me.depth = props.depth = props.depth or 0
  me.parent = props.parent or null
  me.root = props.root or (props.parent and props.parent.root) or me
  me._path = me.path = path.resolve(props.path)
  if process.platform is "win32"
    me.path = me._path = me.path.replace(/\?/g, "_")
    if me._path.length >= 260
      
      # how DOES one create files on the moon?
      # if the path has spaces in it, then UNC will fail.
      me._swallowErrors = true
      
      #if (me._path.indexOf(" ") === -1) {
      me._path = "\\\\?\\" + me.path.replace(/\//g, "\\")
  
  #}
  me.basename = props.basename = path.basename(me.path)
  me.dirname = props.dirname = path.dirname(me.path)
  
  # these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null
  
  # console.error("\n\n\n%s setting size to", props.path, props.size)
  me.size = props.size
  me.filter = (if typeof props.filter is "function" then props.filter else null)
  props.sort = alphasort  if props.sort is "alpha"
  
  # start the ball rolling.
  # this will stat the thing, and then call me._read()
  # to start reading whatever it is.
  # console.error("calling stat", props.path, currentStat)
  me._stat currentStat
  return
alphasort = (a, b) ->
  (if a is b then 0 else (if a.toLowerCase() > b.toLowerCase() then 1 else (if a.toLowerCase() < b.toLowerCase() then -1 else (if a > b then 1 else -1))))
module.exports = Reader
fs = require("graceful-fs")
Stream = require("stream").Stream
inherits = require("inherits")
path = require("path")
getType = require("./get-type.js")
hardLinks = Reader.hardLinks = {}
Abstract = require("./abstract.js")
inherits Reader, Abstract
DirReader = require("./dir-reader.js")
FileReader = require("./file-reader.js")
LinkReader = require("./link-reader.js")
SocketReader = require("./socket-reader.js")
ProxyReader = require("./proxy-reader.js")
Reader::_stat = (currentStat) ->
  
  # console.error("Reader._stat", me._path, currentStat)
  statCb = (er, props_) ->
    
    # console.error("Reader._stat, statCb", me._path, props_, props_.nlink)
    return me.error(er)  if er
    Object.keys(props_).forEach (k) ->
      props[k] = props_[k]
      return

    
    # if it's not the expected size, then abort here.
    return me.error("incorrect size")  if `undefined` isnt me.size and props.size isnt me.size
    me.size = props.size
    type = getType(props)
    handleHardlinks = props.hardlinks isnt false
    
    # special little thing for handling hardlinks.
    if handleHardlinks and type isnt "Directory" and props.nlink and props.nlink > 1
      k = props.dev + ":" + props.ino
      
      # console.error("Reader has nlink", me._path, k)
      if hardLinks[k] is me._path or not hardLinks[k]
        hardLinks[k] = me._path
      else
        
        # switch into hardlink mode.
        type = me.type = me.props.type = "Link"
        me.Link = me.props.Link = true
        me.linkpath = me.props.linkpath = hardLinks[k]
        
        # console.error("Hardlink detected, switching mode", me._path, me.linkpath)
        # Setting __proto__ would arguably be the "correct"
        # approach here, but that just seems too wrong.
        me._stat = me._read = LinkReader::_read
    me.error "Unexpected type: " + type  if me.type and me.type isnt type
    
    # if the filter doesn't pass, then just skip over this one.
    # still have to emit end so that dir-walking can move on.
    if me.filter
      who = me._proxy or me
      
      # special handling for ProxyReaders
      unless me.filter.call(who, who, props)
        unless me._disowned
          me.abort()
          me.emit "end"
          me.emit "close"
        return
    
    # last chance to abort or disown before the flow starts!
    events = [
      "_stat"
      "stat"
      "ready"
    ]
    e = 0
    (go = ->
      if me._aborted
        me.emit "end"
        me.emit "close"
        return
      if me._paused and me.type isnt "Directory"
        me.once "resume", go
        return
      ev = events[e++]
      return me._read()  unless ev
      me.emit ev, props
      go()
      return
    )()
    return
  me = this
  props = me.props
  stat = (if props.follow then "stat" else "lstat")
  if currentStat
    process.nextTick statCb.bind(null, null, currentStat)
  else
    fs[stat] me._path, statCb
  return

Reader::pipe = (dest, opts) ->
  me = this
  if typeof dest.add is "function"
    
    # piping to a multi-compatible, and we've got directory entries.
    me.on "entry", (entry) ->
      ret = dest.add(entry)
      me.pause()  if false is ret
      return

  
  # console.error("R Pipe apply Stream Pipe")
  Stream::pipe.apply this, arguments

Reader::pause = (who) ->
  @_paused = true
  who = who or this
  @emit "pause", who
  @_stream.pause who  if @_stream
  return

Reader::resume = (who) ->
  @_paused = false
  who = who or this
  @emit "resume", who
  @_stream.resume who  if @_stream
  @_read()
  return

Reader::_read = ->
  @error "Cannot read unknown type: " + @type
  return
