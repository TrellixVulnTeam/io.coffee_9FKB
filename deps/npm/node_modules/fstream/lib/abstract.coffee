# the parent class for all fstreams.
Abstract = ->
  Stream.call this
  return
decorate = (er, code, me) ->
  er = new Error(er)  unless er instanceof Error
  er.code = er.code or code
  er.path = er.path or me.path
  er.fstream_type = er.fstream_type or me.type
  er.fstream_path = er.fstream_path or me.path
  er.fstream_unc_path = er.fstream_unc_path or me._path  if me._path isnt me.path
  er.fstream_linkpath = er.fstream_linkpath or me.linkpath  if me.linkpath
  er.fstream_class = er.fstream_class or me.constructor.name
  er.fstream_stack = er.fstream_stack or new Error().stack.split(/\n/).slice(3).map((s) ->
    s.replace /^    at /, ""
  )
  er
module.exports = Abstract
Stream = require("stream").Stream
inherits = require("inherits")
inherits Abstract, Stream
Abstract::on = (ev, fn) ->
  if ev is "ready" and @ready
    process.nextTick fn.bind(this)
  else
    Stream::on.call this, ev, fn
  this

Abstract::abort = ->
  @_aborted = true
  @emit "abort"
  return

Abstract::destroy = ->

Abstract::warn = (msg, code) ->
  me = this
  er = decorate(msg, code, me)
  unless me.listeners("warn")
    console.error "%s %s\n" + "path = %s\n" + "syscall = %s\n" + "fstream_type = %s\n" + "fstream_path = %s\n" + "fstream_unc_path = %s\n" + "fstream_class = %s\n" + "fstream_stack =\n%s\n", code or "UNKNOWN", er.stack, er.path, er.syscall, er.fstream_type, er.fstream_path, er.fstream_unc_path, er.fstream_class, er.fstream_stack.join("\n")
  else
    me.emit "warn", er
  return

Abstract::info = (msg, code) ->
  @emit "info", msg, code
  return

Abstract::error = (msg, code, th) ->
  er = decorate(msg, code, this)
  if th
    throw er
  else
    @emit "error", er
  return
