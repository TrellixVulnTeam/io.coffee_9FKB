# remove config so doesn't appear on every column.
# this is a line control option, don't pass it to column

# Option defaults inheritance:
# options.config[columnName] => options => DEFAULTS
# probably useless
# alias include/columns, prefer columns if supplied
# optional user-supplied columns to include

# if not suppled column names, automatically determine columns from data keys

# initialize column defaults (each column inherits from options.config)

# sanitize column settings

# sanitize data

# null/undefined -> ''

# toString everything

# merge non-newline whitespace chars

# merge all whitespace chars

# transform data cells

# add headers

# get actual max-width between min & max
# based on length of data in columns

# split long words so they can break onto multiple lines

# wrap long lines. each item is now an array of lines.

# if truncating required, only include first line + add truncation char

# recalculate column widths from truncated output/lines
# merge lines into rows
# conceive output

###*
Convert wrapped lines into rows with padded values.

@param Array items data to process
@param Array columns column width settings for wrapping
@param Array columnNames column ordering
@return Array items wrapped in arrays, corresponding to lines
###
createRows = (items, columns, columnNames, paddingChr) ->
  items.map (item) ->
    row = []
    numLines = 0
    columnNames.forEach (columnName) ->
      numLines = Math.max(numLines, item[columnName].length)
      return

    
    # combine matching lines of each rows
    i = 0

    while i < numLines
      row[i] = row[i] or []
      columnNames.forEach (columnName) ->
        column = columns[columnName]
        val = item[columnName][i] or "" # || '' ensures empty columns get padded
        if column.align is "right"
          row[i].push padLeft(val, column.width, paddingChr)
        else if column.align is "center"
          row[i].push padCenter(val, column.width, paddingChr)
        else
          row[i].push padRight(val, column.width, paddingChr)
        return

      i++
    row


###*
Generic source->target mixin.
Copy properties from `source` into `target` if target doesn't have them.
Destructive. Modifies `target`.

@param target Object target for mixin properties.
@param source Object source of mixin properties.
@return Object `target` after mixin applied.
###
mixin = (target, source) ->
  source = source or {}
  for key of source
    continue  if target.hasOwnProperty(key)
    target[key] = source[key]
  target

###*
Adapted from String.prototype.endsWith polyfill.
###
endsWith = (target, searchString, position) ->
  position = position or target.length
  position = position - searchString.length
  lastIndex = target.lastIndexOf(searchString)
  lastIndex isnt -1 and lastIndex is position
toArray = (items, columnNames) ->
  return items  if Array.isArray(items)
  rows = []
  for key of items
    item = {}
    item[columnNames[0] or "key"] = key
    item[columnNames[1] or "value"] = items[key]
    rows.push item
  rows
"use strict"
wcwidth = require("./width")
utils = require("./utils")
padRight = utils.padRight
padCenter = utils.padCenter
padLeft = utils.padLeft
splitIntoLines = utils.splitIntoLines
splitLongWords = utils.splitLongWords
truncateString = utils.truncateString
DEFAULTS =
  maxWidth: Infinity
  minWidth: 0
  columnSplitter: " "
  truncate: false
  truncateMarker: "â€¦"
  preserveNewLines: false
  paddingChr: " "
  showHeaders: true
  headingTransform: (key) ->
    key.toUpperCase()

  dataTransform: (cell, column, index) ->
    cell

module.exports = (items, options) ->
  options = options or {}
  columnConfigs = options.config or {}
  delete options.config

  maxLineWidth = options.maxLineWidth or Infinity
  delete options.maxLineWidth

  options = mixin(options, DEFAULTS)
  options.config = options.config or Object.create(null)
  options.spacing = options.spacing or "\n"
  options.preserveNewLines = !!options.preserveNewLines
  options.showHeaders = !!options.showHeaders
  options.columns = options.columns or options.include
  columnNames = options.columns or []
  items = toArray(items, columnNames)
  unless columnNames.length
    items.forEach (item) ->
      for columnName of item
        columnNames.push columnName  if columnNames.indexOf(columnName) is -1
      return

  columns = columnNames.reduce((columns, columnName) ->
    column = Object.create(options)
    columns[columnName] = mixin(column, columnConfigs[columnName])
    columns
  , Object.create(null))
  columnNames.forEach (columnName) ->
    column = columns[columnName]
    column.maxWidth = Math.ceil(column.maxWidth)
    column.minWidth = Math.ceil(column.minWidth)
    column.truncate = !!column.truncate
    return

  items = items.map((item) ->
    result = Object.create(null)
    columnNames.forEach (columnName) ->
      result[columnName] = (if item[columnName]? then item[columnName] else "")
      result[columnName] = "" + result[columnName]
      if columns[columnName].preserveNewLines
        result[columnName] = result[columnName].replace(/[^\S\n]/g, " ")
      else
        result[columnName] = result[columnName].replace(/\s/g, " ")
      return

    result
  )
  columnNames.forEach (columnName) ->
    column = columns[columnName]
    items = items.map((item, index) ->
      item[columnName] = column.dataTransform(item[columnName], column, index)
      item
    )
    return

  headers = {}
  if options.showHeaders
    columnNames.forEach (columnName) ->
      column = columns[columnName]
      headers[columnName] = column.headingTransform(columnName)
      return

    items.unshift headers
  columnNames.forEach (columnName) ->
    column = columns[columnName]
    column.width = items.map((item) ->
      item[columnName]
    ).reduce((min, cur) ->
      Math.max min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur)))
    , 0)
    return

  columnNames.forEach (columnName) ->
    column = columns[columnName]
    items = items.map((item) ->
      item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker)
      item
    )
    return

  columnNames.forEach (columnName) ->
    column = columns[columnName]
    items = items.map((item, index) ->
      cell = item[columnName]
      item[columnName] = splitIntoLines(cell, column.width)
      if column.truncate and item[columnName].length > 1
        item[columnName] = splitIntoLines(cell, column.width - wcwidth(column.truncateMarker))
        firstLine = item[columnName][0]
        item[columnName][0] += column.truncateMarker  unless endsWith(firstLine, column.truncateMarker)
        item[columnName] = item[columnName].slice(0, 1)
      item
    )
    return

  columnNames.forEach (columnName) ->
    column = columns[columnName]
    column.width = items.map((item) ->
      item[columnName].reduce ((min, cur) ->
        Math.max min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur)))
      ), 0
    ).reduce((min, cur) ->
      Math.max min, Math.min(column.maxWidth, Math.max(column.minWidth, cur))
    , 0)
    return

  rows = createRows(items, columns, columnNames, options.paddingChr)
  rows.reduce((output, row) ->
    output.concat row.reduce((rowOut, line) ->
      rowOut.concat line.join(options.columnSplitter)
    , [])
  , []).map((line) ->
    truncateString line, maxLineWidth
  ).join options.spacing
