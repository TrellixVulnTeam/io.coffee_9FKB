objectToString = (o) ->
  Object::toString.call o

# shim for Node's 'util' package
# DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).

###*
Clones (copies) an Object using deep copying.

This function supports circular references by default, but if you are certain
there are no circular references in your object, you can save some CPU time
by calling clone(obj, false).

Caution: if `circular` is false and `parent` contains circular references,
your program may enter an infinite loop and crash.

@param `parent` - the object to be cloned
@param `circular` - set to true if the object to be cloned may contain
circular references. (optional - true by default)
@param `depth` - set to a number if the object is only to be cloned to
a particular depth. (optional - defaults to Infinity)
@param `prototype` - sets the prototype to be used when cloning an object.
(optional - defaults to parent prototype).
###
clone = (parent, circular, depth, prototype) ->
  
  # maintain two arrays for circular references, where corresponding parents
  # and children have the same index
  
  # recurse this function so we don't reset allParents and allChildren
  _clone = (parent, depth) ->
    
    # cloning null always returns null
    return null  if parent is null
    return parent  if depth is 0
    child = undefined
    return parent  unless typeof parent is "object"
    if util.isArray(parent)
      child = []
    else if util.isRegExp(parent)
      child = new RegExp(parent.source, util.getRegExpFlags(parent))
      child.lastIndex = parent.lastIndex  if parent.lastIndex
    else if util.isDate(parent)
      child = new Date(parent.getTime())
    else if useBuffer and Buffer.isBuffer(parent)
      child = new Buffer(parent.length)
      parent.copy child
      return child
    else
      if typeof prototype is "undefined"
        child = Object.create(Object.getPrototypeOf(parent))
      else
        child = Object.create(prototype)
    if circular
      index = allParents.indexOf(parent)
      return allChildren[index]  unless index is -1
      allParents.push parent
      allChildren.push child
    for i of parent
      child[i] = _clone(parent[i], depth - 1)
    child
  allParents = []
  allChildren = []
  useBuffer = typeof Buffer isnt "undefined"
  circular = true  if typeof circular is "undefined"
  depth = Infinity  if typeof depth is "undefined"
  _clone parent, depth
"use strict"
util =
  isArray: (ar) ->
    Array.isArray(ar) or (typeof ar is "object" and objectToString(ar) is "[object Array]")

  isDate: (d) ->
    typeof d is "object" and objectToString(d) is "[object Date]"

  isRegExp: (re) ->
    typeof re is "object" and objectToString(re) is "[object RegExp]"

  getRegExpFlags: (re) ->
    flags = ""
    re.global and (flags += "g")
    re.ignoreCase and (flags += "i")
    re.multiline and (flags += "m")
    flags

module.exports = clone  if typeof module is "object"

###*
Simple flat clone using prototype, accepts only objects, usefull for property
override on FLAT configuration object (no nested props).

USE WITH CAUTION! This may not behave as you wish if you do not know how this
works.
###
clone.clonePrototype = (parent) ->
  return null  if parent is null
  c = ->

  c:: = parent
  new c()
