test = require("tap").test
lockFile = require("../lockfile.js")
path = require("path")
fs = require("fs")
touch = require("touch")

# On Unix systems, it uses ctime by default for staleness checks, since it's
# the most reliable.  However, because this test artificially sets some locks
# to an earlier time to simulate staleness, we use mtime here.
lockFile.filetime = "mtime"
test "setup", (t) ->
  try
    lockFile.unlockSync "basic-lock"
  try
    lockFile.unlockSync "sync-lock"
  try
    lockFile.unlockSync "never-forget"
  try
    lockFile.unlockSync "stale-lock"
  try
    lockFile.unlockSync "watch-lock"
  try
    lockFile.unlockSync "retry-lock"
  try
    lockFile.unlockSync "contentious-lock"
  try
    lockFile.unlockSync "stale-wait-lock"
  try
    lockFile.unlockSync "stale-windows-lock"
  t.end()
  return

test "lock contention", (t) ->
  gotlocks = 0
  N = 200
  delay = 10
  
  # allow for some time for each lock acquisition and release.
  # note that raising N higher will mean that the overhead
  # increases, because we're creating more and more watchers.
  # irl, you should never have several hundred contenders for a
  # single lock, so this situation is somewhat pathological.
  overhead = 200
  wait = N * overhead + delay
  
  # first make it locked, so that everyone has to wait
  lockFile.lock "contentious-lock", (er, lock) ->
    t.ifError er, "acquiring starter"
    throw er  if er
    t.pass "acquired starter lock"
    setTimeout (->
      lockFile.unlock "contentious-lock", (er) ->
        t.ifError er, "unlocking starter"
        throw er  if er
        t.pass "unlocked starter"
        return

      return
    ), delay
    return

  i = 0

  while i < N
    lockFile.lock "contentious-lock",
      wait: wait
    , (er, lock) ->
      throw er  if er
      lockFile.unlock "contentious-lock", (er) ->
        throw er  if er
        gotlocks++
        t.pass "locked and unlocked #" + gotlocks
        if gotlocks is N
          t.pass "got all locks"
          t.end()
        return

      return

    i++
  return

test "basic test", (t) ->
  lockFile.check "basic-lock", (er, locked) ->
    throw er  if er
    t.notOk locked
    lockFile.lock "basic-lock", (er) ->
      throw er  if er
      lockFile.lock "basic-lock", (er) ->
        t.ok er
        lockFile.check "basic-lock", (er, locked) ->
          throw er  if er
          t.ok locked
          lockFile.unlock "basic-lock", (er) ->
            throw er  if er
            lockFile.check "basic-lock", (er, locked) ->
              throw er  if er
              t.notOk locked
              t.end()
              return

            return

          return

        return

      return

    return

  return

test "sync test", (t) ->
  locked = undefined
  locked = lockFile.checkSync("sync-lock")
  t.notOk locked
  lockFile.lockSync "sync-lock"
  locked = lockFile.checkSync("sync-lock")
  t.ok locked
  lockFile.unlockSync "sync-lock"
  locked = lockFile.checkSync("sync-lock")
  t.notOk locked
  t.end()
  return

test "exit cleanup test", (t) ->
  child = require.resolve("./fixtures/child.js")
  node = process.execPath
  spawn = require("child_process").spawn
  spawn(node, [child]).on "exit", ->
    setTimeout (->
      locked = lockFile.checkSync("never-forget")
      t.notOk locked
      t.end()
      return
    ), 100
    return

  return

test "error exit cleanup test", (t) ->
  child = require.resolve("./fixtures/bad-child.js")
  node = process.execPath
  spawn = require("child_process").spawn
  spawn(node, [child]).on "exit", ->
    setTimeout (->
      locked = lockFile.checkSync("never-forget")
      t.notOk locked
      t.end()
      return
    ), 100
    return

  return

test "staleness test", (t) ->
  lockFile.lock "stale-lock", (er) ->
    throw er  if er
    
    # simulate 2s old
    touch.sync "stale-lock",
      time: new Date(Date.now() - 2000)

    opts = stale: 1
    lockFile.check "stale-lock", opts, (er, locked) ->
      throw er  if er
      t.notOk locked
      lockFile.lock "stale-lock", opts, (er) ->
        throw er  if er
        lockFile.unlock "stale-lock", (er) ->
          throw er  if er
          t.end()
          return

        return

      return

    return

  return

test "staleness sync test", (t) ->
  opts = stale: 1
  lockFile.lockSync "stale-lock"
  
  # simulate 2s old
  touch.sync "stale-lock",
    time: new Date(Date.now() - 2000)

  locked = undefined
  locked = lockFile.checkSync("stale-lock", opts)
  t.notOk locked
  lockFile.lockSync "stale-lock", opts
  lockFile.unlockSync "stale-lock"
  t.end()
  return

test "retries", (t) ->
  
  # next 5 opens will fail.
  opens = 5
  fs._open = fs.open
  fs.open = (path, mode, cb) ->
    if --opens is 0
      fs.open = fs._open
      return fs.open(path, mode, cb)
    er = new Error("bogus")
    
    # to be, or not to be, that is the question.
    er.code = (if opens % 2 then "EEXIST" else "ENOENT")
    process.nextTick cb.bind(null, er)
    return

  lockFile.lock "retry-lock",
    retries: opens
  , (er) ->
    throw er  if er
    t.equal opens, 0
    lockFile.unlockSync "retry-lock"
    t.end()
    return

  return

test "retryWait", (t) ->
  
  # next 5 opens will fail.
  opens = 5
  fs._open = fs.open
  fs.open = (path, mode, cb) ->
    if --opens is 0
      fs.open = fs._open
      return fs.open(path, mode, cb)
    er = new Error("bogus")
    
    # to be, or not to be, that is the question.
    er.code = (if opens % 2 then "EEXIST" else "ENOENT")
    process.nextTick cb.bind(null, er)
    return

  opts =
    retries: opens
    retryWait: 100

  lockFile.lock "retry-lock", opts, (er) ->
    throw er  if er
    t.equal opens, 0
    lockFile.unlockSync "retry-lock"
    t.end()
    return

  return

test "retry sync", (t) ->
  
  # next 5 opens will fail.
  opens = 5
  fs._openSync = fs.openSync
  fs.openSync = (path, mode) ->
    if --opens is 0
      fs.openSync = fs._openSync
      return fs.openSync(path, mode)
    er = new Error("bogus")
    
    # to be, or not to be, that is the question.
    er.code = (if opens % 2 then "EEXIST" else "ENOENT")
    throw erreturn

  opts = retries: opens
  lockFile.lockSync "retry-lock", opts
  t.equal opens, 0
  lockFile.unlockSync "retry-lock"
  t.end()
  return

test "wait and stale together", (t) ->
  
  # first locker.
  interval = undefined
  lockFile.lock "stale-wait-lock", (er) ->
    
    # keep refreshing the lock, so we keep it forever
    interval = setInterval(->
      touch.sync "stale-wait-lock"
      return
    , 10)
    
    # try to get another lock.  this must fail!
    opt =
      stale: 1000
      wait: 2000
      pollInterval: 1000

    lockFile.lock "stale-wait-lock", opt, (er) ->
      unless er
        t.fail "got second lock?  that unpossible!"
      else
        t.pass "second lock failed, as i have foreseen it"
      clearInterval interval
      t.end()
      return

    return

  return

test "stale windows file tunneling test", (t) ->
  
  # for windows only
  # nt file system tunneling feature will make file creation time not updated
  opts = stale: 1000
  lockFile.lockSync "stale-windows-lock"
  touch.sync "stale-windows-lock",
    time: new Date(Date.now() - 3000)

  locked = undefined
  lockFile.unlockSync "stale-windows-lock"
  lockFile.lockSync "stale-windows-lock", opts
  locked = lockFile.checkSync("stale-windows-lock", opts)
  t.ok locked, "should be locked and not stale"
  lockFile.lock "stale-windows-lock", opts, (er) ->
    unless er
      t.fail "got second lock?  impossible, windows file tunneling problem!"
    else
      t.pass "second lock failed, windows file tunneling problem fixed"
    t.end()
    return

  return

test "cleanup", (t) ->
  try
    lockFile.unlockSync "basic-lock"
  try
    lockFile.unlockSync "sync-lock"
  try
    lockFile.unlockSync "never-forget"
  try
    lockFile.unlockSync "stale-lock"
  try
    lockFile.unlockSync "watch-lock"
  try
    lockFile.unlockSync "retry-lock"
  try
    lockFile.unlockSync "contentious-lock"
  try
    lockFile.unlockSync "stale-wait-lock"
  try
    lockFile.unlockSync "stale-windows-lock"
  t.end()
  return

