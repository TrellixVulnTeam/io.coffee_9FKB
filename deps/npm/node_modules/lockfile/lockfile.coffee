hasOwnProperty = (obj, prop) ->
  Object::hasOwnProperty.call obj, prop

# cleanup

# XXX https://github.com/joyent/node/issues/3555
# Remove when node 0.8 is deprecated.

# cleanup

# best-effort.  unlocking an already-unlocked lock is a noop

# best-effort.  unlocking an already-unlocked lock is a noop

# if the file can be opened in readonly mode, then it's there.
# if the error is something other than ENOENT, then it's not.

# file exists.  however, might be stale

# try to engage the lock.
# if this succeeds, then we're in business.

# something other than "currently locked"
# maybe eperm or something.

# someone's got this one.  see if it's valid.

# Staleness checking algorithm
# 1. acquire $lock, fail
# 2. stat $lock, find that it is stale
# 3. acquire $lock.STALE
# 4. stat $lock, assert that it is still stale
# 5. unlink $lock
# 6. link $lock.STALE $lock
# 7. unlink $lock.STALE
# On any failure, clean up whatever we've done, and raise the error.
maybeStale = (originalEr, path, opts, hasStaleLock, cb) ->
  fs.stat path, (statEr, st) ->
    if statEr
      if statEr.code is "ENOENT"
        
        # expired already!
        opts.stale = false
        debug "lock stale enoent retry", path, opts
        exports.lock path, opts, cb
        return
      return cb(statEr)
    age = Date.now() - st[exports.filetime].getTime()
    return notStale(originalEr, path, opts, cb)  if age <= opts.stale
    debug "lock stale", path, opts
    if hasStaleLock
      exports.unlock path, (er) ->
        return cb(er)  if er
        debug "lock stale retry", path, opts
        fs.link path + ".STALE", path, (er) ->
          fs.unlink path + ".STALE", ->
            
            # best effort.  if the unlink fails, oh well.
            cb er
            return

          return

        return

    else
      debug "acquire .STALE file lock", opts
      exports.lock path + ".STALE", opts, (er) ->
        return cb(er)  if er
        maybeStale originalEr, path, opts, true, cb
        return

    return

  return
notStale = (er, path, opts, cb) ->
  
  # if we can't wait, then just call it a failure
  
  # poll for some ms for the lock to clear
  poll = ->
    debug "notStale, polling", path, opts
    exports.lock path, opts, cb
    return
  debug "notStale", path, opts
  return cb(er)  if typeof opts.wait isnt "number" or opts.wait <= 0
  now = Date.now()
  start = opts.start or now
  end = start + opts.wait
  return cb(er)  if end <= now
  debug "now=%d, wait until %d (delta=%d)", start, end, end - start
  wait = Math.min(end - start, opts.pollPeriod or 100)
  timer = setTimeout(poll, wait)
  return

# probably don't have subsecond resolution.
# round up the staleness indicator.
# Yes, this will be wrong 1/1000 times on platforms
# with subsecond stat precision, but that's acceptable
# in exchange for not mistakenly removing locks on
# most other systems.

# failed to lock!
retryThrow = (path, opts, er) ->
  if typeof opts.retries is "number" and opts.retries > 0
    newRT = opts.retries - 1
    debug "retryThrow", path, opts, newRT
    opts.retries = newRT
    return exports.lockSync(path, opts)
  throw erreturn
fs = require("fs")
wx = "wx"
if process.version.match(/^v0\.[0-6]/)
  c = require("constants")
  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL
os = require("os")
exports.filetime = "ctime"
exports.filetime = "mtime"  if os.platform() is "win32"
debug = undefined
util = require("util")
if util.debuglog
  debug = util.debuglog("LOCKFILE")
else if /\blockfile\b/i.test(process.env.NODE_DEBUG)
  debug = ->
    msg = util.format.apply(util, arguments)
    console.error "LOCKFILE %d %s", process.pid, msg
    return
else
  debug = ->
locks = {}
process.on "exit", ->
  debug "exit listener"
  Object.keys(locks).forEach exports.unlockSync
  return

if /^v0\.[0-8]\./.test(process.version)
  debug "uncaughtException, version = %s", process.version
  process.on "uncaughtException", H = (er) ->
    debug "uncaughtException"
    l = process.listeners("uncaughtException").filter((h) ->
      h isnt H
    )
    unless l.length
      try
        Object.keys(locks).forEach exports.unlockSync
      process.removeListener "uncaughtException", H
      throw er
    return

exports.unlock = (path, cb) ->
  debug "unlock", path
  delete locks[path]

  fs.unlink path, (unlinkEr) ->
    cb()
    return

  return

exports.unlockSync = (path) ->
  debug "unlockSync", path
  try
    fs.unlinkSync path
  delete locks[path]

  return

exports.check = (path, opts, cb) ->
  if typeof opts is "function"
    cb = opts
    opts = {}
  debug "check", path, opts
  fs.open path, "r", (er, fd) ->
    if er
      return cb(er)  if er.code isnt "ENOENT"
      return cb(null, false)
    unless opts.stale
      return fs.close(fd, (er) ->
        cb er, true
      )
    fs.fstat fd, (er, st) ->
      if er
        return fs.close(fd, (er2) ->
          cb er
        )
      fs.close fd, (er) ->
        age = Date.now() - st[exports.filetime].getTime()
        cb er, age <= opts.stale

      return

    return

  return

exports.checkSync = (path, opts) ->
  opts = opts or {}
  debug "checkSync", path, opts
  throw new Error("opts.wait not supported sync for obvious reasons")  if opts.wait
  try
    fd = fs.openSync(path, "r")
  catch er
    throw er  if er.code isnt "ENOENT"
    return false
  unless opts.stale
    try
      fs.closeSync fd
    return true
  if opts.stale
    try
      st = fs.fstatSync(fd)
    finally
      fs.closeSync fd
    age = Date.now() - st[exports.filetime].getTime()
    age <= opts.stale

req = 1
exports.lock = (path, opts, cb) ->
  if typeof opts is "function"
    cb = opts
    opts = {}
  opts.req = opts.req or req++
  debug "lock", path, opts
  opts.start = opts.start or Date.now()
  if typeof opts.retries is "number" and opts.retries > 0
    debug "has retries", opts.retries
    retries = opts.retries
    opts.retries = 0
    cb = ((orig) ->
      cb = (er, fd) ->
        retry = ->
          opts.start = Date.now()
          debug "retrying", opts.start
          exports.lock path, opts, cb
          return
        debug "retry-mutated callback"
        retries -= 1
        return orig(er, fd)  if not er or retries < 0
        debug "lock retry", path, opts
        if opts.retryWait
          setTimeout retry, opts.retryWait
        else
          retry()
        return
    )(cb)
  fs.open path, wx, (er, fd) ->
    unless er
      debug "locked", path, fd
      locks[path] = fd
      return fs.close(fd, ->
        cb()
      )
    return cb(er)  if er.code isnt "EEXIST"
    return notStale(er, path, opts, cb)  unless opts.stale
    maybeStale er, path, opts, false, cb

  return

exports.lockSync = (path, opts) ->
  opts = opts or {}
  opts.req = opts.req or req++
  debug "lockSync", path, opts
  throw new Error("opts.wait not supported sync for obvious reasons")  if opts.wait or opts.retryWait
  try
    fd = fs.openSync(path, wx)
    locks[path] = fd
    try
      fs.closeSync fd
    debug "locked sync!", path, fd
    return
  catch er
    return retryThrow(path, opts, er)  if er.code isnt "EEXIST"
    if opts.stale
      st = fs.statSync(path)
      ct = st[exports.filetime].getTime()
      opts.stale = 1000 * Math.ceil(opts.stale / 1000)  if not (ct % 1000) and (opts.stale % 1000)
      age = Date.now() - ct
      if age > opts.stale
        debug "lockSync stale", path, opts, age
        exports.unlockSync path
        return exports.lockSync(path, opts)
    debug "failed to lock", path, opts, er
    return retryThrow(path, opts, er)
  return
