monkeyPatch = ->
  Object.defineProperty Array::, "abbrev",
    value: ->
      abbrev this

    enumerable: false
    configurable: true
    writable: true

  Object.defineProperty Object::, "abbrev",
    value: ->
      abbrev Object.keys(this)

    enumerable: false
    configurable: true
    writable: true

  return
abbrev = (list) ->
  list = Array::slice.call(arguments, 0)  if arguments.length isnt 1 or not Array.isArray(list)
  i = 0
  l = list.length
  args = []

  while i < l
    args[i] = (if typeof list[i] is "string" then list[i] else String(list[i]))
    i++
  
  # sort them lexicographically, so that they're next to their nearest kin
  args = args.sort(lexSort)
  
  # walk through each, seeing how much it has in common with the next and previous
  abbrevs = {}
  prev = ""
  i = 0
  l = args.length

  while i < l
    current = args[i]
    next = args[i + 1] or ""
    nextMatches = true
    prevMatches = true
    continue  if current is next
    j = 0
    cl = current.length

    while j < cl
      curChar = current.charAt(j)
      nextMatches = nextMatches and curChar is next.charAt(j)
      prevMatches = prevMatches and curChar is prev.charAt(j)
      if not nextMatches and not prevMatches
        j++
        break
      j++
    prev = current
    if j is cl
      abbrevs[current] = current
      continue
    a = current.substr(0, j)

    while j <= cl
      abbrevs[a] = current
      a += current.charAt(j)
      j++
    i++
  abbrevs
lexSort = (a, b) ->
  (if a is b then 0 else (if a > b then 1 else -1))
module.exports = exports = abbrev.abbrev = abbrev
abbrev.monkeyPatch = monkeyPatch
