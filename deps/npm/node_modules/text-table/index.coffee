dotindex = (c) ->
  m = /\.[^.]*$/.exec(c)
  (if m then m.index + 1 else c.length)
reduce = (xs, f, init) ->
  return xs.reduce(f, init)  if xs.reduce
  i = 0
  acc = (if arguments.length >= 3 then init else xs[i++])
  while i < xs.length
    f acc, xs[i], i
    i++
  acc
forEach = (xs, f) ->
  return xs.forEach(f)  if xs.forEach
  i = 0

  while i < xs.length
    f.call xs, xs[i], i
    i++
  return
map = (xs, f) ->
  return xs.map(f)  if xs.map
  res = []
  i = 0

  while i < xs.length
    res.push f.call(xs, xs[i], i)
    i++
  res
module.exports = (rows_, opts) ->
  opts = {}  unless opts
  hsep = (if opts.hsep is `undefined` then "  " else opts.hsep)
  align = opts.align or []
  stringLength = opts.stringLength or (s) ->
    String(s).length

  dotsizes = reduce(rows_, (acc, row) ->
    forEach row, (c, ix) ->
      n = dotindex(c)
      acc[ix] = n  if not acc[ix] or n > acc[ix]
      return

    acc
  , [])
  rows = map(rows_, (row) ->
    map row, (c_, ix) ->
      c = String(c_)
      if align[ix] is "."
        index = dotindex(c)
        size = dotsizes[ix] + ((if /\./.test(c) then 1 else 2)) - (stringLength(c) - index)
        c + Array(size).join(" ")
      else
        c

  )
  sizes = reduce(rows, (acc, row) ->
    forEach row, (c, ix) ->
      n = stringLength(c)
      acc[ix] = n  if not acc[ix] or n > acc[ix]
      return

    acc
  , [])
  map(rows, (row) ->
    map(row, (c, ix) ->
      n = (sizes[ix] - stringLength(c)) or 0
      s = Array(Math.max(n + 1, 1)).join(" ")
      return s + c  if align[ix] is "r" or align[ix] is "."
      return Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ")  if align[ix] is "c"
      c + s
    ).join(hsep).replace /\s+$/, ""
  ).join "\n"
