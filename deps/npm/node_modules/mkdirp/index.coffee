mkdirP = (p, opts, f, made) ->
  if typeof opts is "function"
    f = opts
    opts = {}
  else opts = mode: opts  if not opts or typeof opts isnt "object"
  mode = opts.mode
  xfs = opts.fs or fs
  mode = 0777 & (~process.umask())  if mode is `undefined`
  made = null  unless made
  cb = f or ->

  p = path.resolve(p)
  xfs.mkdir p, mode, (er) ->
    unless er
      made = made or p
      return cb(null, made)
    switch er.code
      when "ENOENT"
        mkdirP path.dirname(p), opts, (er, made) ->
          if er
            cb er, made
          else
            mkdirP p, opts, cb, made
          return

      
      # In the case of any other error, just see if there's a dir
      # there already.  If so, then hooray!  If not, then something
      # is borked.
      else
        xfs.stat p, (er2, stat) ->
          
          # if the stat fails, then that's super weird.
          # let the original error be the failure reason.
          if er2 or not stat.isDirectory()
            cb er, made
          else
            cb null, made
          return


  return
path = require("path")
fs = require("fs")
module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP
mkdirP.sync = sync = (p, opts, made) ->
  opts = mode: opts  if not opts or typeof opts isnt "object"
  mode = opts.mode
  xfs = opts.fs or fs
  mode = 0777 & (~process.umask())  if mode is `undefined`
  made = null  unless made
  p = path.resolve(p)
  try
    xfs.mkdirSync p, mode
    made = made or p
  catch err0
    switch err0.code
      when "ENOENT"
        made = sync(path.dirname(p), opts, made)
        sync p, opts, made
      
      # In the case of any other error, just see if there's a dir
      # there already.  If so, then hooray!  If not, then something
      # is borked.
      else
        stat = undefined
        try
          stat = xfs.statSync(p)
        catch err1
          throw err0
        throw err0  unless stat.isDirectory()
  made
