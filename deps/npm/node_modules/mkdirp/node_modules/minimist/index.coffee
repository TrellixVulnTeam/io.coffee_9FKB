
# Using [\s\S] instead of . because js doesn't support the
# 'dotall' regex modifier. See:
# http://stackoverflow.com/a/1068308/13216
hasKey = (obj, keys) ->
  o = obj
  keys.slice(0, -1).forEach (key) ->
    o = (o[key] or {})
    return

  key = keys[keys.length - 1]
  key of o
setKey = (obj, keys, value) ->
  o = obj
  keys.slice(0, -1).forEach (key) ->
    o[key] = {}  if o[key] is `undefined`
    o = o[key]
    return

  key = keys[keys.length - 1]
  if o[key] is `undefined` or typeof o[key] is "boolean"
    o[key] = value
  else if Array.isArray(o[key])
    o[key].push value
  else
    o[key] = [
      o[key]
      value
    ]
  return
isNumber = (x) ->
  return true  if typeof x is "number"
  return true  if /^0x[0-9a-f]+$/i.test(x)
  /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test x
longest = (xs) ->
  Math.max.apply null, xs.map((x) ->
    x.length
  )
module.exports = (args, opts) ->
  setArg = (key, val) ->
    value = (if not flags.strings[key] and isNumber(val) then Number(val) else val)
    setKey argv, key.split("."), value
    (aliases[key] or []).forEach (x) ->
      setKey argv, x.split("."), value
      return

    return
  opts = {}  unless opts
  flags =
    bools: {}
    strings: {}

  [].concat(opts["boolean"]).filter(Boolean).forEach (key) ->
    flags.bools[key] = true
    return

  [].concat(opts.string).filter(Boolean).forEach (key) ->
    flags.strings[key] = true
    return

  aliases = {}
  Object.keys(opts.alias or {}).forEach (key) ->
    aliases[key] = [].concat(opts.alias[key])
    aliases[key].forEach (x) ->
      aliases[x] = [key].concat(aliases[key].filter((y) ->
        x isnt y
      ))
      return

    return

  defaults = opts["default"] or {}
  argv = _: []
  Object.keys(flags.bools).forEach (key) ->
    setArg key, (if defaults[key] is `undefined` then false else defaults[key])
    return

  notFlags = []
  if args.indexOf("--") isnt -1
    notFlags = args.slice(args.indexOf("--") + 1)
    args = args.slice(0, args.indexOf("--"))
  i = 0

  while i < args.length
    arg = args[i]
    if /^--.+=/.test(arg)
      m = arg.match(/^--([^=]+)=([\s\S]*)$/)
      setArg m[1], m[2]
    else if /^--no-.+/.test(arg)
      key = arg.match(/^--no-(.+)/)[1]
      setArg key, false
    else if /^--.+/.test(arg)
      key = arg.match(/^--(.+)/)[1]
      next = args[i + 1]
      if next isnt `undefined` and not /^-/.test(next) and not flags.bools[key] and ((if aliases[key] then not flags.bools[aliases[key]] else true))
        setArg key, next
        i++
      else if /^(true|false)$/.test(next)
        setArg key, next is "true"
        i++
      else
        setArg key, (if flags.strings[key] then "" else true)
    else if /^-[^-]+/.test(arg)
      letters = arg.slice(1, -1).split("")
      broken = false
      j = 0

      while j < letters.length
        next = arg.slice(j + 2)
        if next is "-"
          setArg letters[j], next
          continue
        if /[A-Za-z]/.test(letters[j]) and /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)
          setArg letters[j], next
          broken = true
          break
        if letters[j + 1] and letters[j + 1].match(/\W/)
          setArg letters[j], arg.slice(j + 2)
          broken = true
          break
        else
          setArg letters[j], (if flags.strings[letters[j]] then "" else true)
        j++
      key = arg.slice(-1)[0]
      if not broken and key isnt "-"
        if args[i + 1] and not /^(-|--)[^-]/.test(args[i + 1]) and not flags.bools[key] and ((if aliases[key] then not flags.bools[aliases[key]] else true))
          setArg key, args[i + 1]
          i++
        else if args[i + 1] and /true|false/.test(args[i + 1])
          setArg key, args[i + 1] is "true"
          i++
        else
          setArg key, (if flags.strings[key] then "" else true)
    else
      argv._.push (if flags.strings["_"] or not isNumber(arg) then arg else Number(arg))
    i++
  Object.keys(defaults).forEach (key) ->
    unless hasKey(argv, key.split("."))
      setKey argv, key.split("."), defaults[key]
      (aliases[key] or []).forEach (x) ->
        setKey argv, x.split("."), defaults[key]
        return

    return

  notFlags.forEach (key) ->
    argv._.push key
    return

  argv
