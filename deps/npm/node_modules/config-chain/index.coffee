
#recursively find a file...
# root

# if we don't know what it is, try json and fall back to ini
# if we know what it is, then it must be that.
ConfigChain = ->
  EE.apply this
  ProtoList.apply this, arguments
  @_awaiting = 0
  @_saving = 0
  @sources = {}
  return
ProtoList = require("proto-list")
path = require("path")
fs = require("fs")
ini = require("ini")
EE = require("events").EventEmitter
url = require("url")
http = require("http")
exports = module.exports = ->
  args = [].slice.call(arguments)
  conf = new ConfigChain()
  while args.length
    a = args.shift()
    conf.push (if "string" is typeof a then json(a) else a)  if a
  conf

find = exports.find = ->
  find = (start, rel) ->
    file = path.join(start, rel)
    try
      fs.statSync file
      return file
    catch err
      return find(path.dirname(start), rel)  if path.dirname(start) isnt start
    return
  rel = path.join.apply(null, [].slice.call(arguments))
  find __dirname, rel

parse = exports.parse = (content, file, type) ->
  content = "" + content
  unless type
    try
      return JSON.parse(content)
    catch er
      return ini.parse(content)
  else if type is "json"
    if @emit
      try
        return JSON.parse(content)
      catch er
        @emit "error", er
    else
      JSON.parse content
  else
    ini.parse content
  return

json = exports.json = ->
  args = [].slice.call(arguments).filter((arg) ->
    arg?
  )
  file = path.join.apply(null, args)
  content = undefined
  try
    content = fs.readFileSync(file, "utf-8")
  catch err
    return
  parse content, file, "json"

env = exports.env = (prefix, env) ->
  env = env or process.env
  obj = {}
  l = prefix.length
  for k of env
    obj[k.substring(l)] = env[k]  if k.indexOf(prefix) is 0
  obj

exports.ConfigChain = ConfigChain

# multi-inheritance-ish
extras = constructor:
  value: ConfigChain

Object.keys(EE::).forEach (k) ->
  extras[k] = Object.getOwnPropertyDescriptor(EE::, k)
  return

ConfigChain:: = Object.create(ProtoList::, extras)
ConfigChain::del = (key, where) ->
  
  # if not specified where, then delete from the whole chain, scorched
  # earth style
  if where
    target = @sources[where]
    target = target and target.data
    return @emit("error", new Error("not found " + where))  unless target
    delete target[key]
  else
    i = 0
    l = @list.length

    while i < l
      delete @list[i][key]
      i++
  this

ConfigChain::set = (key, value, where) ->
  target = undefined
  if where
    target = @sources[where]
    target = target and target.data
    return @emit("error", new Error("not found " + where))  unless target
  else
    target = @list[0]
    return @emit("error", new Error("cannot set, no confs!"))  unless target
  target[key] = value
  this

ConfigChain::get = (key, where) ->
  if where
    where = @sources[where]
    where = where.data  if where
    return where[key]  if where and Object.hasOwnProperty.call(where, key)
    return `undefined`
  @list[0][key]

ConfigChain::save = (where, type, cb) ->
  if typeof type is "function"
    cb = type
    type = null
  target = @sources[where]
  
  # TODO: maybe save() to a url target could be a PUT or something?
  # would be easy to swap out with a reddis type thing, too
  return @emit("error", new Error("bad save target: " + where))  if not target or not (target.path or target.source) or not target.data
  if target.source
    pref = target.prefix or ""
    Object.keys(target.data).forEach (k) ->
      target.source[pref + k] = target.data[k]
      return

    return this
  type = type or target.type
  data = target.data
  if target.type is "json"
    data = JSON.stringify(data)
  else
    data = ini.stringify(data)
  @_saving++
  fs.writeFile target.path, data, "utf8", ((er) ->
    @_saving--
    if er
      if cb
        return cb(er)
      else
        return @emit("error", er)
    if @_saving is 0
      cb()  if cb
      @emit "save"
    return
  ).bind(this)
  this

ConfigChain::addFile = (file, type, name) ->
  name = name or file
  marker = __source__: name
  @sources[name] =
    path: file
    type: type

  @push marker
  @_await()
  fs.readFile file, "utf8", ((er, data) ->
    @emit "error", er  if er
    @addString data, file, type, marker
    return
  ).bind(this)
  this

ConfigChain::addEnv = (prefix, env, name) ->
  name = name or "env"
  data = exports.env(prefix, env)
  @sources[name] =
    data: data
    source: env
    prefix: prefix

  @add data, name

ConfigChain::addUrl = (req, type, name) ->
  @_await()
  href = url.format(req)
  name = name or href
  marker = __source__: name
  @sources[name] =
    href: href
    type: type

  @push marker
  http.request(req, ((res) ->
    c = []
    ct = res.headers["content-type"]
    unless type
      type = (if ct.indexOf("json") isnt -1 then "json" else (if ct.indexOf("ini") isnt -1 then "ini" else (if href.match(/\.json$/) then "json" else (if href.match(/\.ini$/) then "ini" else null))))
      marker.type = type
    res.on("data", c.push.bind(c)).on("end", (->
      @addString Buffer.concat(c), href, type, marker
      return
    ).bind(this)).on "error", @emit.bind(this, "error")
    return
  ).bind(this)).on("error", @emit.bind(this, "error")).end()
  this

ConfigChain::addString = (data, file, type, marker) ->
  data = @parse(data, file, type)
  @add data, marker
  this

ConfigChain::add = (data, marker) ->
  if marker and typeof marker is "object"
    i = @list.indexOf(marker)
    return @emit("error", new Error("bad marker"))  if i is -1
    @splice i, 1, data
    marker = marker.__source__
    @sources[marker] = @sources[marker] or {}
    @sources[marker].data = data
    
    # we were waiting for this.  maybe emit 'load'
    @_resolve()
  else
    if typeof marker is "string"
      @sources[marker] = @sources[marker] or {}
      @sources[marker].data = data
    
    # trigger the load event if nothing was already going to do so.
    @_await()
    @push data
    process.nextTick @_resolve.bind(this)
  this

ConfigChain::parse = exports.parse
ConfigChain::_await = ->
  @_awaiting++
  return

ConfigChain::_resolve = ->
  @_awaiting--
  @emit "load", this  if @_awaiting is 0
  return
