
###*
Module dependencies.
###
build = (gyp, argv, callback) ->
  
  ###*
  Load the "config.gypi" file that was generated during "configure".
  ###
  loadConfigGypi = ->
    fs.readFile configPath, "utf8", (err, data) ->
      if err
        if err.code is "ENOENT"
          callback new Error("You must run `node-gyp configure` first!")
        else
          callback err
        return
      config = JSON.parse(data.replace(/\#.+\n/, ""))
      
      # get the 'arch', 'buildType', and 'nodeDir' vars from the config
      buildType = config.target_defaults.default_configuration
      arch = config.variables.target_arch
      nodeDir = config.variables.nodedir
      copyDevLib = config.variables.copy_dev_lib is "true"
      buildType = (if gyp.opts.debug then "Debug" else "Release")  if "debug" of gyp.opts
      buildType = "Release"  unless buildType
      log.verbose "build type", buildType
      log.verbose "architecture", arch
      log.verbose "node dev dir", nodeDir
      if win
        findSolutionFile()
      else
        doWhich()
      return

    return
  
  ###*
  On Windows, find the first build/*.sln file.
  ###
  findSolutionFile = ->
    glob "build/*.sln", (err, files) ->
      return callback(err)  if err
      return callback(new Error("Could not find *.sln file. Did you run \"configure\"?"))  if files.length is 0
      guessedSolution = files[0]
      log.verbose "found first Solution file", guessedSolution
      doWhich()
      return

    return
  
  ###*
  Uses node-which to locate the msbuild / make executable.
  ###
  doWhich = ->
    
    # First make sure we have the build command in the PATH
    which command, (err, execPath) ->
      if err
        if win and /not found/.test(err.message)
          
          # On windows and no 'msbuild' found. Let's guess where it is
          findMsbuild()
        else
          
          # Some other error or 'make' not found on Unix, report that to the user
          callback err
        return
      log.verbose "`which` succeeded for `" + command + "`", execPath
      copyNodeLib()
      return

    return
  
  ###*
  Search for the location of "msbuild.exe" file on Windows.
  ###
  findMsbuild = ->
    log.verbose "could not find \"msbuild.exe\" in PATH - finding location in registry"
    notfoundErr = new Error("Can't find \"msbuild.exe\". Do you have Microsoft Visual Studio C++ 2008+ installed?")
    cmd = "reg query \"HKLM\\Software\\Microsoft\\MSBuild\\ToolsVersions\" /s"
    cmd += " /reg:32"  if process.arch isnt "ia32"
    exec cmd, (err, stdout, stderr) ->
      reVers = /ToolsVersions\\([^\\]+)$/i
      rePath = /\r\n[ \t]+MSBuildToolsPath[ \t]+REG_SZ[ \t]+([^\r]+)/i
      msbuilds = []
      r = undefined
      msbuildPath = undefined
      return callback(notfoundErr)  if err
      stdout.split("\r\n\r\n").forEach (l) ->
        return l = l.trim()  unless l
        if r = reVers.exec(l.substring(0, l.indexOf("\r\n")))
          ver = parseFloat(r[1], 10)
          if ver >= 3.5
            if r = rePath.exec(l)
              msbuilds.push
                version: ver
                path: r[1]

        return

      msbuilds.sort (x, y) ->
        (if x.version < y.version then -1 else 1)

      (verifyMsbuild = ->
        return callback(notfoundErr)  unless msbuilds.length
        msbuildPath = path.resolve(msbuilds.pop().path, "msbuild.exe")
        fs.stat msbuildPath, (err, stat) ->
          if err
            if err.code is "ENOENT"
              if msbuilds.length
                return verifyMsbuild()
              else
                callback notfoundErr
            else
              callback err
            return
          command = msbuildPath
          copyNodeLib()
          return

        return
      )()
      return

    return
  
  ###*
  Copies the node.lib file for the current target architecture into the
  current proper dev dir location.
  ###
  copyNodeLib = ->
    return doBuild()  if not win or not copyDevLib
    buildDir = path.resolve(nodeDir, buildType)
    archNodeLibPath = path.resolve(nodeDir, arch, "node.lib")
    buildNodeLibPath = path.resolve(buildDir, "node.lib")
    mkdirp buildDir, (err, isNew) ->
      return callback(err)  if err
      log.verbose "\"" + buildType + "\" dir needed to be created?", isNew
      rs = fs.createReadStream(archNodeLibPath)
      ws = fs.createWriteStream(buildNodeLibPath)
      log.verbose "copying \"node.lib\" for " + arch, buildNodeLibPath
      rs.pipe ws
      rs.on "error", callback
      ws.on "error", callback
      rs.on "end", doBuild
      return

    return
  
  ###*
  Actually spawn the process and compile the module.
  ###
  doBuild = ->
    
    # Enable Verbose build
    verbose = log.levels[log.level] <= log.levels.verbose
    argv.push "V=1"  if not win and verbose
    argv.push "/clp:Verbosity=minimal"  if win and not verbose
    
    # Turn off the Microsoft logo on Windows
    argv.push "/nologo"  if win
    
    # Specify the build type, Release by default
    if win
      p = (if arch is "x64" then "x64" else "Win32")
      argv.push "/p:Configuration=" + buildType + ";Platform=" + p
      if jobs
        unless isNaN(parseInt(jobs, 10))
          argv.push "/m:" + parseInt(jobs, 10)
        else argv.push "/m:" + require("os").cpus().length  if jobs.toUpperCase() is "MAX"
    else
      argv.push "BUILDTYPE=" + buildType
      
      # Invoke the Makefile in the 'build' dir.
      argv.push "-C"
      argv.push "build"
      if jobs
        unless isNaN(parseInt(jobs, 10))
          argv.push "--jobs"
          argv.push parseInt(jobs, 10)
        else if jobs.toUpperCase() is "MAX"
          argv.push "--jobs"
          argv.push require("os").cpus().length
    if win
      
      # did the user specify their own .sln file?
      hasSln = argv.some((arg) ->
        path.extname(arg) is ".sln"
      )
      argv.unshift gyp.opts.solution or guessedSolution  unless hasSln
    proc = gyp.spawn(command, argv)
    proc.on "exit", onExit
    return
  
  ###*
  Invoked after the make/msbuild command exits.
  ###
  onExit = (code, signal) ->
    return callback(new Error("`" + command + "` failed with exit code: " + code))  if code isnt 0
    return callback(new Error("`" + command + "` got signal: " + signal))  if signal
    callback()
    return
  makeCommand = gyp.opts.make or process.env.MAKE or ((if process.platform.indexOf("bsd") isnt -1 and process.platform.indexOf("kfreebsd") is -1 then "gmake" else "make"))
  command = (if win then "msbuild" else makeCommand)
  buildDir = path.resolve("build")
  configPath = path.resolve(buildDir, "config.gypi")
  jobs = gyp.opts.jobs or process.env.JOBS
  buildType = undefined
  config = undefined
  arch = undefined
  nodeDir = undefined
  copyDevLib = undefined
  loadConfigGypi()
  return
module.exports = exports = build
fs = require("graceful-fs")
rm = require("rimraf")
path = require("path")
glob = require("glob")
log = require("npmlog")
which = require("which")
mkdirp = require("mkdirp")
exec = require("child_process").exec
win = process.platform is "win32"
exports.usage = "Invokes `" + ((if win then "msbuild" else "make")) + "` and builds the module"
