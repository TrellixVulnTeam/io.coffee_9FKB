((e) ->
  D = (e, t) ->
    n = (if t then r[d] else r[m])
    (if n.test(e) then new H(e, t) else null)
  F = (e, r) ->
    t = D(e, r)
    (if t then t.version else null)
  G = (e, r) ->
    t = D(e.trim().replace(/^[=v]+/, ""), r)
    (if t then t.version else null)
  H = (e, t) ->
    if e instanceof H
      if e.loose is t
        return e
      else
        e = e.version
    else throw new TypeError("Invalid Version: " + e)  if typeof e isnt "string"
    return new H(e, t)  unless this instanceof H
    @loose = t
    n = e.trim().match((if t then r[d] else r[m]))
    throw new TypeError("Invalid Version: " + e)  unless n
    @raw = e
    @major = +n[1]
    @minor = +n[2]
    @patch = +n[3]
    unless n[4]
      @prerelease = []
    else
      @prerelease = n[4].split(".").map((e) ->
        (if /^[0-9]+$/.test(e) then +e else e)
      )
    @build = (if n[5] then n[5].split(".") else [])
    @format()
    return
  J = (e, r, t, n) ->
    if typeof t is "string"
      n = t
      t = `undefined`
    try
      return new H(e, t).inc(r, n).version
    catch i
      return null
    return
  Q = (e, r) ->
    t = K.test(e)
    n = K.test(r)
    if t and n
      e = +e
      r = +r
    (if t and not n then -1 else (if n and not t then 1 else (if e < r then -1 else (if e > r then 1 else 0))))
  U = (e, r) ->
    Q r, e
  W = (e, r, t) ->
    new H(e, t).compare r
  Y = (e, r) ->
    W e, r, true
  er = (e, r, t) ->
    W r, e, t
  rr = (r, t) ->
    r.sort (r, n) ->
      e.compare r, n, t

  tr = (r, t) ->
    r.sort (r, n) ->
      e.rcompare r, n, t

  nr = (e, r, t) ->
    W(e, r, t) > 0
  ir = (e, r, t) ->
    W(e, r, t) < 0
  sr = (e, r, t) ->
    W(e, r, t) is 0
  ar = (e, r, t) ->
    W(e, r, t) isnt 0
  or = (e, r, t) ->
    W(e, r, t) >= 0
  fr = (e, r, t) ->
    W(e, r, t) <= 0
  ur = (e, r, t, n) ->
    i = undefined
    switch r
      when "==="
        e = e.version  if typeof e is "object"
        t = t.version  if typeof t is "object"
        i = e is t
      when "!=="
        e = e.version  if typeof e is "object"
        t = t.version  if typeof t is "object"
        i = e isnt t
      when "", "=", "=="
        i = sr(e, t, n)
      when "!="
        i = ar(e, t, n)
      when ">"
        i = nr(e, t, n)
      when ">="
        i = or_(e, t, n)
      when "<"
        i = ir(e, t, n)
      when "<="
        i = fr(e, t, n)
      else
        throw new TypeError("Invalid operator: " + r)
    i
  lr = (e, r) ->
    if e instanceof lr
      if e.loose is r
        return e
      else
        e = e.value
    return new lr(e, r)  unless this instanceof lr
    @loose = r
    @parse e
    if @semver is pr
      @value = ""
    else
      @value = @operator + @semver.version
    return
  cr = (e, r) ->
    return e  if e instanceof cr and e.loose is r
    return new cr(e, r)  unless this instanceof cr
    @loose = r
    @raw = e
    @set = e.split(/\s*\|\|\s*/).map((e) ->
      @parseRange e.trim()
    , this).filter((e) ->
      e.length
    )
    throw new TypeError("Invalid SemVer Range: " + e)  unless @set.length
    @format()
    return
  hr = (e, r) ->
    new cr(e, r).set.map (e) ->
      e.map((e) ->
        e.value
      ).join(" ").trim().split " "

  vr = (e, r) ->
    e = dr(e, r)
    e = gr(e, r)
    e = br(e, r)
    e = $r(e, r)
    e
  mr = (e) ->
    not e or e.toLowerCase() is "x" or e is "*"
  gr = (e, r) ->
    e.trim().split(/\s+/).map((e) ->
      wr e, r
    ).join " "
  wr = (e, t) ->
    n = (if t then r[T] else r[I])
    e.replace n, (e, r, t, n, i) ->
      s = undefined
      if mr(r)
        s = ""
      else if mr(t)
        s = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0"
      else if mr(n)
        s = ">=" + r + "." + t + ".0 <" + r + "." + (+t + 1) + ".0"
      else if i
        i = "-" + i  if i.charAt(0) isnt "-"
        s = ">=" + r + "." + t + "." + n + i + " <" + r + "." + (+t + 1) + ".0"
      else
        s = ">=" + r + "." + t + "." + n + " <" + r + "." + (+t + 1) + ".0"
      s

  dr = (e, r) ->
    e.trim().split(/\s+/).map((e) ->
      yr e, r
    ).join " "
  yr = (e, t) ->
    n = (if t then r[N] else r[z])
    e.replace n, (e, r, t, n, i) ->
      s = undefined
      if mr(r)
        s = ""
      else if mr(t)
        s = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0"
      else if mr(n)
        if r is "0"
          s = ">=" + r + "." + t + ".0 <" + r + "." + (+t + 1) + ".0"
        else
          s = ">=" + r + "." + t + ".0 <" + (+r + 1) + ".0.0"
      else if i
        i = "-" + i  if i.charAt(0) isnt "-"
        if r is "0"
          if t is "0"
            s = ">=" + r + "." + t + "." + n + i + " <" + r + "." + t + "." + (+n + 1)
          else
            s = ">=" + r + "." + t + "." + n + i + " <" + r + "." + (+t + 1) + ".0"
        else
          s = ">=" + r + "." + t + "." + n + i + " <" + (+r + 1) + ".0.0"
      else
        if r is "0"
          if t is "0"
            s = ">=" + r + "." + t + "." + n + " <" + r + "." + t + "." + (+n + 1)
          else
            s = ">=" + r + "." + t + "." + n + " <" + r + "." + (+t + 1) + ".0"
        else
          s = ">=" + r + "." + t + "." + n + " <" + (+r + 1) + ".0.0"
      s

  br = (e, r) ->
    e.split(/\s+/).map((e) ->
      jr e, r
    ).join " "
  jr = (e, t) ->
    e = e.trim()
    n = (if t then r[x] else r[E])
    e.replace n, (e, r, t, n, i, s) ->
      a = mr(t)
      o = a or mr(n)
      f = o or mr(i)
      u = f
      r = ""  if r is "=" and u
      if a
        if r is ">" or r is "<"
          e = "<0.0.0"
        else
          e = "*"
      else if r and u
        n = 0  if o
        i = 0  if f
        if r is ">"
          r = ">="
          if o
            t = +t + 1
            n = 0
            i = 0
          else if f
            n = +n + 1
            i = 0
        else if r is "<="
          r = "<"
          if o
            t = +t + 1
          else
            n = +n + 1
        e = r + t + "." + n + "." + i
      else if o
        e = ">=" + t + ".0.0 <" + (+t + 1) + ".0.0"
      else e = ">=" + t + "." + n + ".0 <" + t + "." + (+n + 1) + ".0"  if f
      e

  $r = (e, t) ->
    e.trim().replace r[O], ""
  kr = (e, r, t, n, i, s, a, o, f, u, l, p, c) ->
    if mr(t)
      r = ""
    else if mr(n)
      r = ">=" + t + ".0.0"
    else if mr(i)
      r = ">=" + t + "." + n + ".0"
    else
      r = ">=" + r
    if mr(f)
      o = ""
    else if mr(u)
      o = "<" + (+f + 1) + ".0.0"
    else if mr(l)
      o = "<" + f + "." + (+u + 1) + ".0"
    else if p
      o = "<=" + f + "." + u + "." + l + "-" + p
    else
      o = "<=" + o
    (r + " " + o).trim()
  Er = (e, r) ->
    t = 0

    while t < e.length
      return false  unless e[t].test(r)
      t++
    if r.prerelease.length
      t = 0

      while t < e.length
        return true  if e[t].semver is pr
        if e[t].semver.prerelease.length > 0
          n = e[t].semver
          return true  if n.major is r.major and n.minor is r.minor and n.patch is r.patch
        t++
      return false
    true
  xr = (e, r, t) ->
    try
      r = new cr(r, t)
    catch n
      return false
    r.test e
  Rr = (e, r, t) ->
    e.filter((e) ->
      xr e, r, t
    ).sort((e, r) ->
      er e, r, t
    )[0] or null
  Sr = (e, r) ->
    try
      return new cr(e, r).range or "*"
    catch t
      return null
    return
  Vr = (e, r, t) ->
    Tr e, r, "<", t
  Ir = (e, r, t) ->
    Tr e, r, ">", t
  Tr = (e, r, t, n) ->
    e = new H(e, n)
    r = new cr(r, n)
    i = undefined
    s = undefined
    a = undefined
    o = undefined
    f = undefined
    switch t
      when ">"
        i = nr
        s = fr
        a = ir
        o = ">"
        f = ">="
      when "<"
        i = ir
        s = or_
        a = nr
        o = "<"
        f = "<="
      else
        throw new TypeError("Must provide a hilo val of \"<\" or \">\"")
    return false  if xr(e, r, n)
    u = 0

    while u < r.set.length
      l = r.set[u]
      p = null
      c = null
      l.forEach (e) ->
        p = p or e
        c = c or e
        if i(e.semver, p.semver, n)
          p = e
        else c = e  if a(e.semver, c.semver, n)
        return

      return false  if p.operator is o or p.operator is f
      if (not c.operator or c.operator is o) and s(e, c.semver)
        return false
      else return false  if c.operator is f and a(e, c.semver)
      ++u
    true
  e = module.exports = H  if typeof module is "object" and module.exports is e
  e.SEMVER_SPEC_VERSION = "2.0.0"
  r = e.re = []
  t = e.src = []
  n = 0
  i = n++
  t[i] = "0|[1-9]\\d*"
  s = n++
  t[s] = "[0-9]+"
  a = n++
  t[a] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
  o = n++
  t[o] = "(" + t[i] + ")\\." + "(" + t[i] + ")\\." + "(" + t[i] + ")"
  f = n++
  t[f] = "(" + t[s] + ")\\." + "(" + t[s] + ")\\." + "(" + t[s] + ")"
  u = n++
  t[u] = "(?:" + t[i] + "|" + t[a] + ")"
  l = n++
  t[l] = "(?:" + t[s] + "|" + t[a] + ")"
  p = n++
  t[p] = "(?:-(" + t[u] + "(?:\\." + t[u] + ")*))"
  c = n++
  t[c] = "(?:-?(" + t[l] + "(?:\\." + t[l] + ")*))"
  h = n++
  t[h] = "[0-9A-Za-z-]+"
  v = n++
  t[v] = "(?:\\+(" + t[h] + "(?:\\." + t[h] + ")*))"
  m = n++
  g = "v?" + t[o] + t[p] + "?" + t[v] + "?"
  t[m] = "^" + g + "$"
  w = "[v=\\s]*" + t[f] + t[c] + "?" + t[v] + "?"
  d = n++
  t[d] = "^" + w + "$"
  y = n++
  t[y] = "((?:<|>)?=?)"
  b = n++
  t[b] = t[s] + "|x|X|\\*"
  j = n++
  t[j] = t[i] + "|x|X|\\*"
  $ = n++
  t[$] = "[v=\\s]*(" + t[j] + ")" + "(?:\\.(" + t[j] + ")" + "(?:\\.(" + t[j] + ")" + "(?:" + t[p] + ")?" + t[v] + "?" + ")?)?"
  k = n++
  t[k] = "[v=\\s]*(" + t[b] + ")" + "(?:\\.(" + t[b] + ")" + "(?:\\.(" + t[b] + ")" + "(?:" + t[c] + ")?" + t[v] + "?" + ")?)?"
  E = n++
  t[E] = "^" + t[y] + "\\s*" + t[$] + "$"
  x = n++
  t[x] = "^" + t[y] + "\\s*" + t[k] + "$"
  R = n++
  t[R] = "(?:~>?)"
  S = n++
  t[S] = "(\\s*)" + t[R] + "\\s+"
  r[S] = new RegExp(t[S], "g")
  V = "$1~"
  I = n++
  t[I] = "^" + t[R] + t[$] + "$"
  T = n++
  t[T] = "^" + t[R] + t[k] + "$"
  A = n++
  t[A] = "(?:\\^)"
  C = n++
  t[C] = "(\\s*)" + t[A] + "\\s+"
  r[C] = new RegExp(t[C], "g")
  M = "$1^"
  z = n++
  t[z] = "^" + t[A] + t[$] + "$"
  N = n++
  t[N] = "^" + t[A] + t[k] + "$"
  P = n++
  t[P] = "^" + t[y] + "\\s*(" + w + ")$|^$"
  Z = n++
  t[Z] = "^" + t[y] + "\\s*(" + g + ")$|^$"
  q = n++
  t[q] = "(\\s*)" + t[y] + "\\s*(" + w + "|" + t[$] + ")"
  r[q] = new RegExp(t[q], "g")
  L = "$1$2$3"
  X = n++
  t[X] = "^\\s*(" + t[$] + ")" + "\\s+-\\s+" + "(" + t[$] + ")" + "\\s*$"
  _ = n++
  t[_] = "^\\s*(" + t[k] + ")" + "\\s+-\\s+" + "(" + t[k] + ")" + "\\s*$"
  O = n++
  t[O] = "(<|>)?=?\\s*\\*"
  B = 0

  while B < n
    r[B] = new RegExp(t[B])  unless r[B]
    B++
  e.parse = D
  e.valid = F
  e.clean = G
  e.SemVer = H
  H::format = ->
    @version = @major + "." + @minor + "." + @patch
    @version += "-" + @prerelease.join(".")  if @prerelease.length
    @version

  H::inspect = ->
    "<SemVer \"" + this + "\">"

  H::toString = ->
    @version

  H::compare = (e) ->
    e = new H(e, @loose)  unless e instanceof H
    @compareMain(e) or @comparePre(e)

  H::compareMain = (e) ->
    e = new H(e, @loose)  unless e instanceof H
    Q(@major, e.major) or Q(@minor, e.minor) or Q(@patch, e.patch)

  H::comparePre = (e) ->
    e = new H(e, @loose)  unless e instanceof H
    if @prerelease.length and not e.prerelease.length
      return -1
    else if not @prerelease.length and e.prerelease.length
      return 1
    else return 0  if not @prerelease.length and not e.prerelease.length
    r = 0
    loop
      t = @prerelease[r]
      n = e.prerelease[r]
      if t is `undefined` and n is `undefined`
        return 0
      else if n is `undefined`
        return 1
      else if t is `undefined`
        return -1
      else if t is n
        continue
      else
        return Q(t, n)
      break unless ++r
    return

  H::inc = (e, r) ->
    switch e
      when "premajor"
        @prerelease.length = 0
        @patch = 0
        @minor = 0
        @major++
        @inc "pre", r
      when "preminor"
        @prerelease.length = 0
        @patch = 0
        @minor++
        @inc "pre", r
      when "prepatch"
        @prerelease.length = 0
        @inc "patch", r
        @inc "pre", r
      when "prerelease"
        @inc "patch", r  if @prerelease.length is 0
        @inc "pre", r
      when "major"
        @major++  if @minor isnt 0 or @patch isnt 0 or @prerelease.length is 0
        @minor = 0
        @patch = 0
        @prerelease = []
      when "minor"
        @minor++  if @patch isnt 0 or @prerelease.length is 0
        @patch = 0
        @prerelease = []
      when "patch"
        @patch++  if @prerelease.length is 0
        @prerelease = []
      when "pre"
        if @prerelease.length is 0
          @prerelease = [0]
        else
          t = @prerelease.length
          while --t >= 0
            if typeof @prerelease[t] is "number"
              @prerelease[t]++
              t = -2
          @prerelease.push 0  if t is -1
        if r
          if @prerelease[0] is r
            if isNaN(@prerelease[1])
              @prerelease = [
                r
                0
              ]
          else
            @prerelease = [
              r
              0
            ]
      else
        throw new Error("invalid increment argument: " + e)
    @format()
    this

  e.inc = J
  e.compareIdentifiers = Q
  K = /^[0-9]+$/
  e.rcompareIdentifiers = U
  e.compare = W
  e.compareLoose = Y
  e.rcompare = er
  e.sort = rr
  e.rsort = tr
  e.gt = nr
  e.lt = ir
  e.eq = sr
  e.neq = ar
  e.gte = or_
  e.lte = fr
  e.cmp = ur
  e.Comparator = lr
  pr = {}
  lr::parse = (e) ->
    t = (if @loose then r[P] else r[Z])
    n = e.match(t)
    throw new TypeError("Invalid comparator: " + e)  unless n
    @operator = n[1]
    @operator = ""  if @operator is "="
    unless n[2]
      @semver = pr
    else
      @semver = new H(n[2], @loose)
    return

  lr::inspect = ->
    "<SemVer Comparator \"" + this + "\">"

  lr::toString = ->
    @value

  lr::test = (e) ->
    return true  if @semver is pr
    e = new H(e, @loose)  if typeof e is "string"
    ur e, @operator, @semver, @loose

  e.Range = cr
  cr::inspect = ->
    "<SemVer Range \"" + @range + "\">"

  cr::format = ->
    @range = @set.map((e) ->
      e.join(" ").trim()
    ).join("||").trim()
    @range

  cr::toString = ->
    @range

  cr::parseRange = (e) ->
    t = @loose
    e = e.trim()
    n = (if t then r[_] else r[X])
    e = e.replace(n, kr)
    e = e.replace(r[q], L)
    e = e.replace(r[S], V)
    e = e.replace(r[C], M)
    e = e.split(/\s+/).join(" ")
    i = (if t then r[P] else r[Z])
    s = e.split(" ").map((e) ->
      vr e, t
    ).join(" ").split(/\s+/)
    if @loose
      s = s.filter((e) ->
        !!e.match(i)
      )
    s = s.map((e) ->
      new lr(e, t)
    )
    s

  e.toComparators = hr
  cr::test = (e) ->
    return false  unless e
    e = new H(e, @loose)  if typeof e is "string"
    r = 0

    while r < @set.length
      return true  if Er(@set[r], e)
      r++
    false

  e.satisfies = xr
  e.maxSatisfying = Rr
  e.validRange = Sr
  e.ltr = Vr
  e.gtr = Ir
  e.outside = Tr
  define e  if typeof define is "function" and define.amd
  return
) (if typeof exports is "object" then exports else (if typeof define is "function" and define.amd then {} else semver = {}))
