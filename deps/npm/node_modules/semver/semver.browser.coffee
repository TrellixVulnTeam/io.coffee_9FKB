((exports) ->
  
  # export the class if we are in a Node-like system.
  
  # The debug function is excluded entirely from the minified version.
  
  # Note: this is the semver.org version of the spec that it implements
  # Not necessarily the package version of this code.
  
  # The actual regexps go on exports.re
  
  # The following Regular Expressions can be used for tokenizing,
  # validating, and parsing SemVer version strings.
  
  # ## Numeric Identifier
  # A single `0`, or a non-zero digit followed by zero or more digits.
  
  # ## Non-numeric Identifier
  # Zero or more digits, followed by a letter or hyphen, and then zero or
  # more letters, digits, or hyphens.
  
  # ## Main Version
  # Three dot-separated numeric identifiers.
  
  # ## Pre-release Version Identifier
  # A numeric identifier, or a non-numeric identifier.
  
  # ## Pre-release Version
  # Hyphen, followed by one or more dot-separated pre-release version
  # identifiers.
  
  # ## Build Metadata Identifier
  # Any combination of digits, letters, or hyphens.
  
  # ## Build Metadata
  # Plus sign, followed by one or more period-separated build metadata
  # identifiers.
  
  # ## Full Version String
  # A main version, followed optionally by a pre-release version and
  # build metadata.
  
  # Note that the only major, minor, patch, and pre-release sections of
  # the version string are capturing groups.  The build metadata is not a
  # capturing group, because it should not ever be used in version
  # comparison.
  
  # like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
  # also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
  # common in the npm registry.
  
  # Something like "2.*" or "1.2.x".
  # Note that "x.x" is a valid xRange identifer, meaning "any version"
  # Only the first item is strictly required.
  
  # Tilde ranges.
  # Meaning is "reasonably at or greater than"
  
  # Caret ranges.
  # Meaning is "at least and backwards compatible with"
  
  # A simple gt/lt/eq thing, or just "" to indicate "any version"
  
  # An expression to strip any whitespace between the gtlt and the thing
  # it modifies, so that `> 1.2.3` ==> `>1.2.3`
  
  # this one has to use the /g flag
  
  # Something like `1.2.3 - 1.2.4`
  # Note that these all use the loose form, because they'll be
  # checked against either the strict or loose comparator form
  # later.
  
  # Star ranges basically just allow anything at all.
  
  # Compile to actual regexp objects.
  # All are flag-free, unless they were created above with a flag.
  parse = (version, loose) ->
    r = (if loose then re[LOOSE] else re[FULL])
    (if (r.test(version)) then new SemVer(version, loose) else null)
  valid = (version, loose) ->
    v = parse(version, loose)
    (if v then v.version else null)
  clean = (version, loose) ->
    s = parse(version.trim().replace(/^[=v]+/, ""), loose)
    (if s then s.version else null)
  SemVer = (version, loose) ->
    if version instanceof SemVer
      if version.loose is loose
        return version
      else
        version = version.version
    else throw new TypeError("Invalid Version: " + version)  if typeof version isnt "string"
    return new SemVer(version, loose)  unless this instanceof SemVer
    @loose = loose
    m = version.trim().match((if loose then re[LOOSE] else re[FULL]))
    throw new TypeError("Invalid Version: " + version)  unless m
    @raw = version
    
    # these are actually numbers
    @major = +m[1]
    @minor = +m[2]
    @patch = +m[3]
    
    # numberify any prerelease numeric ids
    unless m[4]
      @prerelease = []
    else
      @prerelease = m[4].split(".").map((id) ->
        (if (/^[0-9]+$/.test(id)) then +id else id)
      )
    @build = (if m[5] then m[5].split(".") else [])
    @format()
    return
  
  # NOT having a prerelease is > having one
  
  # preminor will bump the version up to the next minor release, and immediately
  # down to pre-release. premajor and prepatch work the same way.
  
  # If this is already a prerelease, it will bump to the next version
  # drop any prereleases that might already exist, since they are not
  # relevant at this point.
  
  # If the input is a non-prerelease version, this acts the same as
  # prepatch.
  
  # If this is a pre-major version, bump up to the same major version.
  # Otherwise increment major.
  # 1.0.0-5 bumps to 1.0.0
  # 1.1.0 bumps to 2.0.0
  
  # If this is a pre-minor version, bump up to the same minor version.
  # Otherwise increment minor.
  # 1.2.0-5 bumps to 1.2.0
  # 1.2.1 bumps to 1.3.0
  
  # If this is not a pre-release version, it will increment the patch.
  # If it is a pre-release it will bump up to the same patch version.
  # 1.2.0-5 patches to 1.2.0
  # 1.2.0 patches to 1.2.1
  
  # This probably shouldn't be used publicly.
  # 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
  # didn't increment anything
  
  # 1.2.0-beta.1 bumps to 1.2.0-beta.2,
  # 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
  inc = (version, release, loose, identifier) ->
    if typeof (loose) is "string"
      identifier = loose
      loose = `undefined`
    try
      return new SemVer(version, loose).inc(release, identifier).version
    catch er
      return null
    return
  compareIdentifiers = (a, b) ->
    anum = numeric.test(a)
    bnum = numeric.test(b)
    if anum and bnum
      a = +a
      b = +b
    (if (anum and not bnum) then -1 else (if (bnum and not anum) then 1 else (if a < b then -1 else (if a > b then 1 else 0))))
  rcompareIdentifiers = (a, b) ->
    compareIdentifiers b, a
  compare = (a, b, loose) ->
    new SemVer(a, loose).compare b
  compareLoose = (a, b) ->
    compare a, b, true
  rcompare = (a, b, loose) ->
    compare b, a, loose
  sort = (list, loose) ->
    list.sort (a, b) ->
      exports.compare a, b, loose

  rsort = (list, loose) ->
    list.sort (a, b) ->
      exports.rcompare a, b, loose

  gt = (a, b, loose) ->
    compare(a, b, loose) > 0
  lt = (a, b, loose) ->
    compare(a, b, loose) < 0
  eq = (a, b, loose) ->
    compare(a, b, loose) is 0
  neq = (a, b, loose) ->
    compare(a, b, loose) isnt 0
  gte = (a, b, loose) ->
    compare(a, b, loose) >= 0
  lte = (a, b, loose) ->
    compare(a, b, loose) <= 0
  cmp = (a, op, b, loose) ->
    ret = undefined
    switch op
      when "==="
        a = a.version  if typeof a is "object"
        b = b.version  if typeof b is "object"
        ret = a is b
      when "!=="
        a = a.version  if typeof a is "object"
        b = b.version  if typeof b is "object"
        ret = a isnt b
      when "", "=", "=="
        ret = eq(a, b, loose)
      when "!="
        ret = neq(a, b, loose)
      when ">"
        ret = gt(a, b, loose)
      when ">="
        ret = gte(a, b, loose)
      when "<"
        ret = lt(a, b, loose)
      when "<="
        ret = lte(a, b, loose)
      else
        throw new TypeError("Invalid operator: " + op)
    ret
  Comparator = (comp, loose) ->
    if comp instanceof Comparator
      if comp.loose is loose
        return comp
      else
        comp = comp.value
    return new Comparator(comp, loose)  unless this instanceof Comparator
    @loose = loose
    @parse comp
    if @semver is ANY
      @value = ""
    else
      @value = @operator + @semver.version
    return
  
  # if it literally is just '>' or '' then allow anything.
  Range = (range, loose) ->
    return range  if (range instanceof Range) and range.loose is loose
    return new Range(range, loose)  unless this instanceof Range
    @loose = loose
    
    # First, split based on boolean or ||
    @raw = range
    @set = range.split(/\s*\|\|\s*/).map((range) ->
      @parseRange range.trim()
    , this).filter((c) ->
      
      # throw out any that are not relevant for whatever reason
      c.length
    )
    throw new TypeError("Invalid SemVer Range: " + range)  unless @set.length
    @format()
    return
  
  # `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  
  # `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  
  # `~ 1.2.3` => `~1.2.3`
  
  # `^ 1.2.3` => `^1.2.3`
  
  # normalize spaces
  
  # At this point, the range is completely trimmed and
  # ready to be split into comparators.
  
  # in loose mode, throw out any that are not valid comparators
  
  # Mostly just for testing and legacy API reasons
  toComparators = (range, loose) ->
    new Range(range, loose).set.map (comp) ->
      comp.map((c) ->
        c.value
      ).join(" ").trim().split " "

  
  # comprised of xranges, tildes, stars, and gtlt's at this point.
  # already replaced the hyphen ranges
  # turn into a set of JUST comparators.
  parseComparator = (comp, loose) ->
    comp = replaceCarets(comp, loose)
    comp = replaceTildes(comp, loose)
    comp = replaceXRanges(comp, loose)
    comp = replaceStars(comp, loose)
    comp
  isX = (id) ->
    not id or id.toLowerCase() is "x" or id is "*"
  
  # ~, ~> --> * (any, kinda silly)
  # ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
  # ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
  # ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
  # ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
  # ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
  replaceTildes = (comp, loose) ->
    comp.trim().split(/\s+/).map((comp) ->
      replaceTilde comp, loose
    ).join " "
  replaceTilde = (comp, loose) ->
    r = (if loose then re[TILDELOOSE] else re[TILDE])
    comp.replace r, (_, M, m, p, pr) ->
      ret = undefined
      if isX(M)
        ret = ""
      else if isX(m)
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0"
      else if isX(p)
        
        # ~1.2 == >=1.2.0- <1.3.0-
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"
      else if pr
        pr = "-" + pr  if pr.charAt(0) isnt "-"
        ret = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0"
      
      # ~1.2.3 == >=1.2.3 <1.3.0
      else
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0"
      ret

  
  # ^ --> * (any, kinda silly)
  # ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
  # ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
  # ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
  # ^1.2.3 --> >=1.2.3 <2.0.0
  # ^1.2.0 --> >=1.2.0 <2.0.0
  replaceCarets = (comp, loose) ->
    comp.trim().split(/\s+/).map((comp) ->
      replaceCaret comp, loose
    ).join " "
  replaceCaret = (comp, loose) ->
    r = (if loose then re[CARETLOOSE] else re[CARET])
    comp.replace r, (_, M, m, p, pr) ->
      ret = undefined
      if isX(M)
        ret = ""
      else if isX(m)
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0"
      else if isX(p)
        if M is "0"
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"
        else
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0"
      else if pr
        pr = "-" + pr  if pr.charAt(0) isnt "-"
        if M is "0"
          if m is "0"
            ret = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + m + "." + (+p + 1)
          else
            ret = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0"
        else
          ret = ">=" + M + "." + m + "." + p + pr + " <" + (+M + 1) + ".0.0"
      else
        if M is "0"
          if m is "0"
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1)
          else
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0"
        else
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"
      ret

  replaceXRanges = (comp, loose) ->
    comp.split(/\s+/).map((comp) ->
      replaceXRange comp, loose
    ).join " "
  replaceXRange = (comp, loose) ->
    comp = comp.trim()
    r = (if loose then re[XRANGELOOSE] else re[XRANGE])
    comp.replace r, (ret, gtlt, M, m, p, pr) ->
      xM = isX(M)
      xm = xM or isX(m)
      xp = xm or isX(p)
      anyX = xp
      gtlt = ""  if gtlt is "=" and anyX
      if xM
        if gtlt is ">" or gtlt is "<"
          
          # nothing is allowed
          ret = "<0.0.0"
        else
          
          # nothing is forbidden
          ret = "*"
      else if gtlt and anyX
        
        # replace X with 0
        m = 0  if xm
        p = 0  if xp
        if gtlt is ">"
          
          # >1 => >=2.0.0
          # >1.2 => >=1.3.0
          # >1.2.3 => >= 1.2.4
          gtlt = ">="
          if xm
            M = +M + 1
            m = 0
            p = 0
          else if xp
            m = +m + 1
            p = 0
        else if gtlt is "<="
          
          # <=0.7.x is actually <0.8.0, since any 0.7.x should
          # pass.  Similarly, <=7.x is actually <8.0.0, etc.
          gtlt = "<"
          if xm
            M = +M + 1
          else
            m = +m + 1
        ret = gtlt + M + "." + m + "." + p
      else if xm
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0"
      else ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"  if xp
      ret

  
  # Because * is AND-ed with everything else in the comparator,
  # and '' means "any version", just remove the *s entirely.
  replaceStars = (comp, loose) ->
    
    # Looseness is ignored here.  star is always as loose as it gets!
    comp.trim().replace re[STAR], ""
  
  # This function is passed to string.replace(re[HYPHENRANGE])
  # M, m, patch, prerelease, build
  # 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
  # 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
  # 1.2 - 3.4 => >=1.2.0 <3.5.0
  hyphenReplace = ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) ->
    if isX(fM)
      from = ""
    else if isX(fm)
      from = ">=" + fM + ".0.0"
    else if isX(fp)
      from = ">=" + fM + "." + fm + ".0"
    else
      from = ">=" + from
    if isX(tM)
      to = ""
    else if isX(tm)
      to = "<" + (+tM + 1) + ".0.0"
    else if isX(tp)
      to = "<" + tM + "." + (+tm + 1) + ".0"
    else if tpr
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr
    else
      to = "<=" + to
    (from + " " + to).trim()
  
  # if ANY of the sets match ALL of its comparators, then pass
  testSet = (set, version) ->
    i = 0

    while i < set.length
      return false  unless set[i].test(version)
      i++
    if version.prerelease.length
      
      # Find the set of versions that are allowed to have prereleases
      # For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
      # That should allow `1.2.3-pr.2` to pass.
      # However, `1.2.4-alpha.notready` should NOT be allowed,
      # even though it's within the range set by the comparators.
      i = 0

      while i < set.length
        return true  if set[i].semver is ANY
        if set[i].semver.prerelease.length > 0
          allowed = set[i].semver
          return true  if allowed.major is version.major and allowed.minor is version.minor and allowed.patch is version.patch
        i++
      
      # Version has a -pre, but it's not one of the ones we like.
      return false
    true
  satisfies = (version, range, loose) ->
    try
      range = new Range(range, loose)
    catch er
      return false
    range.test version
  maxSatisfying = (versions, range, loose) ->
    versions.filter((version) ->
      satisfies version, range, loose
    ).sort((a, b) ->
      rcompare a, b, loose
    )[0] or null
  validRange = (range, loose) ->
    try
      
      # Return '*' instead of '' so that truthiness works.
      # This will throw if it's invalid anyway
      return new Range(range, loose).range or "*"
    catch er
      return null
    return
  
  # Determine if version is less than all the versions possible in the range
  ltr = (version, range, loose) ->
    outside version, range, "<", loose
  
  # Determine if version is greater than all the versions possible in the range.
  gtr = (version, range, loose) ->
    outside version, range, ">", loose
  outside = (version, range, hilo, loose) ->
    version = new SemVer(version, loose)
    range = new Range(range, loose)
    gtfn = undefined
    ltefn = undefined
    ltfn = undefined
    comp = undefined
    ecomp = undefined
    switch hilo
      when ">"
        gtfn = gt
        ltefn = lte
        ltfn = lt
        comp = ">"
        ecomp = ">="
      when "<"
        gtfn = lt
        ltefn = gte
        ltfn = gt
        comp = "<"
        ecomp = "<="
      else
        throw new TypeError("Must provide a hilo val of \"<\" or \">\"")
    
    # If it satisifes the range it is not outside
    return false  if satisfies(version, range, loose)
    
    # From now on, variable terms are as if we're in "gtr" mode.
    # but note that everything is flipped for the "ltr" function.
    i = 0

    while i < range.set.length
      comparators = range.set[i]
      high = null
      low = null
      comparators.forEach (comparator) ->
        high = high or comparator
        low = low or comparator
        if gtfn(comparator.semver, high.semver, loose)
          high = comparator
        else low = comparator  if ltfn(comparator.semver, low.semver, loose)
        return

      
      # If the edge version comparator has a operator then our version
      # isn't outside it
      return false  if high.operator is comp or high.operator is ecomp
      
      # If the lowest version comparator has an operator and our version
      # is less than it then it isn't higher than the range
      if (not low.operator or low.operator is comp) and ltefn(version, low.semver)
        return false
      else return false  if low.operator is ecomp and ltfn(version, low.semver)
      ++i
    true
  exports = module.exports = SemVer  if typeof module is "object" and module.exports is exports
  exports.SEMVER_SPEC_VERSION = "2.0.0"
  re = exports.re = []
  src = exports.src = []
  R = 0
  NUMERICIDENTIFIER = R++
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*"
  NUMERICIDENTIFIERLOOSE = R++
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+"
  NONNUMERICIDENTIFIER = R++
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
  MAINVERSION = R++
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\." + "(" + src[NUMERICIDENTIFIER] + ")\\." + "(" + src[NUMERICIDENTIFIER] + ")"
  MAINVERSIONLOOSE = R++
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[NUMERICIDENTIFIERLOOSE] + ")"
  PRERELEASEIDENTIFIER = R++
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")"
  PRERELEASEIDENTIFIERLOOSE = R++
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")"
  PRERELEASE = R++
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))"
  PRERELEASELOOSE = R++
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))"
  BUILDIDENTIFIER = R++
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+"
  BUILD = R++
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))"
  FULL = R++
  FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?"
  src[FULL] = "^" + FULLPLAIN + "$"
  LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?"
  LOOSE = R++
  src[LOOSE] = "^" + LOOSEPLAIN + "$"
  GTLT = R++
  src[GTLT] = "((?:<|>)?=?)"
  XRANGEIDENTIFIERLOOSE = R++
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*"
  XRANGEIDENTIFIER = R++
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*"
  XRANGEPLAIN = R++
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIER] + ")" + "(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?" + ")?)?"
  XRANGEPLAINLOOSE = R++
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?" + ")?)?"
  XRANGE = R++
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$"
  XRANGELOOSE = R++
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$"
  LONETILDE = R++
  src[LONETILDE] = "(?:~>?)"
  TILDETRIM = R++
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+"
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g")
  tildeTrimReplace = "$1~"
  TILDE = R++
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$"
  TILDELOOSE = R++
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$"
  LONECARET = R++
  src[LONECARET] = "(?:\\^)"
  CARETTRIM = R++
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+"
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g")
  caretTrimReplace = "$1^"
  CARET = R++
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$"
  CARETLOOSE = R++
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$"
  COMPARATORLOOSE = R++
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$"
  COMPARATOR = R++
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$"
  COMPARATORTRIM = R++
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")"
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g")
  comparatorTrimReplace = "$1$2$3"
  HYPHENRANGE = R++
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[XRANGEPLAIN] + ")" + "\\s*$"
  HYPHENRANGELOOSE = R++
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[XRANGEPLAINLOOSE] + ")" + "\\s*$"
  STAR = R++
  src[STAR] = "(<|>)?=?\\s*\\*"
  i = 0

  while i < R
    re[i] = new RegExp(src[i])  unless re[i]
    i++
  exports.parse = parse
  exports.valid = valid
  exports.clean = clean
  exports.SemVer = SemVer
  SemVer::format = ->
    @version = @major + "." + @minor + "." + @patch
    @version += "-" + @prerelease.join(".")  if @prerelease.length
    @version

  SemVer::inspect = ->
    "<SemVer \"" + this + "\">"

  SemVer::toString = ->
    @version

  SemVer::compare = (other) ->
    other = new SemVer(other, @loose)  unless other instanceof SemVer
    @compareMain(other) or @comparePre(other)

  SemVer::compareMain = (other) ->
    other = new SemVer(other, @loose)  unless other instanceof SemVer
    compareIdentifiers(@major, other.major) or compareIdentifiers(@minor, other.minor) or compareIdentifiers(@patch, other.patch)

  SemVer::comparePre = (other) ->
    other = new SemVer(other, @loose)  unless other instanceof SemVer
    if @prerelease.length and not other.prerelease.length
      return -1
    else if not @prerelease.length and other.prerelease.length
      return 1
    else return 0  if not @prerelease.length and not other.prerelease.length
    i = 0
    loop
      a = @prerelease[i]
      b = other.prerelease[i]
      if a is `undefined` and b is `undefined`
        return 0
      else if b is `undefined`
        return 1
      else if a is `undefined`
        return -1
      else if a is b
        continue
      else
        return compareIdentifiers(a, b)
      break unless ++i
    return

  SemVer::inc = (release, identifier) ->
    switch release
      when "premajor"
        @prerelease.length = 0
        @patch = 0
        @minor = 0
        @major++
        @inc "pre", identifier
      when "preminor"
        @prerelease.length = 0
        @patch = 0
        @minor++
        @inc "pre", identifier
      when "prepatch"
        @prerelease.length = 0
        @inc "patch", identifier
        @inc "pre", identifier
      when "prerelease"
        @inc "patch", identifier  if @prerelease.length is 0
        @inc "pre", identifier
      when "major"
        @major++  if @minor isnt 0 or @patch isnt 0 or @prerelease.length is 0
        @minor = 0
        @patch = 0
        @prerelease = []
      when "minor"
        @minor++  if @patch isnt 0 or @prerelease.length is 0
        @patch = 0
        @prerelease = []
      when "patch"
        @patch++  if @prerelease.length is 0
        @prerelease = []
      when "pre"
        if @prerelease.length is 0
          @prerelease = [0]
        else
          i = @prerelease.length
          while --i >= 0
            if typeof @prerelease[i] is "number"
              @prerelease[i]++
              i = -2
          @prerelease.push 0  if i is -1
        if identifier
          if @prerelease[0] is identifier
            if isNaN(@prerelease[1])
              @prerelease = [
                identifier
                0
              ]
          else
            @prerelease = [
              identifier
              0
            ]
      else
        throw new Error("invalid increment argument: " + release)
    @format()
    this

  exports.inc = inc
  exports.compareIdentifiers = compareIdentifiers
  numeric = /^[0-9]+$/
  exports.rcompareIdentifiers = rcompareIdentifiers
  exports.compare = compare
  exports.compareLoose = compareLoose
  exports.rcompare = rcompare
  exports.sort = sort
  exports.rsort = rsort
  exports.gt = gt
  exports.lt = lt
  exports.eq = eq
  exports.neq = neq
  exports.gte = gte
  exports.lte = lte
  exports.cmp = cmp
  exports.Comparator = Comparator
  ANY = {}
  Comparator::parse = (comp) ->
    r = (if @loose then re[COMPARATORLOOSE] else re[COMPARATOR])
    m = comp.match(r)
    throw new TypeError("Invalid comparator: " + comp)  unless m
    @operator = m[1]
    @operator = ""  if @operator is "="
    unless m[2]
      @semver = ANY
    else
      @semver = new SemVer(m[2], @loose)
    return

  Comparator::inspect = ->
    "<SemVer Comparator \"" + this + "\">"

  Comparator::toString = ->
    @value

  Comparator::test = (version) ->
    return true  if @semver is ANY
    version = new SemVer(version, @loose)  if typeof version is "string"
    cmp version, @operator, @semver, @loose

  exports.Range = Range
  Range::inspect = ->
    "<SemVer Range \"" + @range + "\">"

  Range::format = ->
    @range = @set.map((comps) ->
      comps.join(" ").trim()
    ).join("||").trim()
    @range

  Range::toString = ->
    @range

  Range::parseRange = (range) ->
    loose = @loose
    range = range.trim()
    hr = (if loose then re[HYPHENRANGELOOSE] else re[HYPHENRANGE])
    range = range.replace(hr, hyphenReplace)
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
    range = range.replace(re[TILDETRIM], tildeTrimReplace)
    range = range.replace(re[CARETTRIM], caretTrimReplace)
    range = range.split(/\s+/).join(" ")
    compRe = (if loose then re[COMPARATORLOOSE] else re[COMPARATOR])
    set = range.split(" ").map((comp) ->
      parseComparator comp, loose
    ).join(" ").split(/\s+/)
    if @loose
      set = set.filter((comp) ->
        !!comp.match(compRe)
      )
    set = set.map((comp) ->
      new Comparator(comp, loose)
    )
    set

  exports.toComparators = toComparators
  Range::test = (version) ->
    return false  unless version
    version = new SemVer(version, @loose)  if typeof version is "string"
    i = 0

    while i < @set.length
      return true  if testSet(@set[i], version)
      i++
    false

  exports.satisfies = satisfies
  exports.maxSatisfying = maxSatisfying
  exports.validRange = validRange
  exports.ltr = ltr
  exports.gtr = gtr
  exports.outside = outside
  
  # Use the define() function if we're in AMD land
  define exports  if typeof define is "function" and define.amd
  return
) (if typeof exports is "object" then exports else (if typeof define is "function" and define.amd then {} else semver = {}))
