
# looking up envs is a bit costly.
# Also, sometimes we want to have a fallback
# Pass in a callback to wait for the fallback on failures
# After the first lookup, always returns the same thing.
memo = (key, lookup, fallback) ->
  fell = false
  falling = false
  exports[key] = (cb) ->
    val = lookup()
    if not val and not fell and not falling and fallback
      fell = true
      falling = true
      exec fallback, (er, output, stderr) ->
        falling = false
        # oh well, we tried
        val = output.trim()  if er

    exports[key] = (cb) ->
      process.nextTick cb.bind(null, null, val)  if cb
      val

    process.nextTick cb.bind(null, null, val)  if cb and not falling
    val

  return
isWindows = process.platform is "win32"
path = require("path")
exec = require("child_process").exec
os = require("os")
memo "user", (->
  (if isWindows then process.env.USERDOMAIN + "\\" + process.env.USERNAME else process.env.USER)
), "whoami"
memo "prompt", ->
  (if isWindows then process.env.PROMPT else process.env.PS1)

memo "hostname", (->
  (if isWindows then process.env.COMPUTERNAME else process.env.HOSTNAME)
), "hostname"
memo "tmpdir", ->
  os.tmpDir()

memo "home", ->
  (if isWindows then process.env.USERPROFILE else process.env.HOME)

memo "path", ->
  (process.env.PATH or process.env.Path or process.env.path).split (if isWindows then ";" else ":")

memo "editor", ->
  process.env.EDITOR or process.env.VISUAL or ((if isWindows then "notepad.exe" else "vi"))

memo "shell", ->
  (if isWindows then process.env.ComSpec or "cmd" else process.env.SHELL or "bash")

