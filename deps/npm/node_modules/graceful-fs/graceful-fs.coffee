# Monkey-patching the fs module.
# It's ugly, but there is simply no other way to do this.

# fix up some busted stuff, mostly on windows and old nodes
noop = ->
open = (path, flags, mode, cb) ->
  if typeof mode is "function"
    cb = mode
    mode = null
  cb = noop  if typeof cb isnt "function"
  new OpenReq(path, flags, mode, cb)
  return
OpenReq = (path, flags, mode, cb) ->
  @path = path
  @flags = flags
  @mode = mode
  @cb = cb
  Req.call this
  return
readdir = (path, cb) ->
  cb = noop  if typeof cb isnt "function"
  new ReaddirReq(path, cb)
  return
ReaddirReq = (path, cb) ->
  @path = path
  @cb = cb
  Req.call this
  return
close = (fd, cb) ->
  debug "close", fd
  cb = noop  if typeof cb isnt "function"
  delete fds["fd" + fd]

  originalClose.call fs, fd, (er) ->
    onclose()
    cb er
    return

  return
closeSync = (fd) ->
  try
    return originalCloseSync(fd)
  finally
    onclose()
  return

# Req class
Req = ->
  
  # start processing
  @done = @done.bind(this)
  @failures = 0
  @process()
  return
enqueue = (req) ->
  queue.push req
  debug "enqueue %d %s", queue.length, req.constructor.name, req
  return
onclose = ->
  req = queue.shift()
  if req
    debug "process", req.constructor.name, req
    req.process()
  return
fs = module.exports = require("./fs.js")
assert = require("assert")
require "./polyfills.js"
util = require("util")
debug = noop
if util.debuglog
  debug = util.debuglog("gfs")
else if /\bgfs\b/i.test(process.env.NODE_DEBUG or "")
  debug = ->
    m = util.format.apply(util, arguments)
    m = "GFS: " + m.split(/\n/).join("\nGFS: ")
    console.error m
    return
if /\bgfs\b/i.test(process.env.NODE_DEBUG or "")
  process.on "exit", ->
    debug "fds", fds
    debug queue
    assert.equal queue.length, 0
    return

originalOpen = fs.open
fs.open = open
util.inherits OpenReq, Req
OpenReq::process = ->
  originalOpen.call fs, @path, @flags, @mode, @done
  return

fds = {}
OpenReq::done = (er, fd) ->
  debug "open done", er, fd
  fds["fd" + fd] = @path  if fd
  Req::done.call this, er, fd
  return

originalReaddir = fs.readdir
fs.readdir = readdir
util.inherits ReaddirReq, Req
ReaddirReq::process = ->
  originalReaddir.call fs, @path, @done
  return

ReaddirReq::done = (er, files) ->
  files = files.sort()  if files and files.sort
  Req::done.call this, er, files
  onclose()
  return

originalClose = fs.close
fs.close = close
originalCloseSync = fs.closeSync
fs.closeSync = closeSync
Req::done = (er, result) ->
  tryAgain = false
  if er
    code = er.code
    tryAgain = code is "EMFILE"
    tryAgain = tryAgain or code is "OK"  if process.platform is "win32"
  if tryAgain
    @failures++
    enqueue this
  else
    cb = @cb
    cb er, result
  return

queue = []
