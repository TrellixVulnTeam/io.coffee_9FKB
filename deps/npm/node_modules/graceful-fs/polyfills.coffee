
# (re-)implement some things that are known busted or missing.

# lchmod, broken prior to 0.6.2
# back-port the fix here.

# prefer to return the chmod error, if one occurs,
# but still try to close, and report closing errors if they occur.

# prefer to return the chmod error, if one occurs,
# but still try to close, and report closing errors if they occur.

# lutimes implementation, or no-op

# maybe utimensat will be bound soonish?

# https://github.com/isaacs/node-graceful-fs/issues/4
# Chown should not fail on einval or eperm if non-root.
# It should not fail on enosys ever, as this just indicates
# that a fs doesn't support the intended operation.
chownFix = (orig) ->
  return orig  unless orig
  (target, uid, gid, cb) ->
    orig.call fs, target, uid, gid, (er, res) ->
      er = null  if chownErOk(er)
      cb er, res
      return

chownFixSync = (orig) ->
  return orig  unless orig
  (target, uid, gid) ->
    try
      return orig.call(fs, target, uid, gid)
    catch er
      throw er  unless chownErOk(er)
    return

# ENOSYS means that the fs doesn't support the op. Just ignore
# that, because it doesn't matter.
#
# if there's no getuid, or if getuid() is something other
# than 0, and the error is EINVAL or EPERM, then just ignore
# it.
#
# This specific case is a silent failure in cp, install, tar,
# and most other unix tools that manage permissions.
#
# When running as root, or if other types of errors are
# encountered, then it's strict.
chownErOk = (er) ->
  return true  unless er
  return true  if er.code is "ENOSYS"
  nonroot = not process.getuid or process.getuid() isnt 0
  return true  if er.code is "EINVAL" or er.code is "EPERM"  if nonroot
  false
fs = require("./fs.js")
constants = require("constants")
origCwd = process.cwd
cwd = null
process.cwd = ->
  cwd = origCwd.call(process)  unless cwd
  cwd

chdir = process.chdir
process.chdir = (d) ->
  cwd = null
  chdir.call process, d
  return

if constants.hasOwnProperty("O_SYMLINK") and process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)
  fs.lchmod = (path, mode, callback) ->
    callback = callback or noop
    fs.open path, constants.O_WRONLY | constants.O_SYMLINK, mode, (err, fd) ->
      if err
        callback err
        return
      fs.fchmod fd, mode, (err) ->
        fs.close fd, (err2) ->
          callback err or err2
          return

        return

      return

    return

  fs.lchmodSync = (path, mode) ->
    fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
    err = undefined
    err2 = undefined
    try
      ret = fs.fchmodSync(fd, mode)
    catch er
      err = er
    try
      fs.closeSync fd
    catch er
      err2 = er
    throw (err or err2)  if err or err2
    ret
unless fs.lutimes
  if constants.hasOwnProperty("O_SYMLINK")
    fs.lutimes = (path, at, mt, cb) ->
      fs.open path, constants.O_SYMLINK, (er, fd) ->
        cb = cb or noop
        return cb(er)  if er
        fs.futimes fd, at, mt, (er) ->
          fs.close fd, (er2) ->
            cb er or er2

          return

        return

      return

    fs.lutimesSync = (path, at, mt) ->
      fd = fs.openSync(path, constants.O_SYMLINK)
      err = undefined
      err2 = undefined
      ret = undefined
      try
        ret = fs.futimesSync(fd, at, mt)
      catch er
        err = er
      try
        fs.closeSync fd
      catch er
        err2 = er
      throw (err or err2)  if err or err2
      ret
  else if fs.utimensat and constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")
    fs.lutimes = (path, at, mt, cb) ->
      fs.utimensat path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb
      return

    fs.lutimesSync = (path, at, mt) ->
      fs.utimensatSync path, at, mt, constants.AT_SYMLINK_NOFOLLOW
  else
    fs.lutimes = (_a, _b, _c, cb) ->
      process.nextTick cb
      return

    fs.lutimesSync = ->
fs.chown = chownFix(fs.chown)
fs.fchown = chownFix(fs.fchown)
fs.lchown = chownFix(fs.lchown)
fs.chmod = chownFix(fs.chmod)
fs.fchmod = chownFix(fs.fchmod)
fs.lchmod = chownFix(fs.lchmod)
fs.chownSync = chownFixSync(fs.chownSync)
fs.fchownSync = chownFixSync(fs.fchownSync)
fs.lchownSync = chownFixSync(fs.lchownSync)
fs.chmodSync = chownFix(fs.chmodSync)
fs.fchmodSync = chownFix(fs.fchmodSync)
fs.lchmodSync = chownFix(fs.lchmodSync)

# if lchmod/lchown do not exist, then make them no-ops
unless fs.lchmod
  fs.lchmod = (path, mode, cb) ->
    process.nextTick cb
    return

  fs.lchmodSync = ->
unless fs.lchown
  fs.lchown = (path, uid, gid, cb) ->
    process.nextTick cb
    return

  fs.lchownSync = ->

# on Windows, A/V software can lock the directory, causing this
# to fail with an EACCES or EPERM if the directory contains newly
# created files.  Try again on failure, for up to 1 second.
if process.platform is "win32"
  rename_ = fs.rename
  fs.rename = rename = (from, to, cb) ->
    start = Date.now()
    rename_ from, to, CB = (er) ->
      return rename_(from, to, CB)  if er and (er.code is "EACCES" or er.code is "EPERM") and Date.now() - start < 1000
      cb er
      return

    return

# if read() returns EAGAIN, then just try it again.
read = fs.read
fs.read = (fd, buffer, offset, length, position, callback_) ->
  callback = undefined
  if callback_ and typeof callback_ is "function"
    eagCounter = 0
    callback = (er, _, __) ->
      if er and er.code is "EAGAIN" and eagCounter < 10
        eagCounter++
        return read.call(fs, fd, buffer, offset, length, position, callback)
      callback_.apply this, arguments
      return
  read.call fs, fd, buffer, offset, length, position, callback

readSync = fs.readSync
fs.readSync = (fd, buffer, offset, length, position) ->
  eagCounter = 0
  loop
    try
      return readSync.call(fs, fd, buffer, offset, length, position)
    catch er
      if er.code is "EAGAIN" and eagCounter < 10
        eagCounter++
        continue
      throw er
  return
