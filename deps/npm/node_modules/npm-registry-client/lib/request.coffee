
# npm: means
# 1. https
# 2. send authorization
# 3. content-type is 'application/json' -- metadata
regRequest = (method, uri, options, cb_) ->
  assert uri, "must pass resource to load"
  assert cb_, "must pass callback"
  options = options or {}
  parsed = url.parse(uri)
  where = parsed.pathname
  what = options.body
  follow = ((if typeof options.follow is "boolean" then options.follow else true))
  @log.verbose "request", "on initialization, where is", where
  if parsed.search
    where = where + parsed.search
    parsed.search = ""
  parsed.pathname = "/"
  @log.verbose "request", "after pass 1, where is", where
  
  # Since there are multiple places where an error could occur,
  # don't let the cb be called more than once.
  cb = once(cb_)
  return cb(new Error("favicon.ico isn't a package, it's a picture."))  if where.match(/^\/?favicon.ico/)
  adduserChange = /^\/?-\/user\/org\.couchdb\.user:([^\/]+)\/-rev/
  isUserChange = where.match(adduserChange)
  adduserNew = /^\/?-\/user\/org\.couchdb\.user:([^\/]+)$/
  isNewUser = where.match(adduserNew)
  registry = url.format(parsed)
  alwaysAuth = @conf.getCredentialsByURI(registry).alwaysAuth
  isDelete = method is "DELETE"
  isWrite = what or isDelete
  return cb(new Error("trying to change user document without writing(?!)"))  if isUserChange and not isWrite
  
  # resolve to a full url on the registry
  unless where.match(/^https?:\/\//)
    @log.verbose "request", "url raw", where
    q = where.split("?")
    where = q.shift()
    q = q.join("?")
    where = "/" + where  if where.charAt(0) isnt "/"
    where = "." + where.split("/").map((p) ->
      p = p.trim()
      return p.replace(/\//g, encodeURIComponent("/"))  if p.match(/^org.couchdb.user/)
      p
    ).join("/")
    where += "?" + q  if q
    @log.verbose "request", "resolving registry", [
      registry
      where
    ]
    where = url.resolve(registry, where)
    @log.verbose "request", "after pass 2, where is", where
  authed = undefined
  
  # new users can *not* use auth, because they don't *have* auth yet
  if isNewUser
    @log.verbose "request", "new user, so can't send auth"
    authed = false
  else if alwaysAuth
    @log.verbose "request", "always-auth set; sending authorization"
    authed = true
  else if isWrite
    @log.verbose "request", "sending authorization for write operation"
    authed = true
  else
    
    # most of the time we don't want to auth
    @log.verbose "request", "no auth needed"
    authed = false
  self = this
  @attempt (operation) ->
    makeRequest.call self, method, where, what, options.etag, follow, authed, (er, parsed, raw, response) ->
      if not er or (er.message and er.message.match(/^SSL Error/))
        er.code = "ESSL"  if er
        return cb(er, parsed, raw, response)
      
      # Only retry on 408, 5xx or no `response`.
      statusCode = response and response.statusCode
      timeout = statusCode is 408
      serverError = statusCode >= 500
      statusRetry = not statusCode or timeout or serverError
      if er and statusRetry and operation.retry(er)
        self.log.info "retry", "will retry, error on last attempt: " + er
        return `undefined`
      if response
        self.log.verbose "headers", response.headers
        self.log.warn "notice", response.headers["npm-notice"]  if response.headers["npm-notice"]
      cb.apply null, arguments
      return

    return

  return
makeRequest = (method, where, what, etag, follow, authed, cb_) ->
  cb = once(cb_)
  parsed = url.parse(where)
  headers = {}
  
  # metadata should be compressed
  headers["accept-encoding"] = "gzip"
  er = @authify(authed, parsed, headers)
  return cb_(er)  if er
  opts = @initialize(parsed, method, "application/json", headers)
  opts.followRedirect = follow
  opts.encoding = null # tell request let body be Buffer instance
  if etag
    @log.verbose "etag", etag
    headers[(if method is "GET" then "if-none-match" else "if-match")] = etag
  
  # figure out wth "what" is
  if what
    if Buffer.isBuffer(what) or typeof what is "string"
      opts.body = what
      headers["content-type"] = "application/json"
      headers["content-length"] = Buffer.byteLength(what)
    else if what instanceof Stream
      headers["content-type"] = "application/octet-stream"
      headers["content-length"] = what.size  if what.size
    else
      delete what._etag

      opts.json = what
  @log.http "request", method, parsed.href or "/"
  done = requestDone.call(this, method, where, cb)
  req = request(opts, decodeResponseBody(done))
  req.on "error", cb
  req.on "socket", (s) ->
    s.on "error", cb
    return

  what.pipe req  if what and (what instanceof Stream)
  return
decodeResponseBody = (cb) ->
  (er, response, data) ->
    return cb(er, response, data)  if er
    
    # don't ever re-use connections that had server errors.
    # those sockets connect to the Bad Place!
    response.socket.destroy()  if response.socket and response.statusCode > 500
    return cb(er, response, data)  if response.headers["content-encoding"] isnt "gzip"
    zlib.gunzip data, (er, buf) ->
      return cb(er, response, data)  if er
      cb null, response, buf
      return

    return

# cb(er, parsed, raw, response)
requestDone = (method, where, cb) ->
  
  # expect data with any error codes
  
  # invalidate cache
  # This is irrelevant for commands that do etag caching, but
  # ls and view also have a timed cache, so this keeps the user
  # from thinking that it didn't work when it did.
  # Note that failure is an acceptable option here, since the
  # only result will be a stale cache for some helper commands.
  ((er, response, data) ->
    return cb(er)  if er
    urlObj = url.parse(where)
    urlObj.auth = "***"  if urlObj.auth
    @log.http response.statusCode, url.format(urlObj)
    parsed = undefined
    data = data.toString()  if Buffer.isBuffer(data)
    if data and typeof data is "string" and response.statusCode isnt 304
      try
        parsed = JSON.parse(data)
      catch ex
        ex.message += "\n" + data
        @log.verbose "bad json", data
        @log.error "registry", "error parsing json"
        return cb(ex, null, data, response)
    else if data
      parsed = data
      data = JSON.stringify(parsed)
    return cb(response.statusCode + " " + require("http").STATUS_CODES[response.statusCode], null, data, response)  if not data and response.statusCode >= 400
    er = null
    parsed._etag = response.headers.etag  if parsed and response.headers.etag
    if parsed and parsed.error and response.statusCode >= 400
      w = url.parse(where).pathname.substr(1)
      name = undefined
      unless w.match(/^-/)
        w = w.split("/")
        name = w[w.indexOf("_rewrite") + 1]
      if name and parsed.error is "not_found"
        er = new Error("404 Not Found: " + name)
      else
        er = new Error(parsed.error + " " + (parsed.reason or "") + ": " + w)
      er.pkgid = name  if name
      er.statusCode = response.statusCode
      er.code = "E" + er.statusCode
    else if method isnt "HEAD" and method isnt "GET"
      rm @cacheFile(where), ->

    cb er, parsed, data, response
  ).bind this
assert = require("assert")
url = require("url")
zlib = require("zlib")
Stream = require("stream").Stream
rm = require("rimraf")
request = require("request")
once = require("once")
module.exports = regRequest
