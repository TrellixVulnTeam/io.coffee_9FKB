
# fetch the data
# modify to remove the version in question
# If no versions remaining, then DELETE
# else, PUT the modified data
# delete the tarball
unpublish = (uri, ver, cb) ->
  if typeof cb isnt "function"
    cb = ver
    ver = null
  @get uri + "?write=true",
    timeout: -1
    follow: false
  
  # remove all if no version specified
  
  # if it was the only version, then delete the whole package.
  , ((er, data) ->
    if er
      @log.info "unpublish", uri + " not published"
      return cb()
    unless ver
      @log.info "unpublish", "No version specified, removing all"
      return @request("DELETE", uri + "/-rev/" + data._rev, null, cb)
    versions = data.versions or {}
    versionPublic = versions.hasOwnProperty(ver)
    dist = undefined
    unless versionPublic
      @log.info "unpublish", uri + "@" + ver + " not published"
    else
      dist = versions[ver].dist
      @log.verbose "unpublish", "removing attachments", dist
    delete versions[ver]

    unless Object.keys(versions).length
      @log.info "unpublish", "No versions remain, removing entire package"
      return @request("DELETE", uri + "/-rev/" + data._rev, null, cb)
    return cb()  unless versionPublic
    latestVer = data["dist-tags"].latest
    for tag of data["dist-tags"]
      delete data["dist-tags"][tag]  if data["dist-tags"][tag] is ver
    data["dist-tags"].latest = Object.getOwnPropertyNames(versions).sort(semver.compareLoose).pop()  if latestVer is ver
    rev = data._rev
    delete data._revisions

    delete data._attachments

    cb_ = detacher.call(this, uri, data, dist, cb)
    @request "PUT", uri + "/-rev/" + rev,
      body: data
    , ((er) ->
      @log.error "unpublish", "Failed to update data"  if er
      cb_ er
      return
    ).bind(this)
    return
  ).bind(this)
  return
detacher = (uri, data, dist, cb) ->
  ((er) ->
    return cb(er)  if er
    @get escape(uri, data.name), null, ((er, data) ->
      return cb(er)  if er
      tb = url.parse(dist.tarball)
      detach.call this, uri, data, tb.pathname, data._rev, ((er) ->
        return cb(er)  if er or not dist.bin
        chain Object.keys(dist.bin).map((bt) ->
          ((cb) ->
            d = dist.bin[bt]
            detach.call this, uri, data, url.parse(d.tarball).pathname, null, cb
            return
          ).bind this
        , this), cb
        return
      ).bind(this)
      return
    ).bind(this)
    return
  ).bind this
detach = (uri, data, path, rev, cb) ->
  if rev
    path += "/-rev/" + rev
    @log.info "detach", path
    return @request("DELETE", url.resolve(uri, path), null, cb)
  @get escape(uri, data.name), null, ((er, data) ->
    rev = data._rev
    return cb(new Error("No _rev found in " + data._id))  unless rev
    detach.call this, data, path, rev, cb
    return
  ).bind(this)
  return
escape = (base, name) ->
  escaped = name.replace(/\//, "%2f")
  url.resolve base, escaped
module.exports = unpublish
semver = require("semver")
url = require("url")
chain = require("slide").chain
