fetch = (uri, headers, cb) ->
  assert uri, "must pass resource to fetch"
  assert cb, "must pass callback"
  headers = {}  unless headers
  cb = once(cb)
  client = this
  @attempt (operation) ->
    makeRequest.call client, uri, headers, (er, req) ->
      return cb(er)  if er
      req.on "error", (er) ->
        client.log.info "retry", "will retry, error on last attempt: " + er  if operation.retry(er)
        return

      req.on "response", (res) ->
        client.log.http "fetch", "" + res.statusCode, uri
        er = undefined
        statusCode = res and res.statusCode
        if statusCode is 200
          
          # Work around bug in node v0.10.0 where the CryptoStream
          # gets stuck and never starts reading again.
          res.resume()
          unstick res  if process.version is "v0.10.0"
          return cb(null, res)
        
        # Only retry on 408, 5xx or no `response`.
        else if statusCode is 408
          er = new Error("request timed out")
        else er = new Error("server error " + statusCode)  if statusCode >= 500
        if er and operation.retry(er)
          client.log.info "retry", "will retry, error on last attempt: " + er
        else
          cb new Error("fetch failed with status code " + statusCode)
        return

      return

    return

  return
unstick = (response) ->
  response.resume = (orig) ->
    ->
      ret = orig.apply(response, arguments)
      response.socket.encrypted.read 0  if response.socket.encrypted
      ret
  (response.resume)
  return
makeRequest = (remote, headers, cb) ->
  parsed = url.parse(remote)
  @log.http "fetch", "GET", parsed.href
  er = @authify(@conf.getCredentialsByURI(remote).alwaysAuth, parsed, headers)
  return cb(er)  if er
  opts = @initialize(parsed, "GET", "application/x-tar", headers)
  
  # always want to follow redirects for fetch
  opts.followRedirect = true
  cb null, request(opts)
  return
assert = require("assert")
url = require("url")
request = require("request")
once = require("once")
module.exports = fetch
