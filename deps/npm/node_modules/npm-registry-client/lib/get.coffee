
###*
options:

timeout: request timeouts
follow:  follow redirects
staleOk: stale results are OK
stat:    results of checking for cached metadata
data:    the cached metadata
###
get = (uri, options, cb) ->
  assert uri, "must have URL to fetch"
  assert cb, "must have callback"
  options = {}  unless options
  parsed = url.parse(uri)
  assert parsed.protocol, "must have a URL that starts with npm:, http:, or https:"
  cache = @cacheFile(uri) + "/.cache.json"
  
  # /-/all is special.
  # It uses timestamp-based caching and partial updates,
  # because it is a monster.
  return requestAll.call(this, uri, cache, cb)  if parsed.pathname is "/-/all"
  
  # If the GET is part of a write operation (PUT or DELETE), then
  # skip past the cache entirely, but still save the results.
  return get_.call(this, uri, cache, options, cb)  if uri.match(/\?write=true$/)
  fs.stat cache, ((er, stat) ->
    unless er
      fs.readFile cache, ((er, data) ->
        try
          data = JSON.parse(data)
        catch ex
          data = null
        options.stat = stat
        options.data = data
        get_.call this, uri, cache, options, cb
        return
      ).bind(this)
    else
      get_.call this, uri, cache, options, cb
    return
  ).bind(this)
  return
requestAll = (uri, cache, cb) ->
  @log.info "get", cache
  mkdir path.dirname(cache), ((er) ->
    return cb(er)  if er
    fs.readFile cache, ((er, data) ->
      return requestAll_.call(this, uri, 0, {}, cache, cb)  if er
      try
        data = JSON.parse(data)
      catch ex
        fs.writeFile cache, "{}", ((er) ->
          return cb(new Error("Broken cache."))  if er
          requestAll_.call this, uri, 0, {}, cache, cb
        ).bind(this)
      t = +data._updated or 0
      requestAll_.call this, uri, t, data, cache, cb
      return
    ).bind(this)
    return
  ).bind(this)
  return
requestAll_ = (uri, c, data, cache, cb) ->
  
  # use the cache and update in the background if it's not too old
  if Date.now() - c < 60000
    cb null, data
    cb = ->
  if c is 0
    @log.warn "", "Building the local index for the first time, please be patient"
    uri = url.resolve(uri, "/-/all")
  else
    uri = url.resolve(uri, "/-/all/since?stale=update_after&startkey=" + c)
  @request "GET", uri, null, (er, updates, _, res) ->
    return cb(er, data)  if er
    headers = res.headers
    updated = updates._updated or Date.parse(headers.date)
    Object.keys(updates).forEach (p) ->
      data[p] = updates[p]
      return

    data._updated = updated
    fs.writeFile cache, JSON.stringify(data), (er) ->
      delete data._updated

      cb er, data

    return

  return
get_ = (uri, cache, options, cb) ->
  staleOk = (if options.staleOk is `undefined` then false else options.staleOk)
  follow = options.follow
  data = options.data
  stat = options.stat
  etag = undefined
  timeout = (if options.timeout is `undefined` then -1 else options.timeout)
  timeout = Math.min(timeout, @conf.get("cache-max") or 0)
  timeout = Math.max(timeout, @conf.get("cache-min") or -Infinity)
  timeout = Math.max(timeout, 60000)  if process.env.COMP_CWORD isnt `undefined` and process.env.COMP_LINE isnt `undefined` and process.env.COMP_POINT isnt `undefined`
  etag = data._etag  if data and data._etag
  if timeout and timeout > 0 and options.stat and options.data
    if (Date.now() - stat.mtime.getTime()) / 1000 < timeout
      @log.verbose "registry.get", uri, "not expired, no request"
      delete data._etag

      return cb(null, data, JSON.stringify(data),
        statusCode: 304
      )
    if staleOk
      @log.verbose "registry.get", uri, "staleOk, background update"
      delete data._etag

      process.nextTick cb.bind(null, null, data, JSON.stringify(data),
        statusCode: 304
      )
      cb = ->
  @request "GET", uri,
    etag: etag
    follow: follow
  
  # if we get an error talking to the registry, but we have it
  # from the cache, then just pretend we got it.
  
  # just give the write the old college try.  if it fails, whatever.
  , ((er, remoteData, raw, response) ->
    saved = ->
      delete data._etag

      cb er, data, raw, response
      return
    if er and cache and data and not data.error
      er = null
      response = statusCode: 304
    if response
      @log.silly "registry.get", "cb", [
        response.statusCode
        response.headers
      ]
      if response.statusCode is 304 and etag
        remoteData = data
        @log.verbose "etag", uri + " from cache"
    data = remoteData
    er = er or new Error("failed to fetch from registry: " + uri)  unless data
    return cb(er, data, raw, response)  if er
    saveToCache.call this, cache, data, saved
    return
  ).bind(this)
  return
saveToCache = (cache, data, saved) ->
  if @_cacheStat
    cs = @_cacheStat
    return saveToCache_.call(this, cache, data, cs.uid, cs.gid, saved)
  
  # if this fails, oh well.
  fs.stat @conf.get("cache"), ((er, st) ->
    if er
      return fs.stat(process.env.HOME or "", ((er, st) ->
        return saved()  if er
        @_cacheStat = st
        saveToCache.call this, cache, data, saved
      ).bind(this))
    @_cacheStat = st or
      uid: null
      gid: null

    saveToCache.call this, cache, data, saved
  ).bind(this)
  return
saveToCache_ = (cache, data, uid, gid, saved) ->
  mkdir path.dirname(cache), (er, made) ->
    return saved()  if er
    fs.writeFile cache, JSON.stringify(data), (er) ->
      return saved()  if er or uid is null or gid is null
      chownr made or cache, uid, gid, saved
      return

    return

  return
module.exports = get
fs = require("graceful-fs")
assert = require("assert")
path = require("path")
mkdir = require("mkdirp")
chownr = require("chownr")
url = require("url")
