escaped = (name) ->
  name.replace "/", "%2f"
publish = (uri, data, tarball, cb) ->
  c = @conf.getCredentialsByURI(uri)
  unless c.token or (c.auth and c.username and c.email)
    er = new Error("auth and email required for publishing")
    er.code = "ENEEDAUTH"
    return cb(er)
  try
    fixNameField data, true
  catch er
    return cb(er)
  ver = semver.clean(data.version)
  return cb(new Error("invalid semver: " + data.version))  unless ver
  data.version = ver
  self = this
  fs.stat tarball, (er, s) ->
    return cb(er)  if er
    fs.readFile tarball, (er, tarbuffer) ->
      return cb(er)  if er
      putFirst.call self, uri, data, tarbuffer, s, c, cb
      return

    return

  return
putFirst = (registry, data, tarbuffer, stat, creds, cb) ->
  
  # optimistically try to PUT all in one single atomic thing.
  # If 409, then GET and merge, try again.
  # If other error, then fail.
  root =
    _id: data.name
    name: data.name
    description: data.description
    "dist-tags": {}
    versions: {}
    readme: data.readme or ""

  unless creds.token
    root.maintainers = [
      name: creds.username
      email: creds.email
    ]
    data.maintainers = JSON.parse(JSON.stringify(root.maintainers))
  root.versions[data.version] = data
  tag = data.tag or @conf.get("tag") or "latest"
  root["dist-tags"][tag] = data.version
  tbName = data.name + "-" + data.version + ".tgz"
  tbURI = data.name + "/-/" + tbName
  data._id = data.name + "@" + data.version
  data.dist = data.dist or {}
  data.dist.shasum = crypto.createHash("sha1").update(tarbuffer).digest("hex")
  data.dist.tarball = url.resolve(registry, tbURI).replace(/^https:\/\//, "http://")
  root._attachments = {}
  root._attachments[tbName] =
    content_type: "application/octet-stream"
    data: tarbuffer.toString("base64")
    length: stat.size

  fixed = url.resolve(registry, escaped(data.name))
  @request "PUT", fixed,
    body: root
  
  # a 409 is typical here.  GET the data and merge in.
  
  # let's see what versions are already published.
  , ((er, parsed, json, res) ->
    r409 = "must supply latest _rev to update existing package"
    r409b = "Document update conflict."
    conflict = res and res.statusCode is 409
    conflict = true  if parsed and (parsed.reason is r409 or parsed.reason is r409b)
    if er and not conflict
      @log.error "publish", "Failed PUT " + (res and res.statusCode)
      return cb(er)
    return cb(er, parsed, json, res)  if not er and not conflict
    @request "GET", fixed + "?write=true", null, ((er, current) ->
      return cb(er)  if er
      putNext.call this, registry, data.version, root, current, cb
      return
    ).bind(this)
    return
  ).bind(this)
  return
putNext = (registry, newVersion, root, current, cb) ->
  
  # already have the tardata on the root object
  # just merge in existing stuff
  curVers = Object.keys(current.versions or {}).map((v) ->
    semver.clean v, true
  ).concat(Object.keys(current.time or {}).map((v) ->
    semver.clean v, true  if semver.valid(v, true)
  ).filter((v) ->
    v
  ))
  return cb(conflictError(root.name, newVersion))  if curVers.indexOf(newVersion) isnt -1
  current.versions[newVersion] = root.versions[newVersion]
  current._attachments = current._attachments or {}
  for i of root
    switch i
      
      # objects that copy over the new stuffs
      when "dist-tags", "versions", "_attachments"
        for j of root[i]
          current[i][j] = root[i][j]
      
      # ignore these
      when "maintainers"
      
      # copy
      else
        current[i] = root[i]
  maint = JSON.parse(JSON.stringify(root.maintainers))
  root.versions[newVersion].maintainers = maint
  uri = url.resolve(registry, escaped(root.name))
  @request "PUT", uri,
    body: current
  , cb
  return
conflictError = (pkgid, version) ->
  e = new Error("cannot modify pre-existing version")
  e.code = "EPUBLISHCONFLICT"
  e.pkgid = pkgid
  e.version = version
  e
module.exports = publish
url = require("url")
semver = require("semver")
crypto = require("crypto")
fs = require("fs")
fixNameField = require("normalize-package-data/lib/fixer.js").fixNameField
