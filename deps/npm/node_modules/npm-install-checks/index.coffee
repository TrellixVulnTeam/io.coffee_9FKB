checkEngine = (target, npmVer, nodeVer, force, strict, cb) ->
  nodev = (if force then null else nodeVer)
  strict = strict or target.engineStrict
  eng = target.engines
  return cb()  unless eng
  if nodev and eng.node and not semver.satisfies(nodev, eng.node) or eng.npm and not semver.satisfies(npmVer, eng.npm)
    if strict
      er = new Error("Unsupported")
      er.code = "ENOTSUP"
      er.required = eng
      er.pkgid = target._id
      return cb(er)
    else
      log.warn "engine", "%s: wanted: %j (current: %j)", target._id, eng,
        node: nodev
        npm: npmVer

  cb()
checkPlatform = (target, force, cb) ->
  platform = process.platform
  arch = process.arch
  osOk = true
  cpuOk = true
  return cb()  if force
  osOk = checkList(platform, target.os)  if target.os
  cpuOk = checkList(arch, target.cpu)  if target.cpu
  if not osOk or not cpuOk
    er = new Error("Unsupported")
    er.code = "EBADPLATFORM"
    er.os = target.os or ["any"]
    er.cpu = target.cpu or ["any"]
    er.pkgid = target._id
    return cb(er)
  cb()
checkList = (value, list) ->
  tmp = undefined
  match = false
  blc = 0
  list = [list]  if typeof list is "string"
  return true  if list.length is 1 and list[0] is "any"
  i = 0

  while i < list.length
    tmp = list[i]
    if tmp[0] is "!"
      tmp = tmp.slice(1)
      return false  if tmp is value
      ++blc
    else
      match = match or tmp is value
    ++i
  match or blc is list.length
checkCycle = (target, ancestors, cb) ->
  
  # there are some very rare and pathological edge-cases where
  # a cycle can cause npm to try to install a never-ending tree
  # of stuff.
  # Simplest:
  #
  # A -> B -> A' -> B' -> A -> B -> A' -> B' -> A -> ...
  #
  # Solution: Simply flat-out refuse to install any name@version
  # that is already in the prototype tree of the ancestors object.
  # A more correct, but more complex, solution would be to symlink
  # the deeper thing into the new location.
  # Will do that if anyone whines about this irl.
  #
  # Note: `npm install foo` inside of the `foo` package will abort
  # earlier if `--force` is not set.  However, if it IS set, then
  # we need to still fail here, but just skip the first level. Of
  # course, it'll still fail eventually if it's a true cycle, and
  # leave things in an undefined state, but that's what is to be
  # expected when `--force` is used.  That is why getPrototypeOf
  # is used *twice* here: to skip the first level of repetition.
  p = Object.getPrototypeOf(Object.getPrototypeOf(ancestors))
  name = target.name
  version = target.version
  p = Object.getPrototypeOf(p)  while p and p isnt Object:: and p[name] isnt version
  return cb()  if p[name] isnt version
  er = new Error("Unresolvable cycle detected")
  tree = [
    target._id
    JSON.parse(JSON.stringify(ancestors))
  ]
  t = Object.getPrototypeOf(ancestors)
  while t and t isnt Object::
    t.THIS_IS_P = true  if t is p
    tree.push JSON.parse(JSON.stringify(t))
    t = Object.getPrototypeOf(t)
  log.verbose "unresolvable dependency tree", tree
  er.pkgid = target._id
  er.code = "ECYCLE"
  cb er
checkGit = (folder, cb) ->
  
  # if it's a git repo then don't touch it!
  fs.lstat folder, (er, s) ->
    if er or not s.isDirectory()
      cb()
    else
      checkGit_ folder, cb
    return

  return
checkGit_ = (folder, cb) ->
  fs.stat path.resolve(folder, ".git"), (er, s) ->
    if not er and s.isDirectory()
      e = new Error("Appears to be a git repo or submodule.")
      e.path = folder
      e.code = "EISGIT"
      return cb(e)
    cb()
    return

  return
fs = require("fs")
path = require("path")
log = require("npmlog")
semver = require("semver")
exports.checkEngine = checkEngine
exports.checkPlatform = checkPlatform
exports.checkCycle = checkCycle
exports.checkGit = checkGit
