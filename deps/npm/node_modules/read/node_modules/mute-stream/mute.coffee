
# var out = new MuteStream(process.stdout)
# argument auto-pipes
MuteStream = (opts) ->
  Stream.apply this
  opts = opts or {}
  @writable = @readable = true
  @muted = false
  @on "pipe", @_onpipe
  @replace = opts.replace
  
  # For readline-type situations
  # This much at the start of a line being redrawn after a ctrl char
  # is seen (such as backspace) won't be redrawn as the replacement
  @_prompt = opts.prompt or null
  @_hadControl = false
  return
onPipe = (src) ->
  @_src = src
  return
getIsTTY = ->
  (if (@_dest) then @_dest.isTTY else (if (@_src) then @_src.isTTY else false))

# basically just get replace the getter/setter with a regular value
setIsTTY = (isTTY) ->
  Object.defineProperty this, "isTTY",
    value: isTTY
    enumerable: true
    writable: true
    configurable: true

  return
proxy = (fn) ->
  ->
    d = @_dest
    s = @_src
    d[fn].apply d, arguments  if d and d[fn]
    s[fn].apply s, arguments  if s and s[fn]
    return
Stream = require("stream")
module.exports = MuteStream
MuteStream:: = Object.create(Stream::)
Object.defineProperty MuteStream::, "constructor",
  value: MuteStream
  enumerable: false

MuteStream::mute = ->
  @muted = true
  return

MuteStream::unmute = ->
  @muted = false
  return

Object.defineProperty MuteStream::, "_onpipe",
  value: onPipe
  enumerable: false
  writable: true
  configurable: true

Object.defineProperty MuteStream::, "isTTY",
  get: getIsTTY
  set: setIsTTY
  enumerable: true
  configurable: true

Object.defineProperty MuteStream::, "rows",
  get: ->
    (if @_dest then @_dest.rows else (if @_src then @_src.rows else `undefined`))

  enumerable: true
  configurable: true

Object.defineProperty MuteStream::, "columns",
  get: ->
    (if @_dest then @_dest.columns else (if @_src then @_src.columns else `undefined`))

  enumerable: true
  configurable: true

MuteStream::pipe = (dest) ->
  @_dest = dest
  Stream::pipe.call this, dest

MuteStream::pause = ->
  @_src.pause()  if @_src

MuteStream::resume = ->
  @_src.resume()  if @_src

MuteStream::write = (c) ->
  if @muted
    return true  unless @replace
    if c.match(/^\u001b/)
      @_hadControl = true
      return @emit("data", c)
    else
      if @_prompt and @_hadControl and c.indexOf(@_prompt) is 0
        @_hadControl = false
        @emit "data", @_prompt
        c = c.substr(@_prompt.length)
      c = c.toString().replace(/./g, @replace)
  @emit "data", c
  return

MuteStream::end = (c) ->
  if @muted
    if c and @replace
      c = c.toString().replace(/./g, @replace)
    else
      c = null
  @emit "data", c  if c
  @emit "end"
  return

MuteStream::destroy = proxy("destroy")
MuteStream::destroySoon = proxy("destroySoon")
MuteStream::close = proxy("close")
