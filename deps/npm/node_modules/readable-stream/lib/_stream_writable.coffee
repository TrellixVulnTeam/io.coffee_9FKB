# Copyright Joyent, Inc. and other Node contributors.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the
# following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
# USE OR OTHER DEALINGS IN THE SOFTWARE.

# A bit simpler than readable streams.
# Implement an async ._write(chunk, cb), and it'll handle all
# the drain event emission and buffering.

#<replacement>

#</replacement>

#<replacement>

#</replacement>
WriteReq = (chunk, encoding, cb) ->
  @chunk = chunk
  @encoding = encoding
  @callback = cb
  return
WritableState = (options, stream) ->
  options = options or {}
  
  # the point at which write() starts returning false
  # Note: 0 is a valid value, means that we always return false if
  # the entire buffer is not flushed immediately on write()
  hwm = options.highWaterMark
  @highWaterMark = (if (hwm or hwm is 0) then hwm else 16 * 1024)
  
  # object stream flag to indicate whether or not this stream
  # contains buffers or objects.
  @objectMode = !!options.objectMode
  
  # cast to ints.
  @highWaterMark = ~~@highWaterMark
  @needDrain = false
  
  # at the start of calling end()
  @ending = false
  
  # when end() has been called, and returned
  @ended = false
  
  # when 'finish' is emitted
  @finished = false
  
  # should we decode strings into buffers before passing to _write?
  # this is here so that some node-core streams can optimize string
  # handling at a lower level.
  noDecode = options.decodeStrings is false
  @decodeStrings = not noDecode
  
  # Crypto is kind of old and crusty.  Historically, its default string
  # encoding is 'binary' so we have to make this configurable.
  # Everything else in the universe uses 'utf8', though.
  @defaultEncoding = options.defaultEncoding or "utf8"
  
  # not an actual buffer we keep track of, but a measurement
  # of how much we're waiting to get pushed to some underlying
  # socket or file.
  @length = 0
  
  # a flag to see when we're in the middle of a write.
  @writing = false
  
  # a flag to be able to tell if the onwrite cb is called immediately,
  # or on a later tick.  We set this to true at first, becuase any
  # actions that shouldn't happen until "later" should generally also
  # not happen before the first write call.
  @sync = true
  
  # a flag to know if we're processing previously buffered items, which
  # may call the _write() callback in the same tick, so that we don't
  # end up in an overlapped onwrite situation.
  @bufferProcessing = false
  
  # the callback that's passed to _write(chunk,cb)
  @onwrite = (er) ->
    onwrite stream, er
    return

  
  # the callback that the user supplies to write(chunk,encoding,cb)
  @writecb = null
  
  # the amount that is being written when _write is called.
  @writelen = 0
  @buffer = []
  
  # True if the error was already emitted and should not be thrown again
  @errorEmitted = false
  return
Writable = (options) ->
  Duplex = require("./_stream_duplex")
  
  # Writable ctor is applied to Duplexes, though they're not
  # instanceof Writable, they're instanceof Readable.
  return new Writable(options)  if (this not instanceof Writable) and (this not instanceof Duplex)
  @_writableState = new WritableState(options, this)
  
  # legacy.
  @writable = true
  Stream.call this
  return

# Otherwise people can pipe Writable streams, which is just wrong.
writeAfterEnd = (stream, state, cb) ->
  er = new Error("write after end")
  
  # TODO: defer error events consistently everywhere, not just the cb
  stream.emit "error", er
  process.nextTick ->
    cb er
    return

  return

# If we get something that is not a buffer, string, null, or undefined,
# and we're not in objectMode, then that's an error.
# Otherwise stream chunks are all considered to be of length=1, and the
# watermarks determine how many objects to keep in the buffer, rather than
# how many bytes or characters.
validChunk = (stream, state, chunk, cb) ->
  valid = true
  if not Buffer.isBuffer(chunk) and "string" isnt typeof chunk and chunk isnt null and chunk isnt `undefined` and not state.objectMode
    er = new TypeError("Invalid non-string/buffer chunk")
    stream.emit "error", er
    process.nextTick ->
      cb er
      return

    valid = false
  valid
decodeChunk = (state, chunk, encoding) ->
  chunk = new Buffer(chunk, encoding)  if not state.objectMode and state.decodeStrings isnt false and typeof chunk is "string"
  chunk

# if we're already writing something, then just put this
# in the queue, and wait our turn.  Otherwise, call _write
# If we return false, then we need a drain event, so set that flag.
writeOrBuffer = (stream, state, chunk, encoding, cb) ->
  chunk = decodeChunk(state, chunk, encoding)
  encoding = "buffer"  if Buffer.isBuffer(chunk)
  len = (if state.objectMode then 1 else chunk.length)
  state.length += len
  ret = state.length < state.highWaterMark
  
  # we must ensure that previous needDrain will not be reset to false.
  state.needDrain = true  unless ret
  if state.writing
    state.buffer.push new WriteReq(chunk, encoding, cb)
  else
    doWrite stream, state, len, chunk, encoding, cb
  ret
doWrite = (stream, state, len, chunk, encoding, cb) ->
  state.writelen = len
  state.writecb = cb
  state.writing = true
  state.sync = true
  stream._write chunk, encoding, state.onwrite
  state.sync = false
  return
onwriteError = (stream, state, sync, er, cb) ->
  if sync
    process.nextTick ->
      cb er
      return

  else
    cb er
  stream._writableState.errorEmitted = true
  stream.emit "error", er
  return
onwriteStateUpdate = (state) ->
  state.writing = false
  state.writecb = null
  state.length -= state.writelen
  state.writelen = 0
  return
onwrite = (stream, er) ->
  state = stream._writableState
  sync = state.sync
  cb = state.writecb
  onwriteStateUpdate state
  if er
    onwriteError stream, state, sync, er, cb
  else
    
    # Check if we're actually ready to finish, but don't emit yet
    finished = needFinish(stream, state)
    clearBuffer stream, state  if not finished and not state.bufferProcessing and state.buffer.length
    if sync
      process.nextTick ->
        afterWrite stream, state, finished, cb
        return

    else
      afterWrite stream, state, finished, cb
  return
afterWrite = (stream, state, finished, cb) ->
  onwriteDrain stream, state  unless finished
  cb()
  finishMaybe stream, state  if finished
  return

# Must force callback to be called on nextTick, so that we don't
# emit 'drain' before the write() consumer gets the 'false' return
# value, and has a chance to attach a 'drain' listener.
onwriteDrain = (stream, state) ->
  if state.length is 0 and state.needDrain
    state.needDrain = false
    stream.emit "drain"
  return

# if there's something in the buffer waiting, then process it
clearBuffer = (stream, state) ->
  state.bufferProcessing = true
  c = 0

  while c < state.buffer.length
    entry = state.buffer[c]
    chunk = entry.chunk
    encoding = entry.encoding
    cb = entry.callback
    len = (if state.objectMode then 1 else chunk.length)
    doWrite stream, state, len, chunk, encoding, cb
    
    # if we didn't call the onwrite immediately, then
    # it means that we need to wait until it does.
    # also, that means that the chunk and cb are currently
    # being processed, so move the buffer counter past them.
    if state.writing
      c++
      break
    c++
  state.bufferProcessing = false
  if c < state.buffer.length
    state.buffer = state.buffer.slice(c)
  else
    state.buffer.length = 0
  return

# ignore unnecessary end() calls.
needFinish = (stream, state) ->
  state.ending and state.length is 0 and not state.finished and not state.writing
finishMaybe = (stream, state) ->
  need = needFinish(stream, state)
  if need
    state.finished = true
    stream.emit "finish"
  need
endWritable = (stream, state, cb) ->
  state.ending = true
  finishMaybe stream, state
  if cb
    if state.finished
      process.nextTick cb
    else
      stream.once "finish", cb
  state.ended = true
  return
module.exports = Writable
Buffer = require("buffer").Buffer
Writable.WritableState = WritableState
util = require("core-util-is")
util.inherits = require("inherits")
Stream = require("stream")
util.inherits Writable, Stream
Writable::pipe = ->
  @emit "error", new Error("Cannot pipe. Not readable.")
  return

Writable::write = (chunk, encoding, cb) ->
  state = @_writableState
  ret = false
  if typeof encoding is "function"
    cb = encoding
    encoding = null
  if Buffer.isBuffer(chunk)
    encoding = "buffer"
  else encoding = state.defaultEncoding  unless encoding
  cb = ->  if typeof cb isnt "function"
  if state.ended
    writeAfterEnd this, state, cb
  else ret = writeOrBuffer(this, state, chunk, encoding, cb)  if validChunk(this, state, chunk, cb)
  ret

Writable::_write = (chunk, encoding, cb) ->
  cb new Error("not implemented")
  return

Writable::end = (chunk, encoding, cb) ->
  state = @_writableState
  if typeof chunk is "function"
    cb = chunk
    chunk = null
    encoding = null
  else if typeof encoding is "function"
    cb = encoding
    encoding = null
  @write chunk, encoding  if typeof chunk isnt "undefined" and chunk isnt null
  endWritable this, state, cb  if not state.ending and not state.finished
  return
