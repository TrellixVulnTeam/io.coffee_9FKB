(-> # closure for web browsers
  
  # just set the global for non-node platforms.
  hOP = (obj, key) ->
    Object::hasOwnProperty.call obj, key
  naiveLength = ->
    1
  LRUCache = (options) ->
    return new LRUCache(options)  unless this instanceof LRUCache
    options = max: options  if typeof options is "number"
    options = {}  unless options
    @_max = options.max
    
    # Kind of weird to have a default max of Infinity, but oh well.
    @_max = Infinity  if not @_max or (typeof @_max isnt "number") or @_max <= 0
    @_lengthCalculator = options.length or naiveLength
    @_lengthCalculator = naiveLength  if typeof @_lengthCalculator isnt "function"
    @_allowStale = options.stale or false
    @_maxAge = options.maxAge or null
    @_dispose = options.dispose
    @reset()
    return
  
  # resize the cache when the max changes.
  
  # resize the cache when the lengthCalculator changes.
  # hash of items by key
  # list of items in order of use recency
  # most recently used
  # least recently used
  # number of items in the list
  
  # Provided for debugging/dev purposes only. No promises whatsoever that
  # this API stays stable.
  
  # dispose of the old one before overwriting
  
  # oversized objects fall out of cache automatically.
  get = (self, key, doUse) ->
    hit = self._cache[key]
    if hit
      if self._maxAge and (Date.now() - hit.now > self._maxAge)
        del self, hit
        hit = `undefined`  unless self._allowStale
      else
        use self, hit  if doUse
      hit = hit.value  if hit
    hit
  use = (self, hit) ->
    shiftLU self, hit
    hit.lu = self._mru++
    self._lruList[hit.lu] = hit
    return
  trim = (self) ->
    del self, self._lruList[self._lru]  while self._lru < self._mru and self._length > self._max
    return
  shiftLU = (self, hit) ->
    delete self._lruList[hit.lu]

    self._lru++  while self._lru < self._mru and not self._lruList[self._lru]
    return
  del = (self, hit) ->
    if hit
      self._dispose hit.key, hit.value  if self._dispose
      self._length -= hit.length
      self._itemCount--
      delete self._cache[hit.key]

      shiftLU self, hit
    return
  
  # classy, since V8 prefers predictable objects.
  Entry = (key, value, lu, length, now) ->
    @key = key
    @value = value
    @lu = lu
    @length = length
    @now = now
    return
  if typeof module is "object" and module.exports
    module.exports = LRUCache
  else
    @LRUCache = LRUCache
  Object.defineProperty LRUCache::, "max",
    set: (mL) ->
      mL = Infinity  if not mL or (typeof mL isnt "number") or mL <= 0
      @_max = mL
      trim this  if @_length > @_max
      return

    get: ->
      @_max

    enumerable: true

  Object.defineProperty LRUCache::, "lengthCalculator",
    set: (lC) ->
      if typeof lC isnt "function"
        @_lengthCalculator = naiveLength
        @_length = @_itemCount
        for key of @_cache
          @_cache[key].length = 1
      else
        @_lengthCalculator = lC
        @_length = 0
        for key of @_cache
          @_cache[key].length = @_lengthCalculator(@_cache[key].value)
          @_length += @_cache[key].length
      trim this  if @_length > @_max
      return

    get: ->
      @_lengthCalculator

    enumerable: true

  Object.defineProperty LRUCache::, "length",
    get: ->
      @_length

    enumerable: true

  Object.defineProperty LRUCache::, "itemCount",
    get: ->
      @_itemCount

    enumerable: true

  LRUCache::forEach = (fn, thisp) ->
    thisp = thisp or this
    i = 0
    k = @_mru - 1

    while k >= 0 and i < @_itemCount
      if @_lruList[k]
        i++
        hit = @_lruList[k]
        if @_maxAge and (Date.now() - hit.now > @_maxAge)
          del this, hit
          hit = `undefined`  unless @_allowStale
        fn.call thisp, hit.value, hit.key, this  if hit
      k--
    return

  LRUCache::keys = ->
    keys = new Array(@_itemCount)
    i = 0
    k = @_mru - 1

    while k >= 0 and i < @_itemCount
      if @_lruList[k]
        hit = @_lruList[k]
        keys[i++] = hit.key
      k--
    keys

  LRUCache::values = ->
    values = new Array(@_itemCount)
    i = 0
    k = @_mru - 1

    while k >= 0 and i < @_itemCount
      if @_lruList[k]
        hit = @_lruList[k]
        values[i++] = hit.value
      k--
    values

  LRUCache::reset = ->
    if @_dispose and @_cache
      for k of @_cache
        @_dispose k, @_cache[k].value
    @_cache = Object.create(null)
    @_lruList = Object.create(null)
    @_mru = 0
    @_lru = 0
    @_length = 0
    @_itemCount = 0
    return

  LRUCache::dump = ->
    @_cache

  LRUCache::dumpLru = ->
    @_lruList

  LRUCache::set = (key, value) ->
    if hOP(@_cache, key)
      @_dispose key, @_cache[key].value  if @_dispose
      @_cache[key].now = Date.now()  if @_maxAge
      @_cache[key].value = value
      @get key
      return true
    len = @_lengthCalculator(value)
    age = (if @_maxAge then Date.now() else 0)
    hit = new Entry(key, value, @_mru++, len, age)
    if hit.length > @_max
      @_dispose key, value  if @_dispose
      return false
    @_length += hit.length
    @_lruList[hit.lu] = @_cache[key] = hit
    @_itemCount++
    trim this  if @_length > @_max
    true

  LRUCache::has = (key) ->
    return false  unless hOP(@_cache, key)
    hit = @_cache[key]
    return false  if @_maxAge and (Date.now() - hit.now > @_maxAge)
    true

  LRUCache::get = (key) ->
    get this, key, true

  LRUCache::peek = (key) ->
    get this, key, false

  LRUCache::pop = ->
    hit = @_lruList[@_lru]
    del this, hit
    hit or null

  LRUCache::del = (key) ->
    del this, @_cache[key]
    return

  return
)()
