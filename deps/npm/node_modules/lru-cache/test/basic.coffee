test = require("tap").test
LRU = require("../")
test "basic", (t) ->
  cache = new LRU(max: 10)
  cache.set "key", "value"
  t.equal cache.get("key"), "value"
  t.equal cache.get("nada"), `undefined`
  t.equal cache.length, 1
  t.equal cache.max, 10
  t.end()
  return

test "least recently set", (t) ->
  cache = new LRU(2)
  cache.set "a", "A"
  cache.set "b", "B"
  cache.set "c", "C"
  t.equal cache.get("c"), "C"
  t.equal cache.get("b"), "B"
  t.equal cache.get("a"), `undefined`
  t.end()
  return

test "lru recently gotten", (t) ->
  cache = new LRU(2)
  cache.set "a", "A"
  cache.set "b", "B"
  cache.get "a"
  cache.set "c", "C"
  t.equal cache.get("c"), "C"
  t.equal cache.get("b"), `undefined`
  t.equal cache.get("a"), "A"
  t.end()
  return

test "del", (t) ->
  cache = new LRU(2)
  cache.set "a", "A"
  cache.del "a"
  t.equal cache.get("a"), `undefined`
  t.end()
  return

test "max", (t) ->
  cache = new LRU(3)
  
  # test changing the max, verify that the LRU items get dropped.
  cache.max = 100
  i = 0

  while i < 100
    cache.set i, i
    i++
  t.equal cache.length, 100
  i = 0

  while i < 100
    t.equal cache.get(i), i
    i++
  cache.max = 3
  t.equal cache.length, 3
  i = 0

  while i < 97
    t.equal cache.get(i), `undefined`
    i++
  i = 98

  while i < 100
    t.equal cache.get(i), i
    i++
  
  # now remove the max restriction, and try again.
  cache.max = "hello"
  i = 0

  while i < 100
    cache.set i, i
    i++
  t.equal cache.length, 100
  i = 0

  while i < 100
    t.equal cache.get(i), i
    i++
  
  # should trigger an immediate resize
  cache.max = 3
  t.equal cache.length, 3
  i = 0

  while i < 97
    t.equal cache.get(i), `undefined`
    i++
  i = 98

  while i < 100
    t.equal cache.get(i), i
    i++
  t.end()
  return

test "reset", (t) ->
  cache = new LRU(10)
  cache.set "a", "A"
  cache.set "b", "B"
  cache.reset()
  t.equal cache.length, 0
  t.equal cache.max, 10
  t.equal cache.get("a"), `undefined`
  t.equal cache.get("b"), `undefined`
  t.end()
  return


# Note: `<cache>.dump()` is a debugging tool only. No guarantees are made
# about the format/layout of the response.
test "dump", (t) ->
  cache = new LRU(10)
  d = cache.dump()
  t.equal Object.keys(d).length, 0, "nothing in dump for empty cache"
  cache.set "a", "A"
  d = cache.dump() # { a: { key: "a", value: "A", lu: 0 } }
  t.ok d.a
  t.equal d.a.key, "a"
  t.equal d.a.value, "A"
  t.equal d.a.lu, 0
  cache.set "b", "B"
  cache.get "b"
  d = cache.dump()
  t.ok d.b
  t.equal d.b.key, "b"
  t.equal d.b.value, "B"
  t.equal d.b.lu, 2
  t.end()
  return

test "basic with weighed length", (t) ->
  cache = new LRU(
    max: 100
    length: (item) ->
      item.size
  )
  cache.set "key",
    val: "value"
    size: 50

  t.equal cache.get("key").val, "value"
  t.equal cache.get("nada"), `undefined`
  t.equal cache.lengthCalculator(cache.get("key")), 50
  t.equal cache.length, 50
  t.equal cache.max, 100
  t.end()
  return

test "weighed length item too large", (t) ->
  cache = new LRU(
    max: 10
    length: (item) ->
      item.size
  )
  t.equal cache.max, 10
  
  # should fall out immediately
  cache.set "key",
    val: "value"
    size: 50

  t.equal cache.length, 0
  t.equal cache.get("key"), `undefined`
  t.end()
  return

test "least recently set with weighed length", (t) ->
  cache = new LRU(
    max: 8
    length: (item) ->
      item.length
  )
  cache.set "a", "A"
  cache.set "b", "BB"
  cache.set "c", "CCC"
  cache.set "d", "DDDD"
  t.equal cache.get("d"), "DDDD"
  t.equal cache.get("c"), "CCC"
  t.equal cache.get("b"), `undefined`
  t.equal cache.get("a"), `undefined`
  t.end()
  return

test "lru recently gotten with weighed length", (t) ->
  cache = new LRU(
    max: 8
    length: (item) ->
      item.length
  )
  cache.set "a", "A"
  cache.set "b", "BB"
  cache.set "c", "CCC"
  cache.get "a"
  cache.get "b"
  cache.set "d", "DDDD"
  t.equal cache.get("c"), `undefined`
  t.equal cache.get("d"), "DDDD"
  t.equal cache.get("b"), "BB"
  t.equal cache.get("a"), "A"
  t.end()
  return

test "set returns proper booleans", (t) ->
  cache = new LRU(
    max: 5
    length: (item) ->
      item.length
  )
  t.equal cache.set("a", "A"), true
  
  # should return false for max exceeded
  t.equal cache.set("b", "donuts"), false
  t.equal cache.set("b", "B"), true
  t.equal cache.set("c", "CCCC"), true
  t.end()
  return

test "drop the old items", (t) ->
  cache = new LRU(
    max: 5
    maxAge: 50
  )
  cache.set "a", "A"
  setTimeout (->
    cache.set "b", "b"
    t.equal cache.get("a"), "A"
    return
  ), 25
  setTimeout (->
    cache.set "c", "C"
    
    # timed out
    t.notOk cache.get("a")
    return
  ), 60
  setTimeout (->
    t.notOk cache.get("b")
    t.equal cache.get("c"), "C"
    return
  ), 90
  setTimeout (->
    t.notOk cache.get("c")
    t.end()
    return
  ), 155
  return

test "disposal function", (t) ->
  disposed = false
  cache = new LRU(
    max: 1
    dispose: (k, n) ->
      disposed = n
      return
  )
  cache.set 1, 1
  cache.set 2, 2
  t.equal disposed, 1
  cache.set 3, 3
  t.equal disposed, 2
  cache.reset()
  t.equal disposed, 3
  t.end()
  return

test "disposal function on too big of item", (t) ->
  disposed = false
  cache = new LRU(
    max: 1
    length: (k) ->
      k.length

    dispose: (k, n) ->
      disposed = n
      return
  )
  obj = [
    1
    2
  ]
  t.equal disposed, false
  cache.set "obj", obj
  t.equal disposed, obj
  t.end()
  return

test "has()", (t) ->
  cache = new LRU(
    max: 1
    maxAge: 10
  )
  cache.set "foo", "bar"
  t.equal cache.has("foo"), true
  cache.set "blu", "baz"
  t.equal cache.has("foo"), false
  t.equal cache.has("blu"), true
  setTimeout (->
    t.equal cache.has("blu"), false
    t.end()
    return
  ), 15
  return

test "stale", (t) ->
  cache = new LRU(
    maxAge: 10
    stale: true
  )
  cache.set "foo", "bar"
  t.equal cache.get("foo"), "bar"
  t.equal cache.has("foo"), true
  setTimeout (->
    t.equal cache.has("foo"), false
    t.equal cache.get("foo"), "bar"
    t.equal cache.get("foo"), `undefined`
    t.end()
    return
  ), 15
  return

test "lru update via set", (t) ->
  cache = LRU(max: 2)
  cache.set "foo", 1
  cache.set "bar", 2
  cache.del "bar"
  cache.set "baz", 3
  cache.set "qux", 4
  t.equal cache.get("foo"), `undefined`
  t.equal cache.get("bar"), `undefined`
  t.equal cache.get("baz"), 3
  t.equal cache.get("qux"), 4
  t.end()
  return

test "least recently set w/ peek", (t) ->
  cache = new LRU(2)
  cache.set "a", "A"
  cache.set "b", "B"
  t.equal cache.peek("a"), "A"
  cache.set "c", "C"
  t.equal cache.get("c"), "C"
  t.equal cache.get("b"), "B"
  t.equal cache.get("a"), `undefined`
  t.end()
  return

test "pop the least used item", (t) ->
  cache = new LRU(3)
  last = undefined
  cache.set "a", "A"
  cache.set "b", "B"
  cache.set "c", "C"
  t.equal cache.length, 3
  t.equal cache.max, 3
  
  # Ensure we pop a, c, b
  cache.get "b", "B"
  last = cache.pop()
  t.equal last.key, "a"
  t.equal last.value, "A"
  t.equal cache.length, 2
  t.equal cache.max, 3
  last = cache.pop()
  t.equal last.key, "c"
  t.equal last.value, "C"
  t.equal cache.length, 1
  t.equal cache.max, 3
  last = cache.pop()
  t.equal last.key, "b"
  t.equal last.value, "B"
  t.equal cache.length, 0
  t.equal cache.max, 3
  last = cache.pop()
  t.equal last, null
  t.equal cache.length, 0
  t.equal cache.max, 3
  t.end()
  return

