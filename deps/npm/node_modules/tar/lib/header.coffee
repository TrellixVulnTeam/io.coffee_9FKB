# parse a 512-byte header block to a data object, or vice-versa
# If the data won't fit nicely in a simple header, then generate
# the appropriate extended header file, and return that.
TarHeader = (block) ->
  return new TarHeader(block)  unless this instanceof TarHeader
  @decode block  if block
  return

# note that this will only do the normal ustar header, not any kind
# of extended posix header file.  If something doesn't fit comfortably,
# then it will set obj.needExtended = true, and set the block to
# the closest approximation.
encode = (obj) ->
  throw new Error("encode must be called on a TarHeader, or supplied an object")  if not obj and (this not instanceof TarHeader)
  obj = obj or this
  block = obj.block = new Buffer(512)
  
  # if the object has a "prefix", then that's actually an extension of
  # the path field.
  if obj.prefix
    
    # console.error("% header encoding, got a prefix", obj.prefix)
    obj.path = obj.prefix + "/" + obj.path
    
    # console.error("% header encoding, prefixed path", obj.path)
    obj.prefix = ""
  obj.needExtended = false
  if obj.mode
    obj.mode = parseInt(obj.mode, 8)  if typeof obj.mode is "string"
    obj.mode = obj.mode & 0777
  f = 0

  while fields[f] isnt null
    field = fields[f]
    off_ = fieldOffs[f]
    end = fieldEnds[f]
    ret = undefined
    switch field
      
      # special, done below, after all the others
      
      # special, this is an extension of the "path" field.
      # console.error("% header encoding, skip prefix later")
      when "cksum", "prefix", "type"
        
        # convert from long name to a single char.
        type = obj.type or "0"
        if type.length > 1
          type = tar.types[obj.type]
          type = "0"  unless type
        writeText block, off_, end, type
      when "path"
        
        # uses the "prefix" field if > 100 bytes, but <= 255
        pathLen = Buffer.byteLength(obj.path)
        pathFSize = fieldSize[fields.path]
        prefFSize = fieldSize[fields.prefix]
        
        # paths between 100 and 255 should use the prefix field.
        # longer than 255
        if pathLen > pathFSize and pathLen <= pathFSize + prefFSize
          
          # need to find a slash somewhere in the middle so that
          # path and prefix both fit in their respective fields
          searchStart = pathLen - 1 - pathFSize
          searchEnd = prefFSize
          found = false
          pathBuf = new Buffer(obj.path)
          s = searchStart

          while (s <= searchEnd)
            if pathBuf[s] is slash or pathBuf[s] is bslash
              found = s
              break
            s++
          if found isnt false
            prefix = pathBuf.slice(0, found).toString("utf8")
            path = pathBuf.slice(found + 1).toString("utf8")
            ret = writeText(block, off_, end, path)
            off_ = fieldOffs[fields.prefix]
            end = fieldEnds[fields.prefix]
            
            # console.error("% header writing prefix", off, end, prefix)
            ret = writeText(block, off_, end, prefix) or ret
            break
        
        # paths less than 100 chars don't need a prefix
        # and paths longer than 255 need an extended header and will fail
        # on old implementations no matter what we do here.
        # Null out the prefix, and fallthrough to default.
        # console.error("% header writing no prefix")
        poff = fieldOffs[fields.prefix]
        pend = fieldEnds[fields.prefix]
        writeText block, poff, pend, ""
      
      # fallthrough
      
      # all other fields are numeric or text
      else
        ret = (if numeric[field] then writeNumeric(block, off_, end, obj[field]) else writeText(block, off_, end, obj[field] or ""))
    obj.needExtended = obj.needExtended or ret
    f++
  off_ = fieldOffs[fields.cksum]
  end = fieldEnds[fields.cksum]
  writeNumeric block, off_, end, calcSum.call(this, block)
  block

# if it's a negative number, or greater than will fit,
# then use write256.
writeNumeric = (block, off_, end, num) ->
  writeLen = end - off_
  maxNum = MAXNUM[writeLen] or 0
  num = num or 0
  
  # console.error("  numeric", num)
  num = num.getTime() / 1000  if num instanceof Date or Object::toString.call(num) is "[object Date]"
  if num > maxNum or num < 0
    write256 block, off_, end, num
    
    # need an extended header if negative or too big.
    return true
  
  # god, tar is so annoying
  # if the string is small enough, you should put a space
  # between the octal string and the \0, but if it doesn't
  # fit, then don't.
  numStr = Math.floor(num).toString(8)
  numStr += " "  if num < MAXNUM[writeLen - 1]
  
  # pad with "0" chars
  numStr = (new Array(writeLen - numStr.length).join("0")) + numStr  if numStr.length < writeLen
  throw new Error("invalid length: " + JSON.stringify(numStr) + "\n" + "expected: " + writeLen)  if numStr.length isnt writeLen - 1
  block.write numStr, off_, writeLen, "utf8"
  block[end - 1] = 0
  return
write256 = (block, off_, end, num) ->
  buf = block.slice(off_, end)
  positive = num >= 0
  buf[0] = (if positive then 0x80 else 0xff)
  
  # get the number as a base-256 tuple
  num *= -1  unless positive
  tuple = []
  loop
    n = num % 256
    tuple.push n
    num = (num - n) / 256
    break unless num
  bytes = tuple.length
  fill = buf.length - bytes
  i = 1

  while i < fill
    buf[i] = (if positive then 0 else 0xff)
    i++
  
  # tuple is a base256 number, with [0] as the *least* significant byte
  # if it's negative, then we need to flip all the bits once we hit the
  # first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-
  # complement is (0xFF - n).
  zero = true
  i = bytes
  while i > 0
    byte = tuple[bytes - i]
    if positive
      buf[fill + i] = byte
    else if zero and byte is 0
      buf[fill + i] = 0
    else if zero
      zero = false
      buf[fill + i] = 0x100 - byte
    else
      buf[fill + i] = 0xff - byte
    i--
  return
writeText = (block, off_, end, str) ->
  
  # strings are written as utf8, then padded with \0
  strLen = Buffer.byteLength(str)
  writeLen = Math.min(strLen, end - off_)
  
  # non-ascii fields need extended headers
  # long fields get truncated
  needExtended = strLen isnt str.length or strLen > writeLen
  
  # write the string, and null-pad
  block.write str, off_, writeLen, "utf8"  if writeLen > 0
  i = off_ + writeLen

  while i < end
    block[i] = 0
    i++
  needExtended
calcSum = (block) ->
  block = block or @block
  assert Buffer.isBuffer(block) and block.length is 512
  throw new Error("Need block to checksum")  unless block
  
  # now figure out what it would be if the cksum was "        "
  sum = 0
  start = fieldOffs[fields.cksum]
  end = fieldEnds[fields.cksum]
  i = 0

  while i < fieldOffs[fields.cksum]
    sum += block[i]
    i++
  i = start

  while i < end
    sum += space
    i++
  i = end

  while i < 512
    sum += block[i]
    i++
  sum
checkSum = (block) ->
  sum = calcSum.call(this, block)
  block = block or @block
  cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum])
  cksum = parseNumeric(cksum)
  cksum is sum
decode = (block) ->
  block = block or @block
  assert Buffer.isBuffer(block) and block.length is 512
  @block = block
  @cksumValid = @checkSum()
  prefix = null
  
  # slice off each field.
  f = 0

  while fields[f] isnt null
    field = fields[f]
    val = block.slice(fieldOffs[f], fieldEnds[f])
    switch field
      when "ustar"
        
        # if not ustar, then everything after that is just padding.
        if val.toString() isnt "ustar\u0000"
          @ustar = false
          return
        else
          
          # console.error("ustar:", val, val.toString())
          @ustar = val.toString()
      
      # prefix is special, since it might signal the xstar header
      when "prefix"
        atime = parseNumeric(val.slice(131, 131 + 12))
        ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12))
        if (val[130] is 0 or val[130] is space) and typeof atime is "number" and typeof ctime is "number" and val[131 + 12] is space and val[131 + 12 + 12] is space
          @atime = atime
          @ctime = ctime
          val = val.slice(0, 130)
        prefix = val.toString("utf8").replace(/\0+$/, "")
      
      # console.error("% header reading prefix", prefix)
      
      # all other fields are null-padding text
      # or a number.
      else
        if numeric[field]
          this[field] = parseNumeric(val)
        else
          this[field] = val.toString("utf8").replace(/\0+$/, "")
    f++
  
  # if we got a prefix, then prepend it to the path.
  @path = prefix + "/" + @path  if prefix
  return

# console.error("% header got a prefix", this.path)
parse256 = (buf) ->
  
  # first byte MUST be either 80 or FF
  # 80 for positive, FF for 2's comp
  positive = undefined
  if buf[0] is 0x80
    positive = true
  else if buf[0] is 0xff
    positive = false
  else
    return null
  
  # build up a base-256 tuple from the least sig to the highest
  zero = false
  tuple = []
  i = buf.length - 1

  while i > 0
    byte = buf[i]
    if positive
      tuple.push byte
    else if zero and byte is 0
      tuple.push 0
    else if zero
      zero = false
      tuple.push 0x100 - byte
    else
      tuple.push 0xff - byte
    i--
  sum = 0
  i = 0
  l = tuple.length

  while i < l
    sum += tuple[i] * Math.pow(256, i)
    i++
  (if positive then sum else -1 * sum)
parseNumeric = (f) ->
  return parse256(f)  if f[0] & 0x80
  str = f.toString("utf8").split("\u0000")[0].trim()
  res = parseInt(str, 8)
  (if isNaN(res) then null else res)
module.exports = TarHeader
tar = require("../tar.js")
fields = tar.fields
fieldOffs = tar.fieldOffs
fieldEnds = tar.fieldEnds
fieldSize = tar.fieldSize
numeric = tar.numeric
assert = require("assert").ok
space = " ".charCodeAt(0)
slash = "/".charCodeAt(0)
bslash = (if process.platform is "win32" then "\\".charCodeAt(0) else null)
TarHeader:: =
  decode: decode
  encode: encode
  calcSum: calcSum
  checkSum: checkSum

TarHeader.parseNumeric = parseNumeric
TarHeader.encode = encode
TarHeader.decode = decode
MAXNUM =
  12: 077777777777
  11: 07777777777
  8: 07777777
  7: 0777777
