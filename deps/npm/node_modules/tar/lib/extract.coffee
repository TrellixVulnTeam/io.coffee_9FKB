# give it a tarball and a path, and it'll dump the contents
Extract = (opts) ->
  return new Extract(opts)  unless this instanceof Extract
  tar.Parse.apply this
  
  # have to dump into a directory
  opts.type = "Directory"
  opts.Directory = true
  opts = path: opts  if typeof opts isnt "object"
  
  # better to drop in cwd? seems more standard.
  opts.path = opts.path or path.resolve("node-tar-extract")
  opts.type = "Directory"
  opts.Directory = true
  
  # similar to --strip or --strip-components
  opts.strip = +opts.strip
  opts.strip = 0  if not opts.strip or opts.strip <= 0
  @_fst = fstream.Writer(opts)
  @pause()
  me = this
  
  # Hardlinks in tarballs are relative to the root
  # of the tarball.  So, they need to be resolved against
  # the target directory in order to be created properly.
  me.on "entry", (entry) ->
    
    # if there's a "strip" argument, then strip off that many
    # path components.
    if opts.strip
      p = entry.path.split("/").slice(opts.strip).join("/")
      entry.path = entry.props.path = p
      if entry.linkpath
        lp = entry.linkpath.split("/").slice(opts.strip).join("/")
        entry.linkpath = entry.props.linkpath = lp
    entry.linkpath = entry.props.linkpath = path.join(opts.path, path.join("/", entry.props.linkpath))  if entry.type isnt "Link"

  @_fst.on "ready", ->
    me.pipe me._fst,
      end: false

    me.resume()
    return

  
  # this._fst.on("end", function () {
  #   console.error("\nEEEE Extract End", me._fst.path)
  # })
  @_fst.on "close", ->
    
    # console.error("\nEEEE Extract End", me._fst.path)
    me.emit "end"
    me.emit "close"
    return

  return
module.exports = Extract
tar = require("../tar.js")
fstream = require("fstream")
inherits = require("inherits")
path = require("path")
inherits Extract, tar.Parse
Extract::_streamEnd = ->
  me = this
  me.error "unexpected eof"  unless me._ended
  me._fst.end()
  return

# my .end() is coming later.
