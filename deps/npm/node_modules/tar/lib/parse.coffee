
# A writable stream.
# It emits "entry" events, which provide a readable stream that has
# header info attached.

# reading a tar is a lot like reading a directory
# However, we're actually not going to run the ctor,
# since it does a stat and various other stuff.
# This inheritance gives us the pause/resume/pipe
# behavior that is desired.
Parse = ->
  me = this
  return new Parse()  unless me instanceof Parse
  
  # doesn't apply fstream.Reader ctor?
  # no, becasue we don't want to stat/etc, we just
  # want to get the entry/add logic from .pipe()
  Stream.apply me
  me.writable = true
  me.readable = true
  me._stream = new BlockStream(512)
  me.position = 0
  me._ended = false
  me._stream.on "error", (e) ->
    me.emit "error", e
    return

  me._stream.on "data", (c) ->
    me._process c
    return

  me._stream.on "end", ->
    me._streamEnd()
    return

  me._stream.on "drain", ->
    me.emit "drain"
    return

  return
module.exports = Parse.create = Parse
stream = require("stream")
Stream = stream.Stream
BlockStream = require("block-stream")
tar = require("../tar.js")
TarHeader = require("./header.js")
Entry = require("./entry.js")
BufferEntry = require("./buffer-entry.js")
ExtendedHeader = require("./extended-header.js")
assert = require("assert").ok
inherits = require("inherits")
fstream = require("fstream")
inherits Parse, fstream.Reader

# overridden in Extract class, since it needs to
# wait for its DirWriter part to finish before
# emitting "end"
Parse::_streamEnd = ->
  me = this
  me.error "unexpected eof"  unless me._ended
  me.emit "end"
  return


# a tar reader is actually a filter, not just a readable stream.
# So, you should pipe a tarball stream into it, and it needs these
# write/end methods to do that.
Parse::write = (c) ->
  if @_ended
    
    # gnutar puts a LOT of nulls at the end.
    # you can keep writing these things forever.
    # Just ignore them.
    i = 0
    l = c.length

    while i > l
      return @error("write() after end()")  if c[i] isnt 0
      i++
    return
  @_stream.write c

Parse::end = (c) ->
  @_ended = true
  @_stream.end c


# don't need to do anything, since we're just
# proxying the data up from the _stream.
# Just need to override the parent's "Not Implemented"
# error-thrower.
Parse::_read = ->

Parse::_process = (c) ->
  assert c and c.length is 512, "block size should be 512"
  
  # one of three cases.
  # 1. A new header
  # 2. A part of a file/extended header
  # 3. One of two or more EOF null blocks
  if @_entry
    entry = @_entry
    entry.write c
    if entry._remaining is 0
      entry.end()
      @_entry = null
  else
    
    # either zeroes or a header
    zero = true
    i = 0

    while i < 512 and zero
      zero = c[i] is 0
      i++
    
    # eof is *at least* 2 blocks of nulls, and then the end of the
    # file.  you can put blocks of nulls between entries anywhere,
    # so appending one tarball to another is technically valid.
    # ending without the eof null blocks is not allowed, however.
    if zero
      @_ended = true  if @_eofStarted
      @_eofStarted = true
    else
      @_eofStarted = false
      @_startEntry c
  @position += 512
  return


# take a header chunk, start the right kind of entry.
Parse::_startEntry = (c) ->
  header = new TarHeader(c)
  self = this
  entry = undefined
  ev = undefined
  EntryType = undefined
  onend = undefined
  meta = false
  if null is header.size or not header.cksumValid
    e = new Error("invalid tar file")
    e.header = header
    e.tar_file_offset = @position
    e.tar_block = @position / 512
    @emit "error", e
  switch tar.types[header.type]
    when "File", "OldFile", "Link", "SymbolicLink", "CharacterDevice", "BlockDevice", "Directory", "FIFO", "ContiguousFile", "GNUDumpDir"
      
      # start a file.
      # pass in any extended headers
      # These ones consumers are typically most interested in.
      EntryType = Entry
      ev = "entry"
    when "GlobalExtendedHeader"
      
      # extended headers that apply to the rest of the tarball
      EntryType = ExtendedHeader
      onend = ->
        self._global = self._global or {}
        Object.keys(entry.fields).forEach (k) ->
          self._global[k] = entry.fields[k]
          return

        return

      ev = "globalExtendedHeader"
      meta = true
    when "ExtendedHeader", "OldExtendedHeader"
      
      # extended headers that apply to the next entry
      EntryType = ExtendedHeader
      onend = ->
        self._extended = entry.fields
        return

      ev = "extendedHeader"
      meta = true
    when "NextFileHasLongLinkpath"
      
      # set linkpath=<contents> in extended header
      EntryType = BufferEntry
      onend = ->
        self._extended = self._extended or {}
        self._extended.linkpath = entry.body
        return

      ev = "longLinkpath"
      meta = true
    when "NextFileHasLongPath", "OldGnuLongPath"
      
      # set path=<contents> in file-extended header
      EntryType = BufferEntry
      onend = ->
        self._extended = self._extended or {}
        self._extended.path = entry.body
        return

      ev = "longPath"
      meta = true
    else
      
      # all the rest we skip, but still set the _entry
      # member, so that we can skip over their data appropriately.
      # emit an event to say that this is an ignored entry type?
      EntryType = Entry
      ev = "ignoredEntry"
  global = undefined
  extended = undefined
  if meta
    global = extended = null
  else
    global = @_global
    extended = @_extended
    
    # extendedHeader only applies to one entry, so once we start
    # an entry, it's over.
    @_extended = null
  entry = new EntryType(header, extended, global)
  entry.meta = meta
  
  # only proxy data events of normal files.
  unless meta
    entry.on "data", (c) ->
      me.emit "data", c
      return

  entry.on "end", onend  if onend
  @_entry = entry
  me = this
  entry.on "pause", ->
    me.pause()
    return

  entry.on "resume", ->
    me.resume()
    return

  @emit "*", ev, entry  if @listeners("*").length
  @emit ev, entry
  
  # Zero-byte entry.  End immediately.
  if entry.props.size is 0
    entry.end()
    @_entry = null
  return
