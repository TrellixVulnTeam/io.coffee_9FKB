
###*
Require the given path.

@param {String} path
@return {Object} exports
@api public
###
require = (path, parent, orig) ->
  resolved = require.resolve(path)
  
  # lookup failed
  if null is resolved
    orig = orig or path
    parent = parent or "root"
    err = new Error("Failed to require \"" + orig + "\" from \"" + parent + "\"")
    err.path = orig
    err.parent = parent
    err.require = true
    throw err
  module = require.modules[resolved]
  
  # perform real require()
  # by invoking the module's
  # registered function
  unless module.exports
    module.exports = {}
    module.client = module.component = true
    module.call this, module.exports, require.relative(resolved), module
  module.exports

###*
Registered modules.
###
require.modules = {}

###*
Registered aliases.
###
require.aliases = {}

###*
Resolve `path`.

Lookup:

- PATH/index.js
- PATH.js
- PATH

@param {String} path
@return {String} path or null
@api private
###
require.resolve = (path) ->
  path = path.slice(1)  if path.charAt(0) is "/"
  index = path + "/index.js"
  paths = [
    path
    path + ".js"
    path + ".json"
    path + "/index.js"
    path + "/index.json"
  ]
  i = 0

  while i < paths.length
    path = paths[i]
    return path  if require.modules.hasOwnProperty(path)
    i++
  require.aliases[index]  if require.aliases.hasOwnProperty(index)


###*
Normalize `path` relative to the current path.

@param {String} curr
@param {String} path
@return {String}
@api private
###
require.normalize = (curr, path) ->
  segs = []
  return path  unless "." is path.charAt(0)
  curr = curr.split("/")
  path = path.split("/")
  i = 0

  while i < path.length
    if ".." is path[i]
      curr.pop()
    else segs.push path[i]  if "." isnt path[i] and "" isnt path[i]
    ++i
  curr.concat(segs).join "/"


###*
Register module at `path` with callback `definition`.

@param {String} path
@param {Function} definition
@api private
###
require.register = (path, definition) ->
  require.modules[path] = definition
  return


###*
Alias a module definition.

@param {String} from
@param {String} to
@api private
###
require.alias = (from, to) ->
  throw new Error("Failed to alias \"" + from + "\", it does not exist")  unless require.modules.hasOwnProperty(from)
  require.aliases[to] = from
  return


###*
Return a require function relative to the `parent` path.

@param {String} parent
@return {Function}
@api private
###
require.relative = (parent) ->
  
  ###*
  lastIndexOf helper.
  ###
  lastIndexOf = (arr, obj) ->
    i = arr.length
    return i  if arr[i] is obj  while i--
    -1
  
  ###*
  The relative require() itself.
  ###
  localRequire = (path) ->
    resolved = localRequire.resolve(path)
    require resolved, parent, path
  p = require.normalize(parent, "..")
  
  ###*
  Resolve relative to the parent.
  ###
  localRequire.resolve = (path) ->
    c = path.charAt(0)
    return path.slice(1)  if "/" is c
    return require.normalize(p, path)  if "." is c
    
    # resolve deps by returning
    # the dep in the nearest "deps"
    # directory
    segs = parent.split("/")
    i = lastIndexOf(segs, "deps") + 1
    i = 0  unless i
    path = segs.slice(0, i + 1).join("/") + "/deps/" + path
    path

  
  ###*
  Check if module is defined at `path`.
  ###
  localRequire.exists = (path) ->
    require.modules.hasOwnProperty localRequire.resolve(path)

  localRequire

require.register "isarray/index.js", (exports, require, module) ->
  module.exports = Array.isArray or (arr) ->
    Object::toString.call(arr) is "[object Array]"

  return

require.alias "isarray/index.js", "isarray/index.js"
