
#
#usage:
#
#// do something to a list of things
#asyncMap(myListOfStuff, function (thing, cb) { doSomething(thing.foo, cb) }, cb)
#// do more than one thing to each item
#asyncMap(list, fooFn, barFn, cb)
#
#
asyncMap = ->
  # 2d array
  cb = (er) ->
    errState = er  if er and not errState
    argLen = arguments.length
    i = 1

    while i < argLen
      data[i - 1] = (data[i - 1] or []).concat(arguments[i])  if arguments[i] isnt `undefined`
      i++
    
    # see if any new things have been added.
    if list.length > l
      newList = list.slice(l)
      a += (list.length - l) * n
      l = list.length
      process.nextTick ->
        newList.forEach (ar) ->
          steps.forEach (fn) ->
            fn ar, cb
            return

          return

        return

    cb_.apply null, [errState].concat(data)  if --a is 0
    return
  steps = Array::slice.call(arguments)
  list = steps.shift() or []
  cb_ = steps.pop()
  throw new Error("No callback provided to asyncMap")  if typeof cb_ isnt "function"
  return cb_(null, [])  unless list
  list = [list]  unless Array.isArray(list)
  n = steps.length
  data = []
  errState = null
  l = list.length
  a = l * n
  return cb_(null, [])  unless a
  
  # expect the supplied cb function to be called
  # "n" times for each thing in the array.
  list.forEach (ar) ->
    steps.forEach (fn) ->
      fn ar, cb
      return

    return

  return
module.exports = asyncMap
