
# node.js

#
# x-platform log/assert shims
#
_log = (msg, type) ->
  type = type or "log"
  document.write "<div class=\"" + type + "\">" + msg.replace(/\n/g, "<br />") + "</div>"  unless typeof (document) is "undefined"
  unless typeof (console) is "undefined"
    color =
      log: "\u001b[39m"
      warn: "\u001b[33m"
      error: "\u001b[31m"

    console[type] color[type] + msg + color.log
  return
log = (msg) ->
  _log msg, "log"
  return
warn = (msg) ->
  _log msg, "warn"
  return
error = (msg) ->
  _log msg, "error"
  return
assert = (res, msg) ->
  unless res
    error "FAIL: " + msg
  else
    log "Pass: " + msg
  return

#
# Unit tests
#

# Verify ordering of v1 ids created with explicit times
# 2011-11-18 11:36:01.388-08:00
compare = (name, ids) ->
  ids = ids.map((id) ->
    id.split("-").reverse().join "-"
  ).sort()
  sorted = ([].concat(ids)).sort()
  assert sorted.toString() is ids.toString(), name + " have expected order"
  return

# Verify ordering of v1 ids created using default behavior

# Verify ordering of v1 ids created with explicit times

# Verify throw if too many ids created

# Verify clock regression bumps clockseq

# Verify clock regression bumps clockseq

# Verify explicit options produce expected id

# Verify adjacent ids across a msec boundary are 1 time unit apart

#
# Test parse/unparse
#

#
# Perf tests
#

# Get %'age an actual value differs from the ideal value
divergence = (actual, ideal) ->
  Math.round(100 * 100 * (actual - ideal) / ideal) / 100
rate = (msg, t) ->
  log msg + ": " + (N / (Date.now() - t) * 1e3 | 0) + " uuids/second"
  return
uuid = require("../uuid")  unless @uuid
TIME = 1321644961388
compare "uuids with current time", [
  uuid.v1()
  uuid.v1()
  uuid.v1()
  uuid.v1()
  uuid.v1()
]
compare "uuids with time option", [
  uuid.v1(msecs: TIME - 10 * 3600 * 1000)
  uuid.v1(msecs: TIME - 1)
  uuid.v1(msecs: TIME)
  uuid.v1(msecs: TIME + 1)
  uuid.v1(msecs: TIME + 28 * 24 * 3600 * 1000)
]
assert uuid.v1(msecs: TIME) isnt uuid.v1(msecs: TIME), "IDs created at same msec are different"
thrown = false
try
  uuid.v1
    msecs: TIME
    nsecs: 10000

catch e
  thrown = true
assert thrown, "Exception thrown when > 10K ids created in 1 ms"
uidt = uuid.v1(msecs: TIME)
uidtb = uuid.v1(msecs: TIME - 1)
assert parseInt(uidtb.split("-")[3], 16) - parseInt(uidt.split("-")[3], 16) is 1, "Clock regression by msec increments the clockseq"
uidtn = uuid.v1(
  msecs: TIME
  nsecs: 10
)
uidtnb = uuid.v1(
  msecs: TIME
  nsecs: 9
)
assert parseInt(uidtnb.split("-")[3], 16) - parseInt(uidtn.split("-")[3], 16) is 1, "Clock regression by nsec increments the clockseq"
id = uuid.v1(
  msecs: 1321651533573
  nsecs: 5432
  clockseq: 0x385c
  node: [
    0x61
    0xcd
    0x3c
    0xbb
    0x32
    0x10
  ]
)
assert id is "d9428888-122b-11e1-b85c-61cd3cbb3210", "Explicit options produce expected id"
u0 = uuid.v1(
  msecs: TIME
  nsecs: 9999
)
u1 = uuid.v1(
  msecs: TIME + 1
  nsecs: 0
)
before = u0.split("-")[0]
after = u1.split("-")[0]
dt = parseInt(after, 16) - parseInt(before, 16)
assert dt is 1, "Ids spanning 1ms boundary are 100ns apart"
id = "00112233445566778899aabbccddeeff"
assert uuid.unparse(uuid.parse(id.substr(0, 10))) is "00112233-4400-0000-0000-000000000000", "Short parse"
assert uuid.unparse(uuid.parse("(this is the uuid -> " + id + id)) is "00112233-4455-6677-8899-aabbccddeeff", "Dirty parse"
generators =
  v1: uuid.v1
  v4: uuid.v4

UUID_FORMAT =
  v1: /[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i
  v4: /[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i

N = 1e4
for version of generators
  counts = {}
  max = 0
  generator = generators[version]
  format = UUID_FORMAT[version]
  log "\nSanity check " + N + " " + version + " uuids"
  i = 0
  ok = 0

  while i < N
    id = generator()
    throw Error(id + " is not a valid UUID string")  unless format.test(id)
    assert fail, id + " is not a valid id"  unless id is uuid.unparse(uuid.parse(id))
    
    # Count digits for our randomness check
    if version is "v4"
      digits = id.replace(/-/g, "").split("")
      j = digits.length - 1

      while j >= 0
        c = digits[j]
        max = Math.max(max, counts[c] = (counts[c] or 0) + 1)
        j--
    i++
  
  # Check randomness for v4 UUIDs
  if version is "v4"
    
    # Limit that we get worried about randomness. (Purely empirical choice, this!)
    limit = 2 * 100 * Math.sqrt(1 / N)
    log "\nChecking v4 randomness.  Distribution of Hex Digits (% deviation from ideal)"
    i = 0

    while i < 16
      c = i.toString(16)
      bar = ""
      n = counts[c]
      p = Math.round(n / max * 100 | 0)
      
      # 1-3,5-8, and D-F: 1:16 odds over 30 digits
      ideal = N * 30 / 16
      if i is 4
        
        # 4: 1:1 odds on 1 digit, plus 1:16 odds on 30 digits
        ideal = N * (1 + 30 / 16)
      else if i >= 8 and i <= 11
        
        # 8-B: 1:4 odds on 1 digit, plus 1:16 odds on 30 digits
        ideal = N * (1 / 4 + 30 / 16)
      else
        
        # Otherwise: 1:16 odds on 30 digits
        ideal = N * 30 / 16
      d = divergence(n, ideal)
      
      # Draw bar using UTF squares (just for grins)
      s = n / max * 50 | 0
      bar += "="  while s--
      assert Math.abs(d) < limit, c + " |" + bar + "| " + counts[c] + " (" + d + "% < " + limit + "%)"
      i++

# Perf tests
for version of generators
  log "\nPerformance testing " + version + " UUIDs"
  generator = generators[version]
  buf = new uuid.BufferClass(16)
  i = 0
  t = Date.now()

  while i < N
    generator()
    i++
  rate "uuid." + version + "()", t
  i = 0
  t = Date.now()

  while i < N
    generator "binary"
    i++
  rate "uuid." + version + "('binary')", t
  i = 0
  t = Date.now()

  while i < N
    generator "binary", buf
    i++
  rate "uuid." + version + "('binary', buffer)", t
