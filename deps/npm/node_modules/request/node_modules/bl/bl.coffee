BufferList = (callback) ->
  return new BufferList(callback)  unless this instanceof BufferList
  @_bufs = []
  @length = 0
  if typeof callback is "function"
    @_callback = callback
    piper = ((err) ->
      if @_callback
        @_callback err
        @_callback = null
      return
    ).bind(this)
    @on "pipe", (src) ->
      src.on "error", piper
      return

    @on "unpipe", (src) ->
      src.removeListener "error", piper
      return

  else if Buffer.isBuffer(callback)
    @append callback
  else if Array.isArray(callback)
    callback.forEach ((b) ->
      Buffer.isBuffer(b) and @append(b)
      return
    ).bind(this)
  DuplexStream.call this
  return
DuplexStream = require("readable-stream").Duplex
util = require("util")
util.inherits BufferList, DuplexStream
BufferList::_offset = (offset) ->
  tot = 0
  i = 0
  _t = undefined
  while i < @_bufs.length
    _t = tot + @_bufs[i].length
    if offset < _t
      return [
        i
        offset - tot
      ]
    tot = _t
    i++
  return

BufferList::append = (buf) ->
  isBuffer = Buffer.isBuffer(buf) or buf instanceof BufferList
  @_bufs.push (if isBuffer then buf else new Buffer(buf))
  @length += buf.length
  this

BufferList::_write = (buf, encoding, callback) ->
  @append buf
  callback()  if callback
  return

BufferList::_read = (size) ->
  return @push(null)  unless @length
  size = Math.min(size, @length)
  @push @slice(0, size)
  @consume size
  return

BufferList::end = (chunk) ->
  DuplexStream::end.call this, chunk
  if @_callback
    @_callback null, @slice()
    @_callback = null
  return

BufferList::get = (index) ->
  @slice(index, index + 1)[0]

BufferList::slice = (start, end) ->
  @copy null, 0, start, end

BufferList::copy = (dst, dstStart, srcStart, srcEnd) ->
  srcStart = 0  if typeof srcStart isnt "number" or srcStart < 0
  srcEnd = @length  if typeof srcEnd isnt "number" or srcEnd > @length
  return dst or new Buffer(0)  if srcStart >= @length
  return dst or new Buffer(0)  if srcEnd <= 0
  copy = !!dst
  off_ = @_offset(srcStart)
  len = srcEnd - srcStart
  bytes = len
  bufoff = (copy and dstStart) or 0
  start = off_[1]
  l = undefined
  i = undefined
  
  # copy/slice everything
  if srcStart is 0 and srcEnd is @length
    # slice, just return a full concat
    return Buffer.concat(@_bufs)  unless copy
    
    # copy, need to copy individual buffers
    i = 0
    while i < @_bufs.length
      @_bufs[i].copy dst, bufoff
      bufoff += @_bufs[i].length
      i++
    return dst
  
  # easy, cheap case where it's a subset of one of the buffers
  return (if copy then @_bufs[off_[0]].copy(dst, dstStart, start, start + bytes) else @_bufs[off_[0]].slice(start, start + bytes))  if bytes <= @_bufs[off_[0]].length - start
  # a slice, we need something to copy in to
  dst = new Buffer(len)  unless copy
  i = off_[0]
  while i < @_bufs.length
    l = @_bufs[i].length - start
    if bytes > l
      @_bufs[i].copy dst, bufoff, start
    else
      @_bufs[i].copy dst, bufoff, start, start + bytes
      break
    bufoff += l
    bytes -= l
    start = 0  if start
    i++
  dst

BufferList::toString = (encoding, start, end) ->
  @slice(start, end).toString encoding

BufferList::consume = (bytes) ->
  while @_bufs.length
    if bytes > @_bufs[0].length
      bytes -= @_bufs[0].length
      @length -= @_bufs[0].length
      @_bufs.shift()
    else
      @_bufs[0] = @_bufs[0].slice(bytes)
      @length -= bytes
      break
  this

BufferList::duplicate = ->
  i = 0
  copy = new BufferList()
  while i < @_bufs.length
    copy.append @_bufs[i]
    i++
  copy

BufferList::destroy = ->
  @_bufs.length = 0
  @length = 0
  @push null
  return

(->
  methods =
    readDoubleBE: 8
    readDoubleLE: 8
    readFloatBE: 4
    readFloatLE: 4
    readInt32BE: 4
    readInt32LE: 4
    readUInt32BE: 4
    readUInt32LE: 4
    readInt16BE: 2
    readInt16LE: 2
    readUInt16BE: 2
    readUInt16LE: 2
    readInt8: 1
    readUInt8: 1

  for m of methods
    ((m) ->
      BufferList::[m] = (offset) ->
        @slice(offset, offset + methods[m])[m] 0

      return
    ) m
  return
)()
module.exports = BufferList
