tape = require("tape")
crypto = require("crypto")
fs = require("fs")
hash = require("hash_file")
BufferList = require("../")
encodings = ("hex utf8 utf-8 ascii binary base64" + ((if process.browser then "" else " ucs2 ucs-2 utf16le utf-16le"))).split(" ")
tape "single bytes from single buffer", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  t.equal bl.length, 4
  t.equal bl.get(0), 97
  t.equal bl.get(1), 98
  t.equal bl.get(2), 99
  t.equal bl.get(3), 100
  t.end()
  return

tape "single bytes from multiple buffers", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  bl.append new Buffer("efg")
  bl.append new Buffer("hi")
  bl.append new Buffer("j")
  t.equal bl.length, 10
  t.equal bl.get(0), 97
  t.equal bl.get(1), 98
  t.equal bl.get(2), 99
  t.equal bl.get(3), 100
  t.equal bl.get(4), 101
  t.equal bl.get(5), 102
  t.equal bl.get(6), 103
  t.equal bl.get(7), 104
  t.equal bl.get(8), 105
  t.equal bl.get(9), 106
  t.end()
  return

tape "multi bytes from single buffer", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  t.equal bl.length, 4
  t.equal bl.slice(0, 4).toString("ascii"), "abcd"
  t.equal bl.slice(0, 3).toString("ascii"), "abc"
  t.equal bl.slice(1, 4).toString("ascii"), "bcd"
  t.end()
  return

tape "multiple bytes from multiple buffers", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  bl.append new Buffer("efg")
  bl.append new Buffer("hi")
  bl.append new Buffer("j")
  t.equal bl.length, 10
  t.equal bl.slice(0, 10).toString("ascii"), "abcdefghij"
  t.equal bl.slice(3, 10).toString("ascii"), "defghij"
  t.equal bl.slice(3, 6).toString("ascii"), "def"
  t.equal bl.slice(3, 8).toString("ascii"), "defgh"
  t.equal bl.slice(5, 10).toString("ascii"), "fghij"
  t.end()
  return

tape "multiple bytes from multiple buffer lists", (t) ->
  bl = new BufferList()
  bl.append new BufferList([
    new Buffer("abcd")
    new Buffer("efg")
  ])
  bl.append new BufferList([
    new Buffer("hi")
    new Buffer("j")
  ])
  t.equal bl.length, 10
  t.equal bl.slice(0, 10).toString("ascii"), "abcdefghij"
  t.equal bl.slice(3, 10).toString("ascii"), "defghij"
  t.equal bl.slice(3, 6).toString("ascii"), "def"
  t.equal bl.slice(3, 8).toString("ascii"), "defgh"
  t.equal bl.slice(5, 10).toString("ascii"), "fghij"
  t.end()
  return

tape "consuming from multiple buffers", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  bl.append new Buffer("efg")
  bl.append new Buffer("hi")
  bl.append new Buffer("j")
  t.equal bl.length, 10
  t.equal bl.slice(0, 10).toString("ascii"), "abcdefghij"
  bl.consume 3
  t.equal bl.length, 7
  t.equal bl.slice(0, 7).toString("ascii"), "defghij"
  bl.consume 2
  t.equal bl.length, 5
  t.equal bl.slice(0, 5).toString("ascii"), "fghij"
  bl.consume 1
  t.equal bl.length, 4
  t.equal bl.slice(0, 4).toString("ascii"), "ghij"
  bl.consume 1
  t.equal bl.length, 3
  t.equal bl.slice(0, 3).toString("ascii"), "hij"
  bl.consume 2
  t.equal bl.length, 1
  t.equal bl.slice(0, 1).toString("ascii"), "j"
  t.end()
  return

tape "test readUInt8 / readInt8", (t) ->
  buf1 = new Buffer(1)
  buf2 = new Buffer(3)
  buf3 = new Buffer(3)
  bl = new BufferList()
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42
  bl.append buf1
  bl.append buf2
  bl.append buf3
  t.equal bl.readUInt8(2), 0x3
  t.equal bl.readInt8(2), 0x3
  t.equal bl.readUInt8(3), 0x4
  t.equal bl.readInt8(3), 0x4
  t.equal bl.readUInt8(4), 0x23
  t.equal bl.readInt8(4), 0x23
  t.equal bl.readUInt8(5), 0x42
  t.equal bl.readInt8(5), 0x42
  t.end()
  return

tape "test readUInt16LE / readUInt16BE / readInt16LE / readInt16BE", (t) ->
  buf1 = new Buffer(1)
  buf2 = new Buffer(3)
  buf3 = new Buffer(3)
  bl = new BufferList()
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42
  bl.append buf1
  bl.append buf2
  bl.append buf3
  t.equal bl.readUInt16BE(2), 0x0304
  t.equal bl.readUInt16LE(2), 0x0403
  t.equal bl.readInt16BE(2), 0x0304
  t.equal bl.readInt16LE(2), 0x0403
  t.equal bl.readUInt16BE(3), 0x0423
  t.equal bl.readUInt16LE(3), 0x2304
  t.equal bl.readInt16BE(3), 0x0423
  t.equal bl.readInt16LE(3), 0x2304
  t.equal bl.readUInt16BE(4), 0x2342
  t.equal bl.readUInt16LE(4), 0x4223
  t.equal bl.readInt16BE(4), 0x2342
  t.equal bl.readInt16LE(4), 0x4223
  t.end()
  return

tape "test readUInt32LE / readUInt32BE / readInt32LE / readInt32BE", (t) ->
  buf1 = new Buffer(1)
  buf2 = new Buffer(3)
  buf3 = new Buffer(3)
  bl = new BufferList()
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42
  bl.append buf1
  bl.append buf2
  bl.append buf3
  t.equal bl.readUInt32BE(2), 0x03042342
  t.equal bl.readUInt32LE(2), 0x42230403
  t.equal bl.readInt32BE(2), 0x03042342
  t.equal bl.readInt32LE(2), 0x42230403
  t.end()
  return

tape "test readFloatLE / readFloatBE", (t) ->
  buf1 = new Buffer(1)
  buf2 = new Buffer(3)
  buf3 = new Buffer(3)
  bl = new BufferList()
  buf2[1] = 0x00
  buf2[2] = 0x00
  buf3[0] = 0x80
  buf3[1] = 0x3f
  bl.append buf1
  bl.append buf2
  bl.append buf3
  t.equal bl.readFloatLE(2), 0x01
  t.end()
  return

tape "test readDoubleLE / readDoubleBE", (t) ->
  buf1 = new Buffer(1)
  buf2 = new Buffer(3)
  buf3 = new Buffer(10)
  bl = new BufferList()
  buf2[1] = 0x55
  buf2[2] = 0x55
  buf3[0] = 0x55
  buf3[1] = 0x55
  buf3[2] = 0x55
  buf3[3] = 0x55
  buf3[4] = 0xd5
  buf3[5] = 0x3f
  bl.append buf1
  bl.append buf2
  bl.append buf3
  t.equal bl.readDoubleLE(2), 0.3333333333333333
  t.end()
  return

tape "test toString", (t) ->
  bl = new BufferList()
  bl.append new Buffer("abcd")
  bl.append new Buffer("efg")
  bl.append new Buffer("hi")
  bl.append new Buffer("j")
  t.equal bl.toString("ascii", 0, 10), "abcdefghij"
  t.equal bl.toString("ascii", 3, 10), "defghij"
  t.equal bl.toString("ascii", 3, 6), "def"
  t.equal bl.toString("ascii", 3, 8), "defgh"
  t.equal bl.toString("ascii", 5, 10), "fghij"
  t.end()
  return

tape "test toString encoding", (t) ->
  bl = new BufferList()
  b = new Buffer("abcdefghijÿ\u0000")
  bl.append new Buffer("abcd")
  bl.append new Buffer("efg")
  bl.append new Buffer("hi")
  bl.append new Buffer("j")
  bl.append new Buffer("ÿ\u0000")
  encodings.forEach (enc) ->
    t.equal bl.toString(enc), b.toString(enc), enc
    return

  t.end()
  return

not process.browser and tape("test stream", (t) ->
  random = crypto.randomBytes(65534)
  rndhash = hash(random, "md5")
  md5sum = crypto.createHash("md5")
  bl = new BufferList((err, buf) ->
    t.ok Buffer.isBuffer(buf)
    t.ok err is null
    t.equal rndhash, hash(bl.slice(), "md5")
    t.equal rndhash, hash(buf, "md5")
    bl.pipe(fs.createWriteStream("/tmp/bl_test_rnd_out.dat")).on "close", ->
      s = fs.createReadStream("/tmp/bl_test_rnd_out.dat")
      s.on "data", md5sum.update.bind(md5sum)
      s.on "end", ->
        t.equal rndhash, md5sum.digest("hex"), "woohoo! correct hash!"
        t.end()
        return

      return

    return
  )
  fs.writeFileSync "/tmp/bl_test_rnd.dat", random
  fs.createReadStream("/tmp/bl_test_rnd.dat").pipe bl
  return
)
tape "instantiation with Buffer", (t) ->
  buf = crypto.randomBytes(1024)
  buf2 = crypto.randomBytes(1024)
  b = BufferList(buf)
  t.equal buf.toString("hex"), b.slice().toString("hex"), "same buffer"
  b = BufferList([
    buf
    buf2
  ])
  t.equal b.slice().toString("hex"), Buffer.concat([
    buf
    buf2
  ]).toString("hex"), "same buffer"
  t.end()
  return

tape "test String appendage", (t) ->
  bl = new BufferList()
  b = new Buffer("abcdefghijÿ\u0000")
  bl.append "abcd"
  bl.append "efg"
  bl.append "hi"
  bl.append "j"
  bl.append "ÿ\u0000"
  encodings.forEach (enc) ->
    t.equal bl.toString(enc), b.toString(enc)
    return

  t.end()
  return

tape "write nothing, should get empty buffer", (t) ->
  t.plan 3
  BufferList((err, data) ->
    t.notOk err, "no error"
    t.ok Buffer.isBuffer(data), "got a buffer"
    t.equal 0, data.length, "got a zero-length buffer"
    t.end()
    return
  ).end()
  return

tape "unicode string", (t) ->
  t.plan 2
  inp1 = "☀"
  inp2 = "☃"
  exp = inp1 + " and " + inp2
  bl = BufferList()
  bl.write inp1
  bl.write " and "
  bl.write inp2
  t.equal exp, bl.toString()
  t.equal new Buffer(exp).toString("hex"), bl.toString("hex")
  return

tape "should emit finish", (t) ->
  source = BufferList()
  dest = BufferList()
  source.write "hello"
  source.pipe dest
  dest.on "finish", ->
    t.equal dest.toString("utf8"), "hello"
    t.end()
    return

  return

tape "basic copy", (t) ->
  buf = crypto.randomBytes(1024)
  buf2 = new Buffer(1024)
  b = BufferList(buf)
  b.copy buf2
  t.equal b.slice().toString("hex"), buf2.toString("hex"), "same buffer"
  t.end()
  return

tape "copy after many appends", (t) ->
  buf = crypto.randomBytes(512)
  buf2 = new Buffer(1024)
  b = BufferList(buf)
  b.append buf
  b.copy buf2
  t.equal b.slice().toString("hex"), buf2.toString("hex"), "same buffer"
  t.end()
  return

tape "copy at a precise position", (t) ->
  buf = crypto.randomBytes(1004)
  buf2 = new Buffer(1024)
  b = BufferList(buf)
  b.copy buf2, 20
  t.equal b.slice().toString("hex"), buf2.slice(20).toString("hex"), "same buffer"
  t.end()
  return

tape "copy starting from a precise location", (t) ->
  buf = crypto.randomBytes(10)
  buf2 = new Buffer(5)
  b = BufferList(buf)
  b.copy buf2, 0, 5
  t.equal b.slice(5).toString("hex"), buf2.toString("hex"), "same buffer"
  t.end()
  return

tape "copy in an interval", (t) ->
  rnd = crypto.randomBytes(10)
  b = BufferList(rnd) # put the random bytes there
  actual = new Buffer(3)
  expected = new Buffer(3)
  rnd.copy expected, 0, 5, 8
  b.copy actual, 0, 5, 8
  t.equal actual.toString("hex"), expected.toString("hex"), "same buffer"
  t.end()
  return

tape "copy an interval between two buffers", (t) ->
  buf = crypto.randomBytes(10)
  buf2 = new Buffer(10)
  b = BufferList(buf)
  b.append buf
  b.copy buf2, 0, 5, 15
  t.equal b.slice(5, 15).toString("hex"), buf2.toString("hex"), "same buffer"
  t.end()
  return

tape "duplicate", (t) ->
  t.plan 2
  bl = new BufferList("abcdefghijÿ\u0000")
  dup = bl.duplicate()
  t.equal bl::, dup::
  t.equal bl.toString("hex"), dup.toString("hex")
  return

tape "destroy no pipe", (t) ->
  t.plan 2
  bl = new BufferList("alsdkfja;lsdkfja;lsdk")
  bl.destroy()
  t.equal bl._bufs.length, 0
  t.equal bl.length, 0
  return

not process.browser and tape("destroy with pipe before read end", (t) ->
  t.plan 2
  bl = new BufferList()
  fs.createReadStream(__dirname + "/sauce.js").pipe bl
  bl.destroy()
  t.equal bl._bufs.length, 0
  t.equal bl.length, 0
  return
)
not process.browser and tape("destroy with pipe before read end with race", (t) ->
  t.plan 2
  bl = new BufferList()
  fs.createReadStream(__dirname + "/sauce.js").pipe bl
  setTimeout (->
    bl.destroy()
    setTimeout (->
      t.equal bl._bufs.length, 0
      t.equal bl.length, 0
      return
    ), 500
    return
  ), 500
  return
)
not process.browser and tape("destroy with pipe after read end", (t) ->
  onEnd = ->
    bl.destroy()
    t.equal bl._bufs.length, 0
    t.equal bl.length, 0
    return
  t.plan 2
  bl = new BufferList()
  fs.createReadStream(__dirname + "/sauce.js").on("end", onEnd).pipe bl
  return
)
not process.browser and tape("destroy with pipe while writing to a destination", (t) ->
  onEnd = ->
    bl.pipe ds
    setTimeout (->
      bl.destroy()
      t.equals bl._bufs.length, 0
      t.equals bl.length, 0
      ds.destroy()
      t.equals bl._bufs.length, 0
      t.equals bl.length, 0
      return
    ), 100
    return
  t.plan 4
  bl = new BufferList()
  ds = new BufferList()
  fs.createReadStream(__dirname + "/sauce.js").on("end", onEnd).pipe bl
  return
)
not process.browser and tape("handle error", (t) ->
  t.plan 2
  fs.createReadStream("/does/not/exist").pipe BufferList((err, data) ->
    t.ok err instanceof Error, "has error"
    t.notOk data, "no data"
    return
  )
  return
)
