# Load modules
Utils = require("./utils")

# Declare internals
internals =
  delimiter: "&"
  depth: 5
  arrayLimit: 20
  parametersLimit: 1000

internals.parseValues = (str, delimiter) ->
  delimiter = (if typeof delimiter is "string" then delimiter else internals.delimiter)
  obj = {}
  parts = str.split(delimiter, internals.parametersLimit)
  i = 0
  il = parts.length

  while i < il
    part = parts[i]
    pos = (if part.indexOf("]=") is -1 then part.indexOf("=") else part.indexOf("]=") + 1)
    if pos is -1
      obj[Utils.decode(part)] = ""
    else
      key = Utils.decode(part.slice(0, pos))
      val = Utils.decode(part.slice(pos + 1))
      unless obj[key]
        obj[key] = val
      else
        obj[key] = [].concat(obj[key]).concat(val)
    ++i
  obj

internals.parseObject = (chain, val) ->
  return val  unless chain.length
  root = chain.shift()
  obj = {}
  if root is "[]"
    obj = []
    obj = obj.concat(internals.parseObject(chain, val))
  else
    cleanRoot = (if root[0] is "[" and root[root.length - 1] is "]" then root.slice(1, root.length - 1) else root)
    index = parseInt(cleanRoot, 10)
    if not isNaN(index) and root isnt cleanRoot and index <= internals.arrayLimit
      obj = []
      obj[index] = internals.parseObject(chain, val)
    else
      obj[cleanRoot] = internals.parseObject(chain, val)
  obj

internals.parseKeys = (key, val, depth) ->
  return  unless key
  
  # The regex chunks
  parent = /^([^\[\]]*)/
  child = /(\[[^\[\]]*\])/g
  
  # Get the parent
  segment = parent.exec(key)
  
  # Don't allow them to overwrite object prototype properties
  return  if Object::hasOwnProperty(segment[1])
  
  # Stash the parent if it exists
  keys = []
  keys.push segment[1]  if segment[1]
  
  # Loop through children appending to the array until we hit depth
  i = 0
  while (segment = child.exec(key)) isnt null and i < depth
    ++i
    keys.push segment[1]  unless Object::hasOwnProperty(segment[1].replace(/\[|\]/g, ""))
  
  # If there's a remainder, just add whatever is left
  keys.push "[" + key.slice(segment.index) + "]"  if segment
  internals.parseObject keys, val

module.exports = (str, depth, delimiter) ->
  return {}  if str is "" or str is null or typeof str is "undefined"
  if typeof depth isnt "number"
    delimiter = depth
    depth = internals.depth
  tempObj = (if typeof str is "string" then internals.parseValues(str, delimiter) else Utils.clone(str))
  obj = {}
  
  # Iterate over the keys and setup the new object
  #
  for key of tempObj
    if tempObj.hasOwnProperty(key)
      newObj = internals.parseKeys(key, tempObj[key], depth)
      obj = Utils.merge(obj, newObj)
  Utils.compact obj
