httpOverHttp = (options) ->
  agent = new TunnelingAgent(options)
  agent.request = http.request
  agent
httpsOverHttp = (options) ->
  agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  agent
httpOverHttps = (options) ->
  agent = new TunnelingAgent(options)
  agent.request = https.request
  agent
httpsOverHttps = (options) ->
  agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  agent
TunnelingAgent = (options) ->
  self = this
  self.options = options or {}
  self.proxyOptions = self.options.proxy or {}
  self.maxSockets = self.options.maxSockets or http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []
  self.on "free", onFree = (socket, host, port) ->
    i = 0
    len = self.requests.length

    while i < len
      pending = self.requests[i]
      if pending.host is host and pending.port is port
        
        # Detect the request to connect same origin server,
        # reuse the connection.
        self.requests.splice i, 1
        pending.request.onSocket socket
        return
      ++i
    socket.destroy()
    self.removeSocket socket
    return

  return

# Legacy API: addRequest(req, host, port, path)

# We are over limit so we'll add it to the queue.

# If we are under maxSockets create a new one.
# for v0.6
# for v0.6
# for v0.6
# for v0.7 or later

# Very hacky. This is necessary to avoid http-parser leaks.

# Hacky.

# If we have pending requests and a socket gets closed a new one
# needs to be created to take over in the pool for the one that closed.
createSecureSocket = (options, cb) ->
  self = this
  TunnelingAgent::createSocket.call self, options, (socket) ->
    
    # 0 is dummy port for v0.6
    secureSocket = tls.connect(0, mergeOptions({}, self.options,
      servername: options.host
      socket: socket
    ))
    cb secureSocket
    return

  return
mergeOptions = (target) ->
  i = 1
  len = arguments.length

  while i < len
    overrides = arguments[i]
    if typeof overrides is "object"
      keys = Object.keys(overrides)
      j = 0
      keyLen = keys.length

      while j < keyLen
        k = keys[j]
        target[k] = overrides[k]  if overrides[k] isnt `undefined`
        ++j
    ++i
  target
"use strict"
net = require("net")
tls = require("tls")
http = require("http")
https = require("https")
events = require("events")
assert = require("assert")
util = require("util")
exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps
util.inherits TunnelingAgent, events.EventEmitter
TunnelingAgent::addRequest = addRequest = (req, options) ->
  self = this
  if typeof options is "string"
    options =
      host: options
      port: arguments[2]
      path: arguments[3]
  if self.sockets.length >= @maxSockets
    self.requests.push
      host: host
      port: port
      request: req

    return
  self.createSocket
    host: options.host
    port: options.port
    request: req
  , (socket) ->
    onFree = ->
      self.emit "free", socket, options.host, options.port
      return
    onCloseOrRemove = (err) ->
      self.removeSocket()
      socket.removeListener "free", onFree
      socket.removeListener "close", onCloseOrRemove
      socket.removeListener "agentRemove", onCloseOrRemove
      return
    socket.on "free", onFree
    socket.on "close", onCloseOrRemove
    socket.on "agentRemove", onCloseOrRemove
    req.onSocket socket
    return

  return

TunnelingAgent::createSocket = createSocket = (options, cb) ->
  onResponse = (res) ->
    res.upgrade = true
    return
  onUpgrade = (res, socket, head) ->
    process.nextTick ->
      onConnect res, socket, head
      return

    return
  onConnect = (res, socket, head) ->
    connectReq.removeAllListeners()
    socket.removeAllListeners()
    if res.statusCode is 200
      assert.equal head.length, 0
      debug "tunneling connection has established"
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb socket
    else
      debug "tunneling socket could not be established, statusCode=%d", res.statusCode
      error = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode)
      error.code = "ECONNRESET"
      options.request.emit "error", error
      self.removeSocket placeholder
    return
  onError = (cause) ->
    connectReq.removeAllListeners()
    debug "tunneling socket could not be established, cause=%s\n", cause.message, cause.stack
    error = new Error("tunneling socket could not be established, " + "cause=" + cause.message)
    error.code = "ECONNRESET"
    options.request.emit "error", error
    self.removeSocket placeholder
    return
  self = this
  placeholder = {}
  self.sockets.push placeholder
  connectOptions = mergeOptions({}, self.proxyOptions,
    method: "CONNECT"
    path: options.host + ":" + options.port
    agent: false
  )
  if connectOptions.proxyAuth
    connectOptions.headers = connectOptions.headers or {}
    connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64")
  debug "making CONNECT request"
  connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false
  connectReq.once "response", onResponse
  connectReq.once "upgrade", onUpgrade
  connectReq.once "connect", onConnect
  connectReq.once "error", onError
  connectReq.end()
  return

TunnelingAgent::removeSocket = removeSocket = (socket) ->
  pos = @sockets.indexOf(socket)
  return @sockets.splice(pos, 1)  if pos is -1
  pending = @requests.shift()
  if pending
    @createSocket pending, (socket) ->
      pending.request.onSocket socket
      return

  return

debug = undefined
if process.env.NODE_DEBUG and /\btunnel\b/.test(process.env.NODE_DEBUG)
  debug = ->
    args = Array::slice.call(arguments)
    if typeof args[0] is "string"
      args[0] = "TUNNEL: " + args[0]
    else
      args.unshift "TUNNEL:"
    console.error.apply console, args
    return
else
  debug = ->
exports.debug = debug # for test
