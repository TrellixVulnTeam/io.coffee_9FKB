FormData = ->
  @_overheadLength = 0
  @_valueLength = 0
  @_lengthRetrievers = []
  CombinedStream.call this
  return

# all that streamy business can't handle numbers

# https://github.com/felixge/node-form-data/issues/38

# Please convert your array into string
# the way web server expects it

# pass along options.knownLength

# used w/ getLengthSync(), when length is known.
# e.g. for streaming directly from a remote server,
# w/ a known file a size, and not wanting to wait for
# incoming file to finish to get its size.

# @check why add CRLF? does this account for custom/multiple CRLFs?

# empty or either doesn't have path or not an http response

# no need to bother with the length

# take read range into a account
# `end` = Infinity â€“> read file till the end
#
# TODO: Looks like there is bug in Node fs.createReadStream
# it doesn't respect `end` options without `start` options
# Fix it when node fixes it.
# https://github.com/joyent/node/issues/7819

# when end specified
# no need to calculate range
# inclusive, starts with 0

# not that fast snoopy

# still need to fetch file size from fs

# update final size based on the range options

# or http response

# or request stream http://github.com/mikeal/request

# wait till response come back

# something else

# custom header specified (as string)?
# it becomes responsible for boundary
# (e.g. to handle extra CRLFs on .NET servers)

# fs- and request- streams have path property
# or use custom filename and/or contentType
# TODO: Use request's response mime-type

# http response has not

# This generates a 50 character boundary similar to those used by Firefox.
# They are optimized for boyer-moore parsing.

# Note: getLengthSync DOESN'T calculate streams length
# As workaround one can calculate file size manually
# and add it as knownLength option

# Don't get confused, there are 3 "internal" streams for each keyval pair
# so it basically checks if there is any value added to the form

# https://github.com/felixge/node-form-data/issues/40

# Some async length retrivers are present
# therefore synchronous length calculation is false.
# Please use getLength(callback) to get proper length

# parse provided url if it's string
# or treat it as options object
# use custom params

# if no port provided use default one

# put that good code in getHeaders to some use

# https if specified, fallback to http in any other case

# get content length and fire away

# TODO: Add chunked encoding when no length (if err)

# add content length

#
# * Santa's little helpers
# 

# populates missing values
populate = (dst, src) ->
  for prop of src
    dst[prop] = src[prop]  unless dst[prop]
  dst
CombinedStream = require("combined-stream")
util = require("util")
path = require("path")
http = require("http")
https = require("https")
parseUrl = require("url").parse
fs = require("fs")
mime = require("mime")
async = require("async")
module.exports = FormData
util.inherits FormData, CombinedStream
FormData.LINE_BREAK = "\r\n"
FormData::append = (field, value, options) ->
  options = options or {}
  append = CombinedStream::append.bind(this)
  value = "" + value  if typeof value is "number"
  if util.isArray(value)
    @_error new Error("Arrays are not supported.")
    return
  header = @_multiPartHeader(field, value, options)
  footer = @_multiPartFooter(field, value, options)
  append header
  append value
  append footer
  @_trackLength header, value, options
  return

FormData::_trackLength = (header, value, options) ->
  valueLength = 0
  if options.knownLength?
    valueLength += +options.knownLength
  else if Buffer.isBuffer(value)
    valueLength = value.length
  else valueLength = Buffer.byteLength(value)  if typeof value is "string"
  @_valueLength += valueLength
  @_overheadLength += Buffer.byteLength(header) + +FormData.LINE_BREAK.length
  return  if not value or (not value.path and not (value.readable and value.hasOwnProperty("httpVersion")))
  unless options.knownLength
    @_lengthRetrievers.push (next) ->
      if value.hasOwnProperty("fd")
        if value.end? and value.end isnt Infinity and value.start?
          next null, value.end + 1 - ((if value.start then value.start else 0))
        else
          fs.stat value.path, (err, stat) ->
            fileSize = undefined
            if err
              next err
              return
            fileSize = stat.size - ((if value.start then value.start else 0))
            next null, fileSize
            return

      else if value.hasOwnProperty("httpVersion")
        next null, +value.headers["content-length"]
      else if value.hasOwnProperty("httpModule")
        value.on "response", (response) ->
          value.pause()
          next null, +response.headers["content-length"]
          return

        value.resume()
      else
        next "Unknown stream"
      return

  return

FormData::_multiPartHeader = (field, value, options) ->
  boundary = @getBoundary()
  header = ""
  if options.header?
    header = options.header
  else
    header += "--" + boundary + FormData.LINE_BREAK + "Content-Disposition: form-data; name=\"" + field + "\""
    if options.filename or value.path
      header += "; filename=\"" + path.basename(options.filename or value.path) + "\"" + FormData.LINE_BREAK + "Content-Type: " + (options.contentType or mime.lookup(options.filename or value.path))
    else header += "; filename=\"" + path.basename(value.client._httpMessage.path) + "\"" + FormData.LINE_BREAK + "Content-Type: " + value.headers["content-type"]  if value.readable and value.hasOwnProperty("httpVersion")
    header += FormData.LINE_BREAK + FormData.LINE_BREAK
  header

FormData::_multiPartFooter = (field, value, options) ->
  ((next) ->
    footer = FormData.LINE_BREAK
    lastPart = (@_streams.length is 0)
    footer += @_lastBoundary()  if lastPart
    next footer
    return
  ).bind this

FormData::_lastBoundary = ->
  "--" + @getBoundary() + "--"

FormData::getHeaders = (userHeaders) ->
  formHeaders = "content-type": "multipart/form-data; boundary=" + @getBoundary()
  for header of userHeaders
    formHeaders[header.toLowerCase()] = userHeaders[header]
  formHeaders

FormData::getCustomHeaders = (contentType) ->
  contentType = (if contentType then contentType else "multipart/form-data")
  formHeaders =
    "content-type": contentType + "; boundary=" + @getBoundary()
    "content-length": @getLengthSync()

  formHeaders

FormData::getBoundary = ->
  @_generateBoundary()  unless @_boundary
  @_boundary

FormData::_generateBoundary = ->
  boundary = "--------------------------"
  i = 0

  while i < 24
    boundary += Math.floor(Math.random() * 10).toString(16)
    i++
  @_boundary = boundary
  return

FormData::getLengthSync = (debug) ->
  knownLength = @_overheadLength + @_valueLength
  knownLength += @_lastBoundary().length  if @_streams.length
  @_error new Error("Cannot calculate proper length in synchronous way.")  if @_lengthRetrievers.length
  knownLength

FormData::getLength = (cb) ->
  knownLength = @_overheadLength + @_valueLength
  knownLength += @_lastBoundary().length  if @_streams.length
  unless @_lengthRetrievers.length
    process.nextTick cb.bind(this, null, knownLength)
    return
  async.parallel @_lengthRetrievers, (err, values) ->
    if err
      cb err
      return
    values.forEach (length) ->
      knownLength += length
      return

    cb null, knownLength
    return

  return

FormData::submit = (params, cb) ->
  request = undefined
  options = undefined
  defaults = method: "post"
  if typeof params is "string"
    params = parseUrl(params)
    options = populate(
      port: params.port
      path: params.pathname
      host: params.hostname
    , defaults)
  else
    options = populate(params, defaults)
    options.port = (if options.protocol is "https:" then 443 else 80)  unless options.port
  options.headers = @getHeaders(params.headers)
  if params.protocol is "https:"
    request = https.request(options)
  else
    request = http.request(options)
  @getLength ((err, length) ->
    request.setHeader "Content-Length", length
    @pipe request
    if cb
      request.on "error", cb
      request.on "response", cb.bind(this, null)
    return
  ).bind(this)
  request

FormData::_error = (err) ->
  return  if @error
  @error = err
  @pause()
  @emit "error", err
  return
