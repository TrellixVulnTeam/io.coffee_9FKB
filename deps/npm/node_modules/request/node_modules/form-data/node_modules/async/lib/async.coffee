#!
# * async
# * https://github.com/caolan/async
# *
# * Copyright 2010-2014 Caolan McMahon
# * Released under the MIT license
# 

#jshint onevar: false, indent:4 

#global setImmediate: false, setTimeout: false, console: false 
(->
  
  # global on the server, window in the browser
  only_once = (fn) ->
    called = false
    ->
      throw new Error("Callback was already called.")  if called
      called = true
      fn.apply root, arguments
      return
  async = {}
  root = undefined
  previous_async = undefined
  root = this
  previous_async = root.async  if root?
  async.noConflict = ->
    root.async = previous_async
    async

  
  #// cross-browser compatiblity functions ////
  _toString = Object::toString
  _isArray = Array.isArray or (obj) ->
    _toString.call(obj) is "[object Array]"

  _each = (arr, iterator) ->
    return arr.forEach(iterator)  if arr.forEach
    i = 0

    while i < arr.length
      iterator arr[i], i, arr
      i += 1
    return

  _map = (arr, iterator) ->
    return arr.map(iterator)  if arr.map
    results = []
    _each arr, (x, i, a) ->
      results.push iterator(x, i, a)
      return

    results

  _reduce = (arr, iterator, memo) ->
    return arr.reduce(iterator, memo)  if arr.reduce
    _each arr, (x, i, a) ->
      memo = iterator(memo, x, i, a)
      return

    memo

  _keys = (obj) ->
    return Object.keys(obj)  if Object.keys
    keys = []
    for k of obj
      keys.push k  if obj.hasOwnProperty(k)
    keys

  
  #// exported async module functions ////
  
  #// nextTick implementation with browser-compatible fallback ////
  if typeof process is "undefined" or not (process.nextTick)
    if typeof setImmediate is "function"
      async.nextTick = (fn) ->
        
        # not a direct alias for IE10 compatibility
        setImmediate fn
        return

      async.setImmediate = async.nextTick
    else
      async.nextTick = (fn) ->
        setTimeout fn, 0
        return

      async.setImmediate = async.nextTick
  else
    async.nextTick = process.nextTick
    if typeof setImmediate isnt "undefined"
      async.setImmediate = (fn) ->
        
        # not a direct alias for IE10 compatibility
        setImmediate fn
        return
    else
      async.setImmediate = async.nextTick
  async.each = (arr, iterator, callback) ->
    done = (err) ->
      if err
        callback err
        callback = ->
      else
        completed += 1
        callback()  if completed >= arr.length
      return
    callback = callback or ->

    return callback()  unless arr.length
    completed = 0
    _each arr, (x) ->
      iterator x, only_once(done)
      return

    return

  async.forEach = async.each
  async.eachSeries = (arr, iterator, callback) ->
    callback = callback or ->

    return callback()  unless arr.length
    completed = 0
    iterate = ->
      iterator arr[completed], (err) ->
        if err
          callback err
          callback = ->
        else
          completed += 1
          if completed >= arr.length
            callback()
          else
            iterate()
        return

      return

    iterate()
    return

  async.forEachSeries = async.eachSeries
  async.eachLimit = (arr, limit, iterator, callback) ->
    fn = _eachLimit(limit)
    fn.apply null, [
      arr
      iterator
      callback
    ]
    return

  async.forEachLimit = async.eachLimit
  _eachLimit = (limit) ->
    (arr, iterator, callback) ->
      callback = callback or ->

      return callback()  if not arr.length or limit <= 0
      completed = 0
      started = 0
      running = 0
      (replenish = ->
        return callback()  if completed >= arr.length
        while running < limit and started < arr.length
          started += 1
          running += 1
          iterator arr[started - 1], (err) ->
            if err
              callback err
              callback = ->
            else
              completed += 1
              running -= 1
              if completed >= arr.length
                callback()
              else
                replenish()
            return

        return
      )()
      return

  doParallel = (fn) ->
    ->
      args = Array::slice.call(arguments)
      fn.apply null, [async.each].concat(args)

  doParallelLimit = (limit, fn) ->
    ->
      args = Array::slice.call(arguments)
      fn.apply null, [_eachLimit(limit)].concat(args)

  doSeries = (fn) ->
    ->
      args = Array::slice.call(arguments)
      fn.apply null, [async.eachSeries].concat(args)

  _asyncMap = (eachfn, arr, iterator, callback) ->
    arr = _map(arr, (x, i) ->
      index: i
      value: x
    )
    unless callback
      eachfn arr, (x, callback) ->
        iterator x.value, (err) ->
          callback err
          return

        return

    else
      results = []
      eachfn arr, ((x, callback) ->
        iterator x.value, (err, v) ->
          results[x.index] = v
          callback err
          return

        return
      ), (err) ->
        callback err, results
        return

    return

  async.map = doParallel(_asyncMap)
  async.mapSeries = doSeries(_asyncMap)
  async.mapLimit = (arr, limit, iterator, callback) ->
    _mapLimit(limit) arr, iterator, callback

  _mapLimit = (limit) ->
    doParallelLimit limit, _asyncMap

  
  # reduce only has a series version, as doing reduce in parallel won't
  # work in many situations.
  async.reduce = (arr, memo, iterator, callback) ->
    async.eachSeries arr, ((x, callback) ->
      iterator memo, x, (err, v) ->
        memo = v
        callback err
        return

      return
    ), (err) ->
      callback err, memo
      return

    return

  
  # inject alias
  async.inject = async.reduce
  
  # foldl alias
  async.foldl = async.reduce
  async.reduceRight = (arr, memo, iterator, callback) ->
    reversed = _map(arr, (x) ->
      x
    ).reverse()
    async.reduce reversed, memo, iterator, callback
    return

  
  # foldr alias
  async.foldr = async.reduceRight
  _filter = (eachfn, arr, iterator, callback) ->
    results = []
    arr = _map(arr, (x, i) ->
      index: i
      value: x
    )
    eachfn arr, ((x, callback) ->
      iterator x.value, (v) ->
        results.push x  if v
        callback()
        return

      return
    ), (err) ->
      callback _map(results.sort((a, b) ->
        a.index - b.index
      ), (x) ->
        x.value
      )
      return

    return

  async.filter = doParallel(_filter)
  async.filterSeries = doSeries(_filter)
  
  # select alias
  async.select = async.filter
  async.selectSeries = async.filterSeries
  _reject = (eachfn, arr, iterator, callback) ->
    results = []
    arr = _map(arr, (x, i) ->
      index: i
      value: x
    )
    eachfn arr, ((x, callback) ->
      iterator x.value, (v) ->
        results.push x  unless v
        callback()
        return

      return
    ), (err) ->
      callback _map(results.sort((a, b) ->
        a.index - b.index
      ), (x) ->
        x.value
      )
      return

    return

  async.reject = doParallel(_reject)
  async.rejectSeries = doSeries(_reject)
  _detect = (eachfn, arr, iterator, main_callback) ->
    eachfn arr, ((x, callback) ->
      iterator x, (result) ->
        if result
          main_callback x
          main_callback = ->
        else
          callback()
        return

      return
    ), (err) ->
      main_callback()
      return

    return

  async.detect = doParallel(_detect)
  async.detectSeries = doSeries(_detect)
  async.some = (arr, iterator, main_callback) ->
    async.each arr, ((x, callback) ->
      iterator x, (v) ->
        if v
          main_callback true
          main_callback = ->
        callback()
        return

      return
    ), (err) ->
      main_callback false
      return

    return

  
  # any alias
  async.any = async.some
  async.every = (arr, iterator, main_callback) ->
    async.each arr, ((x, callback) ->
      iterator x, (v) ->
        unless v
          main_callback false
          main_callback = ->
        callback()
        return

      return
    ), (err) ->
      main_callback true
      return

    return

  
  # all alias
  async.all = async.every
  async.sortBy = (arr, iterator, callback) ->
    async.map arr, ((x, callback) ->
      iterator x, (err, criteria) ->
        if err
          callback err
        else
          callback null,
            value: x
            criteria: criteria

        return

      return
    ), (err, results) ->
      if err
        callback err
      else
        fn = (left, right) ->
          a = left.criteria
          b = right.criteria
          (if a < b then -1 else (if a > b then 1 else 0))

        callback null, _map(results.sort(fn), (x) ->
          x.value
        )
      return

    return

  async.auto = (tasks, callback) ->
    callback = callback or ->

    keys = _keys(tasks)
    remainingTasks = keys.length
    return callback()  unless remainingTasks
    results = {}
    listeners = []
    addListener = (fn) ->
      listeners.unshift fn
      return

    removeListener = (fn) ->
      i = 0

      while i < listeners.length
        if listeners[i] is fn
          listeners.splice i, 1
          return
        i += 1
      return

    taskComplete = ->
      remainingTasks--
      _each listeners.slice(0), (fn) ->
        fn()
        return

      return

    addListener ->
      unless remainingTasks
        theCallback = callback
        
        # prevent final callback from calling itself if it errors
        callback = ->

        theCallback null, results
      return

    _each keys, (k) ->
      task = (if _isArray(tasks[k]) then tasks[k] else [tasks[k]])
      taskCallback = (err) ->
        args = Array::slice.call(arguments, 1)
        args = args[0]  if args.length <= 1
        if err
          safeResults = {}
          _each _keys(results), (rkey) ->
            safeResults[rkey] = results[rkey]
            return

          safeResults[k] = args
          callback err, safeResults
          
          # stop subsequent errors hitting callback multiple times
          callback = ->
        else
          results[k] = args
          async.setImmediate taskComplete
        return

      requires = task.slice(0, Math.abs(task.length - 1)) or []
      ready = ->
        _reduce(requires, (a, x) ->
          a and results.hasOwnProperty(x)
        , true) and not results.hasOwnProperty(k)

      if ready()
        task[task.length - 1] taskCallback, results
      else
        listener = ->
          if ready()
            removeListener listener
            task[task.length - 1] taskCallback, results
          return

        addListener listener
      return

    return

  async.retry = (times, task, callback) ->
    DEFAULT_TIMES = 5
    attempts = []
    
    # Use defaults if times not passed
    if typeof times is "function"
      callback = task
      task = times
      times = DEFAULT_TIMES
    
    # Make sure times is a number
    times = parseInt(times, 10) or DEFAULT_TIMES
    wrappedTask = (wrappedCallback, wrappedResults) ->
      retryAttempt = (task, finalAttempt) ->
        (seriesCallback) ->
          task ((err, result) ->
            seriesCallback not err or finalAttempt,
              err: err
              result: result

            return
          ), wrappedResults
          return

      attempts.push retryAttempt(task, not (times -= 1))  while times
      async.series attempts, (done, data) ->
        data = data[data.length - 1]
        (wrappedCallback or callback) data.err, data.result
        return

      return

    
    # If a callback is passed, run this as a controll flow
    (if callback then wrappedTask() else wrappedTask)

  async.waterfall = (tasks, callback) ->
    callback = callback or ->

    unless _isArray(tasks)
      err = new Error("First argument to waterfall must be an array of functions")
      return callback(err)
    return callback()  unless tasks.length
    wrapIterator = (iterator) ->
      (err) ->
        if err
          callback.apply null, arguments
          callback = ->
        else
          args = Array::slice.call(arguments, 1)
          next = iterator.next()
          if next
            args.push wrapIterator(next)
          else
            args.push callback
          async.setImmediate ->
            iterator.apply null, args
            return

        return

    wrapIterator(async.iterator(tasks))()
    return

  _parallel = (eachfn, tasks, callback) ->
    callback = callback or ->

    if _isArray(tasks)
      eachfn.map tasks, ((fn, callback) ->
        if fn
          fn (err) ->
            args = Array::slice.call(arguments, 1)
            args = args[0]  if args.length <= 1
            callback.call null, err, args
            return

        return
      ), callback
    else
      results = {}
      eachfn.each _keys(tasks), ((k, callback) ->
        tasks[k] (err) ->
          args = Array::slice.call(arguments, 1)
          args = args[0]  if args.length <= 1
          results[k] = args
          callback err
          return

        return
      ), (err) ->
        callback err, results
        return

    return

  async.parallel = (tasks, callback) ->
    _parallel
      map: async.map
      each: async.each
    , tasks, callback
    return

  async.parallelLimit = (tasks, limit, callback) ->
    _parallel
      map: _mapLimit(limit)
      each: _eachLimit(limit)
    , tasks, callback
    return

  async.series = (tasks, callback) ->
    callback = callback or ->

    if _isArray(tasks)
      async.mapSeries tasks, ((fn, callback) ->
        if fn
          fn (err) ->
            args = Array::slice.call(arguments, 1)
            args = args[0]  if args.length <= 1
            callback.call null, err, args
            return

        return
      ), callback
    else
      results = {}
      async.eachSeries _keys(tasks), ((k, callback) ->
        tasks[k] (err) ->
          args = Array::slice.call(arguments, 1)
          args = args[0]  if args.length <= 1
          results[k] = args
          callback err
          return

        return
      ), (err) ->
        callback err, results
        return

    return

  async.iterator = (tasks) ->
    makeCallback = (index) ->
      fn = ->
        tasks[index].apply null, arguments  if tasks.length
        fn.next()

      fn.next = ->
        (if (index < tasks.length - 1) then makeCallback(index + 1) else null)

      fn

    makeCallback 0

  async.apply = (fn) ->
    args = Array::slice.call(arguments, 1)
    ->
      fn.apply null, args.concat(Array::slice.call(arguments))

  _concat = (eachfn, arr, fn, callback) ->
    r = []
    eachfn arr, ((x, cb) ->
      fn x, (err, y) ->
        r = r.concat(y or [])
        cb err
        return

      return
    ), (err) ->
      callback err, r
      return

    return

  async.concat = doParallel(_concat)
  async.concatSeries = doSeries(_concat)
  async.whilst = (test, iterator, callback) ->
    if test()
      iterator (err) ->
        return callback(err)  if err
        async.whilst test, iterator, callback
        return

    else
      callback()
    return

  async.doWhilst = (iterator, test, callback) ->
    iterator (err) ->
      return callback(err)  if err
      args = Array::slice.call(arguments, 1)
      if test.apply(null, args)
        async.doWhilst iterator, test, callback
      else
        callback()
      return

    return

  async.until = (test, iterator, callback) ->
    unless test()
      iterator (err) ->
        return callback(err)  if err
        async.until test, iterator, callback
        return

    else
      callback()
    return

  async.doUntil = (iterator, test, callback) ->
    iterator (err) ->
      return callback(err)  if err
      args = Array::slice.call(arguments, 1)
      unless test.apply(null, args)
        async.doUntil iterator, test, callback
      else
        callback()
      return

    return

  async.queue = (worker, concurrency) ->
    _insert = (q, data, pos, callback) ->
      q.started = true  unless q.started
      data = [data]  unless _isArray(data)
      if data.length is 0
        
        # call drain immediately if there are no tasks
        return async.setImmediate(->
          q.drain()  if q.drain
          return
        )
      _each data, (task) ->
        item =
          data: task
          callback: (if typeof callback is "function" then callback else null)

        if pos
          q.tasks.unshift item
        else
          q.tasks.push item
        q.saturated()  if q.saturated and q.tasks.length is q.concurrency
        async.setImmediate q.process
        return

      return
    concurrency = 1  if concurrency is `undefined`
    workers = 0
    q =
      tasks: []
      concurrency: concurrency
      saturated: null
      empty: null
      drain: null
      started: false
      paused: false
      push: (data, callback) ->
        _insert q, data, false, callback
        return

      kill: ->
        q.drain = null
        q.tasks = []
        return

      unshift: (data, callback) ->
        _insert q, data, true, callback
        return

      process: ->
        if not q.paused and workers < q.concurrency and q.tasks.length
          task = q.tasks.shift()
          q.empty()  if q.empty and q.tasks.length is 0
          workers += 1
          next = ->
            workers -= 1
            task.callback.apply task, arguments  if task.callback
            q.drain()  if q.drain and q.tasks.length + workers is 0
            q.process()
            return

          cb = only_once(next)
          worker task.data, cb
        return

      length: ->
        q.tasks.length

      running: ->
        workers

      idle: ->
        q.tasks.length + workers is 0

      pause: ->
        return  if q.paused is true
        q.paused = true
        q.process()
        return

      resume: ->
        return  if q.paused is false
        q.paused = false
        q.process()
        return

    q

  async.priorityQueue = (worker, concurrency) ->
    _compareTasks = (a, b) ->
      a.priority - b.priority
    _binarySearch = (sequence, item, compare) ->
      beg = -1
      end = sequence.length - 1
      while beg < end
        mid = beg + ((end - beg + 1) >>> 1)
        if compare(item, sequence[mid]) >= 0
          beg = mid
        else
          end = mid - 1
      beg
    _insert = (q, data, priority, callback) ->
      q.started = true  unless q.started
      data = [data]  unless _isArray(data)
      if data.length is 0
        
        # call drain immediately if there are no tasks
        return async.setImmediate(->
          q.drain()  if q.drain
          return
        )
      _each data, (task) ->
        item =
          data: task
          priority: priority
          callback: (if typeof callback is "function" then callback else null)

        q.tasks.splice _binarySearch(q.tasks, item, _compareTasks) + 1, 0, item
        q.saturated()  if q.saturated and q.tasks.length is q.concurrency
        async.setImmediate q.process
        return

      return
    
    # Start with a normal queue
    q = async.queue(worker, concurrency)
    
    # Override push to accept second parameter representing priority
    q.push = (data, priority, callback) ->
      _insert q, data, priority, callback
      return

    
    # Remove unshift function
    delete q.unshift

    q

  async.cargo = (worker, payload) ->
    working = false
    tasks = []
    cargo =
      tasks: tasks
      payload: payload
      saturated: null
      empty: null
      drain: null
      drained: true
      push: (data, callback) ->
        data = [data]  unless _isArray(data)
        _each data, (task) ->
          tasks.push
            data: task
            callback: (if typeof callback is "function" then callback else null)

          cargo.drained = false
          cargo.saturated()  if cargo.saturated and tasks.length is payload
          return

        async.setImmediate cargo.process
        return

      process: process = ->
        return  if working
        if tasks.length is 0
          cargo.drain()  if cargo.drain and not cargo.drained
          cargo.drained = true
          return
        ts = (if typeof payload is "number" then tasks.splice(0, payload) else tasks.splice(0, tasks.length))
        ds = _map(ts, (task) ->
          task.data
        )
        cargo.empty()  if cargo.empty
        working = true
        worker ds, ->
          working = false
          args = arguments
          _each ts, (data) ->
            data.callback.apply null, args  if data.callback
            return

          process()
          return

        return

      length: ->
        tasks.length

      running: ->
        working

    cargo

  _console_fn = (name) ->
    (fn) ->
      args = Array::slice.call(arguments, 1)
      fn.apply null, args.concat([(err) ->
        args = Array::slice.call(arguments, 1)
        if typeof console isnt "undefined"
          if err
            console.error err  if console.error
          else if console[name]
            _each args, (x) ->
              console[name] x
              return

        return
      ])
      return

  async.log = _console_fn("log")
  async.dir = _console_fn("dir")
  
  #async.info = _console_fn('info');
  #    async.warn = _console_fn('warn');
  #    async.error = _console_fn('error');
  async.memoize = (fn, hasher) ->
    memo = {}
    queues = {}
    hasher = hasher or (x) ->
      x

    memoized = ->
      args = Array::slice.call(arguments)
      callback = args.pop()
      key = hasher.apply(null, args)
      if key of memo
        async.nextTick ->
          callback.apply null, memo[key]
          return

      else if key of queues
        queues[key].push callback
      else
        queues[key] = [callback]
        fn.apply null, args.concat([->
          memo[key] = arguments
          q = queues[key]
          delete queues[key]

          i = 0
          l = q.length

          while i < l
            q[i].apply null, arguments
            i++
          return
        ])
      return

    memoized.memo = memo
    memoized.unmemoized = fn
    memoized

  async.unmemoize = (fn) ->
    ->
      (fn.unmemoized or fn).apply null, arguments

  async.times = (count, iterator, callback) ->
    counter = []
    i = 0

    while i < count
      counter.push i
      i++
    async.map counter, iterator, callback

  async.timesSeries = (count, iterator, callback) ->
    counter = []
    i = 0

    while i < count
      counter.push i
      i++
    async.mapSeries counter, iterator, callback

  async.seq = -> # functions...
    fns = arguments
    ->
      that = this
      args = Array::slice.call(arguments)
      callback = args.pop()
      async.reduce fns, args, ((newargs, fn, cb) ->
        fn.apply that, newargs.concat([->
          err = arguments[0]
          nextargs = Array::slice.call(arguments, 1)
          cb err, nextargs
          return
        ])
        return
      ), (err, results) ->
        callback.apply that, [err].concat(results)
        return

      return

  async.compose = -> # functions...
    async.seq.apply null, Array::reverse.call(arguments)

  _applyEach = (eachfn, fns) -> #args...
    go = ->
      that = this
      args = Array::slice.call(arguments)
      callback = args.pop()
      eachfn fns, ((fn, cb) ->
        fn.apply that, args.concat([cb])
        return
      ), callback

    if arguments.length > 2
      args = Array::slice.call(arguments, 2)
      go.apply this, args
    else
      go

  async.applyEach = doParallel(_applyEach)
  async.applyEachSeries = doSeries(_applyEach)
  async.forever = (fn, callback) ->
    next = (err) ->
      if err
        return callback(err)  if callback
        throw err
      fn next
      return
    next()
    return

  
  # Node.js
  if typeof module isnt "undefined" and module.exports
    module.exports = async
  
  # AMD / RequireJS
  else if typeof define isnt "undefined" and define.amd
    define [], ->
      async

  
  # included directly via <script> tag
  else
    root.async = async
  return
)()
