DelayedStream = ->
  @source = null
  @dataSize = 0
  @maxDataSize = 1024 * 1024
  @pauseStream = true
  @_maxDataSizeExceeded = false
  @_released = false
  @_bufferedEvents = []
  return
Stream = require("stream").Stream
util = require("util")
module.exports = DelayedStream
util.inherits DelayedStream, Stream
DelayedStream.create = (source, options) ->
  delayedStream = new this()
  options = options or {}
  for option of options
    delayedStream[option] = options[option]
  delayedStream.source = source
  realEmit = source.emit
  source.emit = ->
    delayedStream._handleEmit arguments
    realEmit.apply source, arguments

  source.on "error", ->

  source.pause()  if delayedStream.pauseStream
  delayedStream

DelayedStream::__defineGetter__ "readable", ->
  @source.readable

DelayedStream::resume = ->
  @release()  unless @_released
  @source.resume()
  return

DelayedStream::pause = ->
  @source.pause()
  return

DelayedStream::release = ->
  @_released = true
  @_bufferedEvents.forEach ((args) ->
    @emit.apply this, args
    return
  ).bind(this)
  @_bufferedEvents = []
  return

DelayedStream::pipe = ->
  r = Stream::pipe.apply(this, arguments)
  @resume()
  r

DelayedStream::_handleEmit = (args) ->
  if @_released
    @emit.apply this, args
    return
  if args[0] is "data"
    @dataSize += args[1].length
    @_checkIfMaxDataSizeExceeded()
  @_bufferedEvents.push args
  return

DelayedStream::_checkIfMaxDataSizeExceeded = ->
  return  if @_maxDataSizeExceeded
  return  if @dataSize <= @maxDataSize
  @_maxDataSizeExceeded = true
  message = "DelayedStream#maxDataSize of " + @maxDataSize + " bytes exceeded."
  @emit "error", new Error(message)
  return
