CombinedStream = ->
  @writable = false
  @readable = true
  @dataSize = 0
  @maxDataSize = 2 * 1024 * 1024
  @pauseStreams = true
  @_released = false
  @_streams = []
  @_currentStream = null
  return
util = require("util")
Stream = require("stream").Stream
DelayedStream = require("delayed-stream")
module.exports = CombinedStream
util.inherits CombinedStream, Stream
CombinedStream.create = (options) ->
  combinedStream = new this()
  options = options or {}
  for option of options
    combinedStream[option] = options[option]
  combinedStream

CombinedStream.isStreamLike = (stream) ->
  (typeof stream isnt "function") and (typeof stream isnt "string") and (typeof stream isnt "boolean") and (typeof stream isnt "number") and (not Buffer.isBuffer(stream))

CombinedStream::append = (stream) ->
  isStreamLike = CombinedStream.isStreamLike(stream)
  if isStreamLike
    unless stream instanceof DelayedStream
      stream.on "data", @_checkDataSize.bind(this)
      stream = DelayedStream.create(stream,
        maxDataSize: Infinity
        pauseStream: @pauseStreams
      )
    @_handleErrors stream
    stream.pause()  if @pauseStreams
  @_streams.push stream
  this

CombinedStream::pipe = (dest, options) ->
  Stream::pipe.call this, dest, options
  @resume()
  dest

CombinedStream::_getNext = ->
  @_currentStream = null
  stream = @_streams.shift()
  if typeof stream is "undefined"
    @end()
    return
  if typeof stream isnt "function"
    @_pipeNext stream
    return
  getStream = stream
  getStream ((stream) ->
    isStreamLike = CombinedStream.isStreamLike(stream)
    if isStreamLike
      stream.on "data", @_checkDataSize.bind(this)
      @_handleErrors stream
    @_pipeNext stream
    return
  ).bind(this)
  return

CombinedStream::_pipeNext = (stream) ->
  @_currentStream = stream
  isStreamLike = CombinedStream.isStreamLike(stream)
  if isStreamLike
    stream.on "end", @_getNext.bind(this)
    stream.pipe this,
      end: false

    return
  value = stream
  @write value
  @_getNext()
  return

CombinedStream::_handleErrors = (stream) ->
  self = this
  stream.on "error", (err) ->
    self._emitError err
    return

  return

CombinedStream::write = (data) ->
  @emit "data", data
  return

CombinedStream::pause = ->
  return  unless @pauseStreams
  @emit "pause"
  return

CombinedStream::resume = ->
  unless @_released
    @_released = true
    @writable = true
    @_getNext()
  @emit "resume"
  return

CombinedStream::end = ->
  @_reset()
  @emit "end"
  return

CombinedStream::destroy = ->
  @_reset()
  @emit "close"
  return

CombinedStream::_reset = ->
  @writable = false
  @_streams = []
  @_currentStream = null
  return

CombinedStream::_checkDataSize = ->
  @_updateDataSize()
  return  if @dataSize <= @maxDataSize
  message = "DelayedStream#maxDataSize of " + @maxDataSize + " bytes exceeded."
  @_emitError new Error(message)
  return

CombinedStream::_updateDataSize = ->
  @dataSize = 0
  self = this
  @_streams.forEach (stream) ->
    return  unless stream.dataSize
    self.dataSize += stream.dataSize
    return

  @dataSize += @_currentStream.dataSize  if @_currentStream and @_currentStream.dataSize
  return

CombinedStream::_emitError = (err) ->
  @_reset()
  @emit "error", err
  return
