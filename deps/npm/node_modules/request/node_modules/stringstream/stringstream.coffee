StringStream = (from, to) ->
  return new StringStream(from, to)  unless this instanceof StringStream
  Stream.call this
  from = "utf8"  unless from?
  @readable = @writable = true
  @paused = false
  @toEncoding = ((if not to? then from else to))
  @fromEncoding = ((if not to? then "" else from))
  @decoder = new AlignedStringDecoder(@toEncoding)
  return
AlignedStringDecoder = (encoding) ->
  StringDecoder.call this, encoding
  switch @encoding
    when "base64"
      @write = alignedWrite
      @alignedBuffer = new Buffer(3)
      @alignedBytes = 0
alignedWrite = (buffer) ->
  rem = (@alignedBytes + buffer.length) % @alignedBuffer.length
  return buffer.toString(@encoding)  if not rem and not @alignedBytes
  returnBuffer = new Buffer(@alignedBytes + buffer.length - rem)
  @alignedBuffer.copy returnBuffer, 0, 0, @alignedBytes
  buffer.copy returnBuffer, @alignedBytes, 0, buffer.length - rem
  buffer.copy @alignedBuffer, 0, buffer.length - rem, buffer.length
  @alignedBytes = rem
  returnBuffer.toString @encoding
util = require("util")
Stream = require("stream")
StringDecoder = require("string_decoder").StringDecoder
module.exports = StringStream
module.exports.AlignedStringDecoder = AlignedStringDecoder
util.inherits StringStream, Stream
StringStream::write = (data) ->
  unless @writable
    err = new Error("stream not writable")
    err.code = "EPIPE"
    @emit "error", err
    return false
  if @fromEncoding
    data = data.toString()  if Buffer.isBuffer(data)
    data = new Buffer(data, @fromEncoding)
  string = @decoder.write(data)
  @emit "data", string  if string.length
  not @paused

StringStream::flush = ->
  if @decoder.flush
    string = @decoder.flush()
    @emit "data", string  if string.length
  return

StringStream::end = ->
  return @flush()  if not @writable and not @readable
  @emit "end"
  @writable = @readable = false
  @destroy()
  return

StringStream::destroy = ->
  @decoder = null
  @writable = @readable = false
  @emit "close"
  return

StringStream::pause = ->
  @paused = true
  return

StringStream::resume = ->
  @emit "drain"  if @paused
  @paused = false
  return

util.inherits AlignedStringDecoder, StringDecoder
AlignedStringDecoder::flush = ->
  return ""  if not @alignedBuffer or not @alignedBytes
  leftover = @alignedBuffer.toString(@encoding, 0, @alignedBytes)
  @alignedBytes = 0
  leftover
