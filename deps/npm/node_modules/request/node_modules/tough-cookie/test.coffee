#
# * Copyright GoInstant, Inc. and other contributors. All rights reserved.
# * Permission is hereby granted, free of charge, to any person obtaining a copy
# * of this software and associated documentation files (the "Software"), to
# * deal in the Software without restriction, including without limitation the
# * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# * sell copies of the Software, and to permit persons to whom the Software is
# * furnished to do so, subject to the following conditions:
# *
# * The above copyright notice and this permission notice shall be included in
# * all copies or substantial portions of the Software.
# *
# * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# * IN THE SOFTWARE.
# 

# NOTE use require("tough-cookie") in your own code:
dateVows = (table) ->
  theVows = {}
  Object.keys(table).forEach (date) ->
    expect = table[date]
    theVows[date] = ->
      got = (if tough.parseDate(date) then "valid" else "invalid")
      assert.equal got, (if expect then "valid" else "invalid")
      return

    return

  "date parsing": theVows
matchVows = (func, table) ->
  theVows = {}
  table.forEach (item) ->
    str = item[0]
    dom = item[1]
    expect = item[2]
    label = str + ((if expect then " matches " else " doesn't match ")) + dom
    theVows[label] = ->
      assert.equal func(str, dom), expect
      return

    return

  theVows
defaultPathVows = (table) ->
  theVows = {}
  table.forEach (item) ->
    str = item[0]
    expect = item[1]
    label = str + " gives " + expect
    theVows[label] = ->
      assert.equal tough.defaultPath(str), expect
      return

    return

  theVows
at = (offset) ->
  now: new Date(atNow + offset)
"use strict"
vows = require("vows")
assert = require("assert")
async = require("async")
tough = require("./lib/cookie")
Cookie = tough.Cookie
CookieJar = tough.CookieJar
atNow = Date.now()
# before 1601
# implicit year
# strange time, non-strict OK
# dashes
# dashes and UTC
# mabe this one *shouldn't*?
# should be treated as "earliest representable"
# not valid, really: non-zero-digit *DIGIT
# should be treated as "earliest representable"
# not valid, really: non-zero-digit *DIGIT
# BUG
# "test.test" in greek

# str,          dom,          expect
# RFC6265 S4.1.2.3
# S5.1.3 "The string is a host name"

# request, cookie, match

# force a stable creation time consistent with the order above since
# some may have been created at now + 1ms.

# weak shuffle:
# C is for Cookie, good enough for me
# recently stamped
# path
# host only
# other domain
# expired
# expired via Max-Age
# so that 'h=8' expires
# note lack of 'e'

# may break with sorting; sorting should put 3333 first due to longest path:
vows.describe("Cookie Jar").addBatch("all defined": ->
  assert.ok Cookie
  assert.ok CookieJar
  return
).addBatch(dateVows(
  "Wed, 09 Jun 2021 10:18:14 GMT": true
  "Wed, 09 Jun 2021 22:18:14 GMT": true
  "Tue, 18 Oct 2011 07:42:42.123 GMT": true
  "18 Oct 2011 07:42:42 GMT": true
  "8 Oct 2011 7:42:42 GMT": true
  "8 Oct 2011 7:2:42 GMT": false
  "Oct 18 2011 07:42:42 GMT": true
  "Tue Oct 18 2011 07:05:03 GMT+0000 (GMT)": true
  "09 Jun 2021 10:18:14 GMT": true
  "99 Jix 3038 48:86:72 ZMT": false
  "01 Jan 1970 00:00:00 GMT": true
  "01 Jan 1600 00:00:00 GMT": false
  "01 Jan 1601 00:00:00 GMT": true
  "10 Feb 81 13:00:00 GMT": true
  "Thu, 01 Jan 1970 00:00:010 GMT": true
  "Thu, 17-Apr-2014 02:12:29 GMT": true
  "Thu, 17-Apr-2014 02:12:29 UTC": true
)).addBatch("strict date parse of Thu, 01 Jan 1970 00:00:010 GMT":
  topic: ->
    (if tough.parseDate("Thu, 01 Jan 1970 00:00:010 GMT", true) then true else false)

  invalid: (date) ->
    assert.equal date, false
    return
).addBatch(formatting:
  "a simple cookie":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "b"
      c

    validates: (c) ->
      assert.ok c.validate()
      return

    "to string": (c) ->
      assert.equal c.toString(), "a=b"
      return

  "a cookie with spaces in the value":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "beta gamma"
      c

    "doesn't validate": (c) ->
      assert.ok not c.validate()
      return

    "'garbage in, garbage out'": (c) ->
      assert.equal c.toString(), "a=beta gamma"
      return

  "with an empty value and HttpOnly":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.httpOnly = true
      c

    "to string": (c) ->
      assert.equal c.toString(), "a=; HttpOnly"
      return

  "with an expiry":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "b"
      c.setExpires "Oct 18 2011 07:05:03 GMT"
      c

    validates: (c) ->
      assert.ok c.validate()
      return

    "to string": (c) ->
      assert.equal c.toString(), "a=b; Expires=Tue, 18 Oct 2011 07:05:03 GMT"
      return

    "to short string": (c) ->
      assert.equal c.cookieString(), "a=b"
      return

  "with a max-age":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "b"
      c.setExpires "Oct 18 2011 07:05:03 GMT"
      c.maxAge = 12345
      c

    validates: (c) ->
      assert.ok c.validate()
      return

    "to string": (c) ->
      assert.equal c.toString(), "a=b; Expires=Tue, 18 Oct 2011 07:05:03 GMT; Max-Age=12345"
      return

  "with a bunch of things": ->
    c = new Cookie()
    c.key = "a"
    c.value = "b"
    c.setExpires "Oct 18 2011 07:05:03 GMT"
    c.maxAge = 12345
    c.domain = "example.com"
    c.path = "/foo"
    c.secure = true
    c.httpOnly = true
    c.extensions = ["MyExtension"]
    assert.equal c.toString(), "a=b; Expires=Tue, 18 Oct 2011 07:05:03 GMT; Max-Age=12345; Domain=example.com; Path=/foo; Secure; HttpOnly; MyExtension"
    return

  "a host-only cookie":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "b"
      c.hostOnly = true
      c.domain = "shouldnt-stringify.example.com"
      c.path = "/should-stringify"
      c

    validates: (c) ->
      assert.ok c.validate()
      return

    "to string": (c) ->
      assert.equal c.toString(), "a=b; Path=/should-stringify"
      return

  "minutes are '10'":
    topic: ->
      c = new Cookie()
      c.key = "a"
      c.value = "b"
      c.expires = new Date(1284113410000)
      c

    validates: (c) ->
      assert.ok c.validate()
      return

    "to string": (c) ->
      str = c.toString()
      assert.notEqual str, "a=b; Expires=Fri, 010 Sep 2010 010:010:010 GMT"
      assert.equal str, "a=b; Expires=Fri, 10 Sep 2010 10:10:10 GMT"
      return
).addBatch(
  "TTL with max-age": ->
    c = new Cookie()
    c.maxAge = 123
    assert.equal c.TTL(), 123000
    assert.equal c.expiryTime(new Date(9000000)), 9123000
    return

  "TTL with zero max-age": ->
    c = new Cookie()
    c.key = "a"
    c.value = "b"
    c.maxAge = 0
    assert.equal c.TTL(), 0
    assert.equal c.expiryTime(new Date(9000000)), -Infinity
    assert.ok not c.validate()
    return

  "TTL with negative max-age": ->
    c = new Cookie()
    c.key = "a"
    c.value = "b"
    c.maxAge = -1
    assert.equal c.TTL(), 0
    assert.equal c.expiryTime(new Date(9000000)), -Infinity
    assert.ok not c.validate()
    return

  "TTL with max-age and expires": ->
    c = new Cookie()
    c.maxAge = 123
    c.expires = new Date(Date.now() + 9000)
    assert.equal c.TTL(), 123000
    assert.ok c.isPersistent()
    return

  "TTL with expires": ->
    c = new Cookie()
    now = Date.now()
    c.expires = new Date(now + 9000)
    assert.equal c.TTL(now), 9000
    assert.equal c.expiryTime(), c.expires.getTime()
    return

  "TTL with old expires": ->
    c = new Cookie()
    c.setExpires "17 Oct 2010 00:00:00 GMT"
    assert.ok c.TTL() < 0
    assert.ok c.isPersistent()
    return

  "default TTL":
    topic: ->
      new Cookie()

    "is Infinite-future": (c) ->
      assert.equal c.TTL(), Infinity
      return

    "is a 'session' cookie": (c) ->
      assert.ok not c.isPersistent()
      return
).addBatch(Parsing:
  simple:
    topic: ->
      Cookie.parse("a=bcd", true) or null

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "a"
      return

    value: (c) ->
      assert.equal c.value, "bcd"
      return

    "no path": (c) ->
      assert.equal c.path, null
      return

    "no domain": (c) ->
      assert.equal c.domain, null
      return

    "no extensions": (c) ->
      assert.ok not c.extensions
      return

  "with expiry":
    topic: ->
      Cookie.parse("a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT", true) or null

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "a"
      return

    value: (c) ->
      assert.equal c.value, "bcd"
      return

    "has expires": (c) ->
      assert.ok c.expires isnt Infinity, "expiry is infinite when it shouldn't be"
      assert.equal c.expires.getTime(), 1318921503000
      return

  "with expiry and path":
    topic: ->
      Cookie.parse("abc=\"xyzzy!\"; Expires=Tue, 18 Oct 2011 07:05:03 GMT; Path=/aBc", true) or null

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "abc"
      return

    value: (c) ->
      assert.equal c.value, "xyzzy!"
      return

    "has expires": (c) ->
      assert.ok c.expires isnt Infinity, "expiry is infinite when it shouldn't be"
      assert.equal c.expires.getTime(), 1318921503000
      return

    "has path": (c) ->
      assert.equal c.path, "/aBc"
      return

    "no httponly or secure": (c) ->
      assert.ok not c.httpOnly
      assert.ok not c.secure
      return

  "with everything":
    topic: ->
      Cookie.parse("abc=\"xyzzy!\"; Expires=Tue, 18 Oct 2011 07:05:03 GMT; Path=/aBc; Domain=example.com; Secure; HTTPOnly; Max-Age=1234; Foo=Bar; Baz", true) or null

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "abc"
      return

    value: (c) ->
      assert.equal c.value, "xyzzy!"
      return

    "has expires": (c) ->
      assert.ok c.expires isnt Infinity, "expiry is infinite when it shouldn't be"
      assert.equal c.expires.getTime(), 1318921503000
      return

    "has path": (c) ->
      assert.equal c.path, "/aBc"
      return

    "has domain": (c) ->
      assert.equal c.domain, "example.com"
      return

    "has httponly": (c) ->
      assert.equal c.httpOnly, true
      return

    "has secure": (c) ->
      assert.equal c.secure, true
      return

    "has max-age": (c) ->
      assert.equal c.maxAge, 1234
      return

    "has extensions": (c) ->
      assert.ok c.extensions
      assert.equal c.extensions[0], "Foo=Bar"
      assert.equal c.extensions[1], "Baz"
      return

  "invalid expires":
    strict: ->
      assert.ok not Cookie.parse("a=b; Expires=xyzzy", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; Expires=xyzzy")
      assert.ok c
      assert.equal c.expires, Infinity
      return

  "zero max-age":
    strict: ->
      assert.ok not Cookie.parse("a=b; Max-Age=0", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; Max-Age=0")
      assert.ok c
      assert.equal c.maxAge, 0
      return

  "negative max-age":
    strict: ->
      assert.ok not Cookie.parse("a=b; Max-Age=-1", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; Max-Age=-1")
      assert.ok c
      assert.equal c.maxAge, -1
      return

  "empty domain":
    strict: ->
      assert.ok not Cookie.parse("a=b; domain=", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; domain=")
      assert.ok c
      assert.equal c.domain, null
      return

  "dot domain":
    strict: ->
      assert.ok not Cookie.parse("a=b; domain=.", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; domain=.")
      assert.ok c
      assert.equal c.domain, null
      return

  "uppercase domain":
    "strict lowercases": ->
      c = Cookie.parse("a=b; domain=EXAMPLE.COM")
      assert.ok c
      assert.equal c.domain, "example.com"
      return

    "non-strict lowercases": ->
      c = Cookie.parse("a=b; domain=EXAMPLE.COM")
      assert.ok c
      assert.equal c.domain, "example.com"
      return

  "trailing dot in domain":
    topic: ->
      Cookie.parse("a=b; Domain=example.com.", true) or null

    "has the domain": (c) ->
      assert.equal c.domain, "example.com."
      return

    "but doesn't validate": (c) ->
      assert.equal c.validate(), false
      return

  "empty path":
    strict: ->
      assert.ok not Cookie.parse("a=b; path=", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; path=")
      assert.ok c
      assert.equal c.path, null
      return

  "no-slash path":
    strict: ->
      assert.ok not Cookie.parse("a=b; path=xyzzy", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; path=xyzzy")
      assert.ok c
      assert.equal c.path, null
      return

  "trailing semi-colons after path":
    topic: ->
      [
        "a=b; path=/;"
        "c=d;;;;"
      ]

    strict: (t) ->
      assert.ok not Cookie.parse(t[0], true)
      assert.ok not Cookie.parse(t[1], true)
      return

    "non-strict": (t) ->
      c1 = Cookie.parse(t[0])
      c2 = Cookie.parse(t[1])
      assert.ok c1
      assert.ok c2
      assert.equal c1.path, "/"
      return

  "secure-with-value":
    strict: ->
      assert.ok not Cookie.parse("a=b; Secure=xyzzy", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; Secure=xyzzy")
      assert.ok c
      assert.equal c.secure, true
      return

  "httponly-with-value":
    strict: ->
      assert.ok not Cookie.parse("a=b; HttpOnly=xyzzy", true)
      return

    "non-strict": ->
      c = Cookie.parse("a=b; HttpOnly=xyzzy")
      assert.ok c
      assert.equal c.httpOnly, true
      return

  garbage:
    topic: ->
      Cookie.parse("\b", true) or null

    "doesn't parse": (c) ->
      assert.equal c, null
      return

  "public suffix domain":
    topic: ->
      Cookie.parse("a=b; domain=kyoto.jp", true) or null

    "parses fine": (c) ->
      assert.ok c
      assert.equal c.domain, "kyoto.jp"
      return

    "but fails validation": (c) ->
      assert.ok c
      assert.ok not c.validate()
      return

  "Ironically, Google 'GAPS' cookie has very little whitespace":
    topic: ->
      Cookie.parse "GAPS=1:A1aaaaAaAAa1aaAaAaaAAAaaa1a11a:aaaAaAaAa-aaaA1-;Path=/;Expires=Thu, 17-Apr-2014 02:12:29 GMT;Secure;HttpOnly"

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "GAPS"
      return

    value: (c) ->
      assert.equal c.value, "1:A1aaaaAaAAa1aaAaAaaAAAaaa1a11a:aaaAaAaAa-aaaA1-"
      return

    path: (c) ->
      assert.notEqual c.path, "/;Expires"
      assert.equal c.path, "/"
      return

    expires: (c) ->
      assert.notEqual c.expires, Infinity
      assert.equal c.expires.getTime(), 1397700749000
      return

    secure: (c) ->
      assert.ok c.secure
      return

    httponly: (c) ->
      assert.ok c.httpOnly
      return

  "lots of equal signs":
    topic: ->
      Cookie.parse "queryPref=b=c&d=e; Path=/f=g; Expires=Thu, 17 Apr 2014 02:12:29 GMT; HttpOnly"

    parsed: (c) ->
      assert.ok c
      return

    key: (c) ->
      assert.equal c.key, "queryPref"
      return

    value: (c) ->
      assert.equal c.value, "b=c&d=e"
      return

    path: (c) ->
      assert.equal c.path, "/f=g"
      return

    expires: (c) ->
      assert.notEqual c.expires, Infinity
      assert.equal c.expires.getTime(), 1397700749000
      return

    httponly: (c) ->
      assert.ok c.httpOnly
      return

  "spaces in value":
    strict:
      topic: ->
        Cookie.parse("a=one two three", true) or null

      "did not parse": (c) ->
        assert.isNull c
        return

    "non-strict":
      topic: ->
        Cookie.parse("a=one two three", false) or null

      parsed: (c) ->
        assert.ok c
        return

      key: (c) ->
        assert.equal c.key, "a"
        return

      value: (c) ->
        assert.equal c.value, "one two three"
        return

      "no path": (c) ->
        assert.equal c.path, null
        return

      "no domain": (c) ->
        assert.equal c.domain, null
        return

      "no extensions": (c) ->
        assert.ok not c.extensions
        return

  "quoted spaces in value":
    strict:
      topic: ->
        Cookie.parse("a=\"one two three\"", true) or null

      "did not parse": (c) ->
        assert.isNull c
        return

    "non-strict":
      topic: ->
        Cookie.parse("a=\"one two three\"", false) or null

      parsed: (c) ->
        assert.ok c
        return

      key: (c) ->
        assert.equal c.key, "a"
        return

      value: (c) ->
        assert.equal c.value, "one two three"
        return

      "no path": (c) ->
        assert.equal c.path, null
        return

      "no domain": (c) ->
        assert.equal c.domain, null
        return

      "no extensions": (c) ->
        assert.ok not c.extensions
        return

  "non-ASCII in value":
    strict:
      topic: ->
        Cookie.parse("farbe=weiß", true) or null

      "did not parse": (c) ->
        assert.isNull c
        return

    "non-strict":
      topic: ->
        Cookie.parse("farbe=weiß", false) or null

      parsed: (c) ->
        assert.ok c
        return

      key: (c) ->
        assert.equal c.key, "farbe"
        return

      value: (c) ->
        assert.equal c.value, "weiß"
        return

      "no path": (c) ->
        assert.equal c.path, null
        return

      "no domain": (c) ->
        assert.equal c.domain, null
        return

      "no extensions": (c) ->
        assert.ok not c.extensions
        return
).addBatch("domain normalization":
  simple: ->
    c = new Cookie()
    c.domain = "EXAMPLE.com"
    assert.equal c.canonicalizedDomain(), "example.com"
    return

  "extra dots": ->
    c = new Cookie()
    c.domain = ".EXAMPLE.com"
    assert.equal c.cdomain(), "example.com"
    return

  "weird trailing dot": ->
    c = new Cookie()
    c.domain = "EXAMPLE.ca."
    assert.equal c.canonicalizedDomain(), "example.ca."
    return

  "weird internal dots": ->
    c = new Cookie()
    c.domain = "EXAMPLE...ca."
    assert.equal c.canonicalizedDomain(), "example...ca."
    return

  IDN: ->
    c = new Cookie()
    c.domain = "δοκιμή.δοκιμή"
    assert.equal c.canonicalizedDomain(), "xn--jxalpdlp.xn--jxalpdlp"
    return
).addBatch("Domain Match": matchVows(tough.domainMatch, [
  [
    "example.com"
    "example.com"
    true
  ]
  [
    "eXaMpLe.cOm"
    "ExAmPlE.CoM"
    true
  ]
  [
    "no.ca"
    "yes.ca"
    false
  ]
  [
    "wwwexample.com"
    "example.com"
    false
  ]
  [
    "www.example.com"
    "example.com"
    true
  ]
  [
    "example.com"
    "www.example.com"
    false
  ]
  [
    "www.subdom.example.com"
    "example.com"
    true
  ]
  [
    "www.subdom.example.com"
    "subdom.example.com"
    true
  ]
  [
    "example.com"
    "example.com."
    false
  ]
  [
    "192.168.0.1"
    "168.0.1"
    false
  ]
  [
    null
    "example.com"
    null
  ]
  [
    "example.com"
    null
    null
  ]
  [
    null
    null
    null
  ]
  [
    `undefined`
    `undefined`
    null
  ]
])).addBatch("default-path": defaultPathVows([
  [
    null
    "/"
  ]
  [
    "/"
    "/"
  ]
  [
    "/file"
    "/"
  ]
  [
    "/dir/file"
    "/dir"
  ]
  [
    "noslash"
    "/"
  ]
])).addBatch("Path-Match": matchVows(tough.pathMatch, [
  [
    "/"
    "/"
    true
  ]
  [
    "/dir"
    "/"
    true
  ]
  [
    "/"
    "/dir"
    false
  ]
  [
    "/dir/"
    "/dir/"
    true
  ]
  [
    "/dir/file"
    "/dir/"
    true
  ]
  [
    "/dir/file"
    "/dir"
    true
  ]
  [
    "/directory"
    "/dir"
    false
  ]
])).addBatch("Cookie Sorting":
  topic: ->
    cookies = []
    now = Date.now()
    cookies.push Cookie.parse("a=0; Domain=example.com")
    cookies.push Cookie.parse("b=1; Domain=www.example.com")
    cookies.push Cookie.parse("c=2; Domain=example.com; Path=/pathA")
    cookies.push Cookie.parse("d=3; Domain=www.example.com; Path=/pathA")
    cookies.push Cookie.parse("e=4; Domain=example.com; Path=/pathA/pathB")
    cookies.push Cookie.parse("f=5; Domain=www.example.com; Path=/pathA/pathB")
    i = cookies.length
    cookies.forEach (cookie) ->
      cookie.creation = new Date(now - 100 * (i--))
      return

    cookies = cookies.sort(->
      Math.random() - 0.5
    )
    cookies = cookies.sort(tough.cookieCompare)
    cookies

  got: (cookies) ->
    assert.lengthOf cookies, 6
    names = cookies.map((c) ->
      c.key
    )
    assert.deepEqual names, [
      "e"
      "f"
      "c"
      "d"
      "a"
      "b"
    ]
    return
).addBatch(
  CookieJar:
    "Setting a basic cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com; Path=/")
        assert.strictEqual c.hostOnly, null
        assert.instanceOf c.creation, Date
        assert.strictEqual c.lastAccessed, null
        c.creation = new Date(Date.now() - 10000)
        cj.setCookie c, "http://example.com/index.html", @callback
        return

      works: (c) ->
        assert.instanceOf c, Cookie
        return

      "gets timestamped": (c) ->
        assert.ok c.creation
        assert.ok Date.now() - c.creation.getTime() < 5000
        assert.ok c.lastAccessed
        assert.equal c.creation, c.lastAccessed
        assert.equal c.TTL(), Infinity
        assert.ok not c.isPersistent()
        return

    "Setting a no-path cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com")
        assert.strictEqual c.hostOnly, null
        assert.instanceOf c.creation, Date
        assert.strictEqual c.lastAccessed, null
        c.creation = new Date(Date.now() - 10000)
        cj.setCookie c, "http://example.com/index.html", @callback
        return

      domain: (c) ->
        assert.equal c.domain, "example.com"
        return

      "path is /": (c) ->
        assert.equal c.path, "/"
        return

      "path was derived": (c) ->
        assert.strictEqual c.pathIsDefault, true
        return

    "Setting a cookie already marked as host-only":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com")
        assert.strictEqual c.hostOnly, null
        assert.instanceOf c.creation, Date
        assert.strictEqual c.lastAccessed, null
        c.creation = new Date(Date.now() - 10000)
        c.hostOnly = true
        cj.setCookie c, "http://example.com/index.html", @callback
        return

      domain: (c) ->
        assert.equal c.domain, "example.com"
        return

      "still hostOnly": (c) ->
        assert.strictEqual c.hostOnly, true
        return

    "Setting a session cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b")
        assert.strictEqual c.path, null
        cj.setCookie c, "http://www.example.com/dir/index.html", @callback
        return

      works: (c) ->
        assert.instanceOf c, Cookie
        return

      "gets the domain": (c) ->
        assert.equal c.domain, "www.example.com"
        return

      "gets the default path": (c) ->
        assert.equal c.path, "/dir"
        return

      "is 'hostOnly'": (c) ->
        assert.ok c.hostOnly
        return

    "Setting wrong domain cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=fooxample.com; Path=/")
        cj.setCookie c, "http://example.com/index.html", @callback
        return

      fails: (err, c) ->
        assert.ok err.message.match(/domain/i)
        assert.ok not c
        return

    "Setting sub-domain cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=www.example.com; Path=/")
        cj.setCookie c, "http://example.com/index.html", @callback
        return

      fails: (err, c) ->
        assert.ok err.message.match(/domain/i)
        assert.ok not c
        return

    "Setting super-domain cookie":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com; Path=/")
        cj.setCookie c, "http://www.app.example.com/index.html", @callback
        return

      success: (err, c) ->
        assert.ok not err
        assert.equal c.domain, "example.com"
        return

    "Setting a sub-path cookie on a super-domain":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com; Path=/subpath")
        assert.strictEqual c.hostOnly, null
        assert.instanceOf c.creation, Date
        assert.strictEqual c.lastAccessed, null
        c.creation = new Date(Date.now() - 10000)
        cj.setCookie c, "http://www.example.com/index.html", @callback
        return

      "domain is super-domain": (c) ->
        assert.equal c.domain, "example.com"
        return

      "path is /subpath": (c) ->
        assert.equal c.path, "/subpath"
        return

      "path was NOT derived": (c) ->
        assert.strictEqual c.pathIsDefault, null
        return

    "Setting HttpOnly cookie over non-HTTP API":
      topic: ->
        cj = new CookieJar()
        c = Cookie.parse("a=b; Domain=example.com; Path=/; HttpOnly")
        cj.setCookie c, "http://example.com/index.html",
          http: false
        , @callback
        return

      fails: (err, c) ->
        assert.match err.message, /HttpOnly/i
        assert.ok not c
        return

  "Cookie Jar store eight cookies":
    topic: ->
      cj = new CookieJar()
      ex = "http://example.com/index.html"
      tasks = []
      tasks.push (next) ->
        cj.setCookie "a=1; Domain=example.com; Path=/", ex, at(0), next
        return

      tasks.push (next) ->
        cj.setCookie "b=2; Domain=example.com; Path=/; HttpOnly", ex, at(1000), next
        return

      tasks.push (next) ->
        cj.setCookie "c=3; Domain=example.com; Path=/; Secure", ex, at(2000), next
        return

      tasks.push (next) ->
        cj.setCookie "d=4; Domain=example.com; Path=/foo", ex, at(3000), next
        return

      tasks.push (next) ->
        cj.setCookie "e=5", ex, at(4000), next
        return

      tasks.push (next) ->
        cj.setCookie "f=6; Domain=nodejs.org; Path=/", "http://nodejs.org", at(5000), next
        return

      tasks.push (next) ->
        cj.setCookie "g=7; Domain=example.com; Path=/; Expires=Tue, 18 Oct 2011 00:00:00 GMT", ex, at(6000), next
        return

      tasks.push (next) ->
        cj.setCookie "h=8; Domain=example.com; Path=/; Max-Age=1", ex, next
        return

      cb = @callback
      async.parallel tasks, (err, results) ->
        setTimeout (->
          cb err, cj, results
          return
        ), 2000
        return

      return

    "setup ok": (err, cj, results) ->
      assert.ok not err
      assert.ok cj
      assert.ok results
      return

    "then retrieving for http://nodejs.org":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://nodejs.org", @callback
        return

      "get a nodejs cookie": (cookies) ->
        assert.lengthOf cookies, 1
        cookie = cookies[0]
        assert.equal cookie.domain, "nodejs.org"
        return

    "then retrieving for https://example.com":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "https://example.com",
          secure: true
        , @callback
        return

      "get a secure example cookie with others": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "a"
          "b"
          "c"
          "e"
        ]
        return

    "then retrieving for https://example.com (missing options)":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "https://example.com", @callback
        return

      "get a secure example cookie with others": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "a"
          "b"
          "c"
          "e"
        ]
        return

    "then retrieving for http://example.com":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://example.com", @callback
        return

      "get a bunch of cookies": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "a"
          "b"
          "e"
        ]
        return

    "then retrieving for http://EXAMPlE.com":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://EXAMPlE.com", @callback
        return

      "get a bunch of cookies": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "a"
          "b"
          "e"
        ]
        return

    "then retrieving for http://example.com, non-HTTP":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://example.com",
          http: false
        , @callback
        return

      "get a bunch of cookies": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "a"
          "e"
        ]
        return

    "then retrieving for http://example.com/foo/bar":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://example.com/foo/bar", @callback
        return

      "get a bunch of cookies": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "d"
          "a"
          "b"
          "e"
        ]
        return

    "then retrieving for http://example.com as a string":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookieString "http://example.com", @callback
        return

      "get a single string": (cookieHeader) ->
        assert.equal cookieHeader, "a=1; b=2; e=5"
        return

    "then retrieving for http://example.com as a set-cookie header":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getSetCookieStrings "http://example.com", @callback
        return

      "get a single string": (cookieHeaders) ->
        assert.lengthOf cookieHeaders, 3
        assert.equal cookieHeaders[0], "a=1; Domain=example.com; Path=/"
        assert.equal cookieHeaders[1], "b=2; Domain=example.com; Path=/; HttpOnly"
        assert.equal cookieHeaders[2], "e=5; Path=/"
        return

    "then retrieving for http://www.example.com/":
      topic: (cj, oldResults) ->
        assert.ok oldResults
        cj.getCookies "http://www.example.com/foo/bar", @callback
        return

      "get a bunch of cookies": (cookies) ->
        names = cookies.map((c) ->
          c.key
        )
        assert.deepEqual names, [
          "d"
          "a"
          "b"
        ]
        return

  "Repeated names":
    topic: ->
      cb = @callback
      cj = new CookieJar()
      ex = "http://www.example.com/"
      sc = cj.setCookie
      tasks = []
      now = Date.now()
      tasks.push sc.bind(cj, "aaaa=xxxx", ex, at(0))
      tasks.push sc.bind(cj, "aaaa=1111; Domain=www.example.com", ex, at(1000))
      tasks.push sc.bind(cj, "aaaa=2222; Domain=example.com", ex, at(2000))
      tasks.push sc.bind(cj, "aaaa=3333; Domain=www.example.com; Path=/pathA", ex, at(3000))
      async.series tasks, (err, results) ->
        results = results.filter((e) ->
          e isnt `undefined`
        )
        cb err,
          cj: cj
          cookies: results
          now: now

        return

      return

    "all got set": (err, t) ->
      assert.lengthOf t.cookies, 4
      return

    "then getting 'em back":
      topic: (t) ->
        cj = t.cj
        cj.getCookies "http://www.example.com/pathA", @callback
        return

      "there's just three": (err, cookies) ->
        vals = cookies.map((c) ->
          c.value
        )
        assert.deepEqual vals, [
          "3333"
          "1111"
          "2222"
        ]
        return

  "CookieJar setCookie errors":
    "public-suffix domain":
      topic: ->
        cj = new CookieJar()
        cj.setCookie "i=9; Domain=kyoto.jp; Path=/", "kyoto.jp", @callback
        return

      errors: (err, cookie) ->
        assert.ok err
        assert.ok not cookie
        assert.match err.message, /public suffix/i
        return

    "wrong domain":
      topic: ->
        cj = new CookieJar()
        cj.setCookie "j=10; Domain=google.com; Path=/", "google.ca", @callback
        return

      errors: (err, cookie) ->
        assert.ok err
        assert.ok not cookie
        assert.match err.message, /not in this host's domain/i
        return

    "old cookie is HttpOnly":
      topic: ->
        cb = @callback
        next = (err, c) ->
          c = null
          cb err, cj

        cj = new CookieJar()
        cj.setCookie "k=11; Domain=example.ca; Path=/; HttpOnly", "http://example.ca",
          http: true
        , next
        return

      "initial cookie is set": (err, cj) ->
        assert.ok not err
        assert.ok cj
        return

      "but when trying to overwrite":
        topic: (cj) ->
          cb = @callback
          next = (err, c) ->
            c = null
            cb null, err
            return

          cj.setCookie "k=12; Domain=example.ca; Path=/", "http://example.ca",
            http: false
          , next
          return

        "it's an error": (err) ->
          assert.ok err
          return

        "then, checking the original":
          topic: (ignored, cj) ->
            assert.ok cj instanceof CookieJar
            cj.getCookies "http://example.ca",
              http: true
            , @callback
            return

          "cookie has original value": (err, cookies) ->
            assert.equal err, null
            assert.lengthOf cookies, 1
            assert.equal cookies[0].value, 11
            return
).addBatch(
  JSON:
    serialization:
      topic: ->
        c = Cookie.parse("alpha=beta; Domain=example.com; Path=/foo; Expires=Tue, 19 Jan 2038 03:14:07 GMT; HttpOnly")
        JSON.stringify c

      "gives a string": (str) ->
        assert.equal typeof str, "string"
        return

      "date is in ISO format": (str) ->
        assert.match str, /"expires":"2038-01-19T03:14:07\.000Z"/, "expires is in ISO format"
        return

    deserialization:
      topic: ->
        json = "{\"key\":\"alpha\",\"value\":\"beta\",\"domain\":\"example.com\",\"path\":\"/foo\",\"expires\":\"2038-01-19T03:14:07.000Z\",\"httpOnly\":true,\"lastAccessed\":2000000000123}"
        Cookie.fromJSON json

      works: (c) ->
        assert.ok c
        return

      key: (c) ->
        assert.equal c.key, "alpha"
        return

      value: (c) ->
        assert.equal c.value, "beta"
        return

      domain: (c) ->
        assert.equal c.domain, "example.com"
        return

      path: (c) ->
        assert.equal c.path, "/foo"
        return

      httpOnly: (c) ->
        assert.strictEqual c.httpOnly, true
        return

      secure: (c) ->
        assert.strictEqual c.secure, false
        return

      hostOnly: (c) ->
        assert.strictEqual c.hostOnly, null
        return

      "expires is a date object": (c) ->
        assert.equal c.expires.getTime(), 2147483647000
        return

      "lastAccessed is a date object": (c) ->
        assert.equal c.lastAccessed.getTime(), 2000000000123
        return

      "creation defaulted": (c) ->
        assert.ok c.creation.getTime()
        return

    "null deserialization":
      topic: ->
        Cookie.fromJSON null

      "is null": (cookie) ->
        assert.equal cookie, null
        return

  "expiry deserialization":
    Infinity:
      topic: Cookie.fromJSON.bind(null, "{\"expires\":\"Infinity\"}")
      "is infinite": (c) ->
        assert.strictEqual c.expires, "Infinity"
        assert.equal c.expires, Infinity
        return

  "maxAge serialization":
    topic: ->
      (toSet) ->
        c = new Cookie()
        c.key = "foo"
        c.value = "bar"
        c.setMaxAge toSet
        JSON.stringify c

    zero:
      topic: (f) ->
        f 0

      "looks good": (str) ->
        assert.match str, /"maxAge":0/
        return

    Infinity:
      topic: (f) ->
        f Infinity

      "looks good": (str) ->
        assert.match str, /"maxAge":"Infinity"/
        return

    "-Infinity":
      topic: (f) ->
        f -Infinity

      "looks good": (str) ->
        assert.match str, /"maxAge":"-Infinity"/
        return

    null:
      topic: (f) ->
        f null

      "looks good": (str) ->
        assert.match str, /"maxAge":null/
        return

  "maxAge deserialization":
    number:
      topic: Cookie.fromJSON.bind(null, "{\"key\":\"foo\",\"value\":\"bar\",\"maxAge\":123}")
      "is the number": (c) ->
        assert.strictEqual c.maxAge, 123
        return

    null:
      topic: Cookie.fromJSON.bind(null, "{\"key\":\"foo\",\"value\":\"bar\",\"maxAge\":null}")
      "is null": (c) ->
        assert.strictEqual c.maxAge, null
        return

    "less than zero":
      topic: Cookie.fromJSON.bind(null, "{\"key\":\"foo\",\"value\":\"bar\",\"maxAge\":-123}")
      "is -123": (c) ->
        assert.strictEqual c.maxAge, -123
        return

    Infinity:
      topic: Cookie.fromJSON.bind(null, "{\"key\":\"foo\",\"value\":\"bar\",\"maxAge\":\"Infinity\"}")
      "is inf-as-string": (c) ->
        assert.strictEqual c.maxAge, "Infinity"
        return

    "-Infinity":
      topic: Cookie.fromJSON.bind(null, "{\"key\":\"foo\",\"value\":\"bar\",\"maxAge\":\"-Infinity\"}")
      "is inf-as-string": (c) ->
        assert.strictEqual c.maxAge, "-Infinity"
        return
).addBatch(
  permuteDomain:
    "base case":
      topic: tough.permuteDomain.bind(null, "example.com")
      "got the domain": (list) ->
        assert.deepEqual list, ["example.com"]
        return

    "two levels":
      topic: tough.permuteDomain.bind(null, "foo.bar.example.com")
      "got three things": (list) ->
        assert.deepEqual list, [
          "example.com"
          "bar.example.com"
          "foo.bar.example.com"
        ]
        return

    "invalid domain":
      topic: tough.permuteDomain.bind(null, "foo.bar.example.localduhmain")
      "got three things": (list) ->
        assert.equal list, null
        return

  permutePath:
    "base case":
      topic: tough.permutePath.bind(null, "/")
      "just slash": (list) ->
        assert.deepEqual list, ["/"]
        return

    "single case":
      topic: tough.permutePath.bind(null, "/foo")
      "two things": (list) ->
        assert.deepEqual list, [
          "/foo"
          "/"
        ]
        return

      "path matching": (list) ->
        list.forEach (e) ->
          assert.ok tough.pathMatch("/foo", e)
          return

        return

    "double case":
      topic: tough.permutePath.bind(null, "/foo/bar")
      "four things": (list) ->
        assert.deepEqual list, [
          "/foo/bar"
          "/foo"
          "/"
        ]
        return

      "path matching": (list) ->
        list.forEach (e) ->
          assert.ok tough.pathMatch("/foo/bar", e)
          return

        return

    "trailing slash":
      topic: tough.permutePath.bind(null, "/foo/bar/")
      "three things": (list) ->
        assert.deepEqual list, [
          "/foo/bar"
          "/foo"
          "/"
        ]
        return

      "path matching": (list) ->
        list.forEach (e) ->
          assert.ok tough.pathMatch("/foo/bar/", e)
          return

        return
).addBatch("Issue 1":
  topic: ->
    cj = new CookieJar()
    cj.setCookie "hello=world; path=/some/path/", "http://domain/some/path/file", ((err, cookie) ->
      @callback err,
        cj: cj
        cookie: cookie

      return
    ).bind(this)
    return

  "stored a cookie": (t) ->
    assert.ok t.cookie
    return

  "cookie's path was modified to remove unnecessary slash": (t) ->
    assert.equal t.cookie.path, "/some/path"
    return

  "getting it back":
    topic: (t) ->
      t.cj.getCookies "http://domain/some/path/file", ((err, cookies) ->
        @callback err,
          cj: t.cj
          cookies: cookies or []

        return
      ).bind(this)
      return

    "got one cookie": (t) ->
      assert.lengthOf t.cookies, 1
      return

    "it's the right one": (t) ->
      c = t.cookies[0]
      assert.equal c.key, "hello"
      assert.equal c.value, "world"
      return
).addBatch("expiry option":
  topic: ->
    cb = @callback
    cj = new CookieJar()
    cj.setCookie "near=expiry; Domain=example.com; Path=/; Max-Age=1", "http://www.example.com", at(-1), (err, cookie) ->
      cb err,
        cj: cj
        cookie: cookie

      return

    return

  "set the cookie": (t) ->
    assert.ok t.cookie, "didn't set?!"
    assert.equal t.cookie.key, "near"
    return

  "then, retrieving":
    topic: (t) ->
      cb = @callback
      setTimeout (->
        t.cj.getCookies "http://www.example.com",
          http: true
          expire: false
        , (err, cookies) ->
          t.cookies = cookies
          cb err, t
          return

        return
      ), 2000
      return

    "got the cookie": (t) ->
      assert.lengthOf t.cookies, 1
      assert.equal t.cookies[0].key, "near"
      return
).addBatch("trailing semi-colon set into cj":
  topic: ->
    cb = @callback
    cj = new CookieJar()
    ex = "http://www.example.com"
    tasks = []
    tasks.push (next) ->
      cj.setCookie "broken_path=testme; path=/;", ex, at(-1), next
      return

    tasks.push (next) ->
      cj.setCookie "b=2; Path=/;;;;", ex, at(-1), next
      return

    async.parallel tasks, (err, cookies) ->
      cb null,
        cj: cj
        cookies: cookies

      return

    return

  "check number of cookies": (t) ->
    assert.lengthOf t.cookies, 2, "didn't set"
    return

  "check *broken_path* was set properly": (t) ->
    assert.equal t.cookies[0].key, "broken_path"
    assert.equal t.cookies[0].value, "testme"
    assert.equal t.cookies[0].path, "/"
    return

  "check *b* was set properly": (t) ->
    assert.equal t.cookies[1].key, "b"
    assert.equal t.cookies[1].value, "2"
    assert.equal t.cookies[1].path, "/"
    return

  "retrieve the cookie":
    topic: (t) ->
      cb = @callback
      t.cj.getCookies "http://www.example.com", {}, (err, cookies) ->
        t.cookies = cookies
        cb err, t
        return

      return

    "get the cookie": (t) ->
      assert.lengthOf t.cookies, 2
      assert.equal t.cookies[0].key, "broken_path"
      assert.equal t.cookies[0].value, "testme"
      assert.equal t.cookies[1].key, "b"
      assert.equal t.cookies[1].value, "2"
      assert.equal t.cookies[1].path, "/"
      return
).addBatch(Constructor:
  topic: ->
    new Cookie(
      key: "test"
      value: "b"
      maxAge: 60
    )

  "check for key property": (c) ->
    assert.ok c
    assert.equal c.key, "test"
    return

  "check for value property": (c) ->
    assert.equal c.value, "b"
    return

  "check for maxAge": (c) ->
    assert.equal c.maxAge, 60
    return

  "check for default values for unspecified properties": (c) ->
    assert.equal c.expires, "Infinity"
    assert.equal c.secure, false
    assert.equal c.httpOnly, false
    return
).addBatch("allPaths option":
  topic: ->
    cj = new CookieJar()
    tasks = []
    tasks.push cj.setCookie.bind(cj, "nopath_dom=qq; Path=/; Domain=example.com", "http://example.com", {})
    tasks.push cj.setCookie.bind(cj, "path_dom=qq; Path=/foo; Domain=example.com", "http://example.com", {})
    tasks.push cj.setCookie.bind(cj, "nopath_host=qq; Path=/", "http://www.example.com", {})
    tasks.push cj.setCookie.bind(cj, "path_host=qq; Path=/foo", "http://www.example.com", {})
    tasks.push cj.setCookie.bind(cj, "other=qq; Path=/", "http://other.example.com/", {})
    tasks.push cj.setCookie.bind(cj, "other2=qq; Path=/foo", "http://other.example.com/foo", {})
    cb = @callback
    async.parallel tasks, (err, results) ->
      cb err,
        cj: cj
        cookies: results

      return

    return

  "all set": (t) ->
    assert.equal t.cookies.length, 6
    assert.ok t.cookies.every((c) ->
      !!c
    )
    return

  "getting without allPaths":
    topic: (t) ->
      cb = @callback
      cj = t.cj
      cj.getCookies "http://www.example.com/", {}, (err, cookies) ->
        cb err,
          cj: cj
          cookies: cookies

        return

      return

    "found just two cookies": (t) ->
      assert.equal t.cookies.length, 2
      return

    "all are path=/": (t) ->
      assert.ok t.cookies.every((c) ->
        c.path is "/"
      )
      return

    "no 'other' cookies": (t) ->
      assert.ok not t.cookies.some((c) ->
        (/^other/).test c.name
      )
      return

  "getting without allPaths for /foo":
    topic: (t) ->
      cb = @callback
      cj = t.cj
      cj.getCookies "http://www.example.com/foo", {}, (err, cookies) ->
        cb err,
          cj: cj
          cookies: cookies

        return

      return

    "found four cookies": (t) ->
      assert.equal t.cookies.length, 4
      return

    "no 'other' cookies": (t) ->
      assert.ok not t.cookies.some((c) ->
        (/^other/).test c.name
      )
      return

  "getting with allPaths:true":
    topic: (t) ->
      cb = @callback
      cj = t.cj
      cj.getCookies "http://www.example.com/",
        allPaths: true
      , (err, cookies) ->
        cb err,
          cj: cj
          cookies: cookies

        return

      return

    "found four cookies": (t) ->
      assert.equal t.cookies.length, 4
      return

    "no 'other' cookies": (t) ->
      assert.ok not t.cookies.some((c) ->
        (/^other/).test c.name
      )
      return
).addBatch("remove cookies":
  topic: ->
    jar = new CookieJar()
    cookie = Cookie.parse("a=b; Domain=example.com; Path=/")
    cookie2 = Cookie.parse("a=b; Domain=foo.com; Path=/")
    cookie3 = Cookie.parse("foo=bar; Domain=foo.com; Path=/")
    jar.setCookie cookie, "http://example.com/index.html", ->

    jar.setCookie cookie2, "http://foo.com/index.html", ->

    jar.setCookie cookie3, "http://foo.com/index.html", ->

    jar

  "all from matching domain": (jar) ->
    jar.store.removeCookies "example.com", null, (err) ->
      assert not err?
      jar.store.findCookies "example.com", null, (err, cookies) ->
        assert not err?
        assert cookies?
        assert cookies.length is 0, "cookie was not removed"
        return

      jar.store.findCookies "foo.com", null, (err, cookies) ->
        assert not err?
        assert cookies?
        assert cookies.length is 2, "cookies should not have been removed"
        return

      return

    return

  "from cookie store matching domain and key": (jar) ->
    jar.store.removeCookie "foo.com", "/", "foo", (err) ->
      assert not err?
      jar.store.findCookies "foo.com", null, (err, cookies) ->
        assert not err?
        assert cookies?
        assert cookies.length is 1, "cookie was not removed correctly"
        assert cookies[0].key is "a", "wrong cookie was removed"
        return

      return

    return
).addBatch("Synchronous CookieJar":
  setCookieSync:
    topic: ->
      jar = new CookieJar()
      cookie = Cookie.parse("a=b; Domain=example.com; Path=/")
      cookie = jar.setCookieSync(cookie, "http://example.com/index.html")
      cookie

    "returns a copy of the cookie": (cookie) ->
      assert.instanceOf cookie, Cookie
      return

  "setCookieSync strict parse error":
    topic: ->
      jar = new CookieJar()
      opts = strict: true
      try
        jar.setCookieSync "farbe=weiß", "http://example.com/index.html", opts
        return false
      catch e
        return e
      return

    "throws the error": (err) ->
      assert.instanceOf err, Error
      assert.equal err.message, "Cookie failed to parse"
      return

  getCookiesSync:
    topic: ->
      jar = new CookieJar()
      url = "http://example.com/index.html"
      jar.setCookieSync "a=b; Domain=example.com; Path=/", url
      jar.setCookieSync "c=d; Domain=example.com; Path=/", url
      jar.getCookiesSync url

    "returns the cookie array": (err, cookies) ->
      assert.ok not err
      assert.ok Array.isArray(cookies)
      assert.lengthOf cookies, 2
      cookies.forEach (cookie) ->
        assert.instanceOf cookie, Cookie
        return

      return

  getCookieStringSync:
    topic: ->
      jar = new CookieJar()
      url = "http://example.com/index.html"
      jar.setCookieSync "a=b; Domain=example.com; Path=/", url
      jar.setCookieSync "c=d; Domain=example.com; Path=/", url
      jar.getCookieStringSync url

    "returns the cookie header string": (err, str) ->
      assert.ok not err
      assert.typeOf str, "string"
      return

  getSetCookieStringsSync:
    topic: ->
      jar = new CookieJar()
      url = "http://example.com/index.html"
      jar.setCookieSync "a=b; Domain=example.com; Path=/", url
      jar.setCookieSync "c=d; Domain=example.com; Path=/", url
      jar.getSetCookieStringsSync url

    "returns the cookie header string": (err, headers) ->
      assert.ok not err
      assert.ok Array.isArray(headers)
      assert.lengthOf headers, 2
      headers.forEach (header) ->
        assert.typeOf header, "string"
        return

      return
).addBatch("Synchronous API on async CookieJar":
  topic: ->
    new tough.Store()

  setCookieSync:
    topic: (store) ->
      jar = new CookieJar(store)
      try
        jar.setCookieSync "a=b", "http://example.com/index.html"
        return false
      catch e
        return e
      return

    fails: (err) ->
      assert.instanceOf err, Error
      assert.equal err.message, "CookieJar store is not synchronous; use async API instead."
      return

  getCookiesSync:
    topic: (store) ->
      jar = new CookieJar(store)
      try
        jar.getCookiesSync "http://example.com/index.html"
        return false
      catch e
        return e
      return

    fails: (err) ->
      assert.instanceOf err, Error
      assert.equal err.message, "CookieJar store is not synchronous; use async API instead."
      return

  getCookieStringSync:
    topic: (store) ->
      jar = new CookieJar(store)
      try
        jar.getCookieStringSync "http://example.com/index.html"
        return false
      catch e
        return e
      return

    fails: (err) ->
      assert.instanceOf err, Error
      assert.equal err.message, "CookieJar store is not synchronous; use async API instead."
      return

  getSetCookieStringsSync:
    topic: (store) ->
      jar = new CookieJar(store)
      try
        jar.getSetCookieStringsSync "http://example.com/index.html"
        return false
      catch e
        return e
      return

    fails: (err) ->
      assert.instanceOf err, Error
      assert.equal err.message, "CookieJar store is not synchronous; use async API instead."
      return
).export module
