#
# * Copyright GoInstant, Inc. and other contributors. All rights reserved.
# * Permission is hereby granted, free of charge, to any person obtaining a copy
# * of this software and associated documentation files (the "Software"), to
# * deal in the Software without restriction, including without limitation the
# * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# * sell copies of the Software, and to permit persons to whom the Software is
# * furnished to do so, subject to the following conditions:
# *
# * The above copyright notice and this permission notice shall be included in
# * all copies or substantial portions of the Software.
# *
# * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# * IN THE SOFTWARE.
# 

# From RFC2616 S2.2:

# From RFC6265 S4.1.1
# note that it excludes \x3B ";"

# The name/key cannot be empty but the value can (S5.2):

# RFC6265 S4.1.1 defines extension-av as 'any CHAR except CTLs or ";"'
# Note ';' is \x3B

# Used for checking whether or not there is a trailing semi-colon

# RFC6265 S5.1.1.5:
# * [fail if] the day-of-month-value is less than 1 or greater than 31
# 

# RFC6265 S5.1.1.5:
# * [fail if]
# * *  the hour-value is greater than 23,
# * *  the minute-value is greater than 59, or
# * *  the second-value is greater than 59.
# 
# 2 to 4 digits
# 31-bit max
# 31-bit min

# RFC6265 S5.1.1 date parser:
parseDate = (str, strict) ->
  return  unless str
  found_time = undefined
  found_dom = undefined
  found_month = undefined
  found_year = undefined
  
  # RFC6265 S5.1.1:
  #   * 2. Process each date-token sequentially in the order the date-tokens
  #   * appear in the cookie-date
  #   
  tokens = str.split(DATE_DELIM)
  return  unless tokens
  date = new Date()
  date.setMilliseconds 0
  i = 0

  while i < tokens.length
    token = tokens[i].trim()
    continue  unless token.length
    result = undefined
    
    # 2.1. If the found-time flag is not set and the token matches the time
    #     * production, set the found-time flag and set the hour- value,
    #     * minute-value, and second-value to the numbers denoted by the digits in
    #     * the date-token, respectively.  Skip the remaining sub-steps and continue
    #     * to the next date-token.
    #     
    unless found_time
      result = ((if strict then STRICT_TIME else TIME)).exec(token)
      if result
        found_time = true
        date.setUTCHours result[1]
        date.setUTCMinutes result[2]
        date.setUTCSeconds result[3]
        continue
    
    # 2.2. If the found-day-of-month flag is not set and the date-token matches
    #     * the day-of-month production, set the found-day-of- month flag and set
    #     * the day-of-month-value to the number denoted by the date-token.  Skip
    #     * the remaining sub-steps and continue to the next date-token.
    #     
    unless found_dom
      result = DAY_OF_MONTH.exec(token)
      if result
        found_dom = true
        date.setUTCDate result[1]
        continue
    
    # 2.3. If the found-month flag is not set and the date-token matches the
    #     * month production, set the found-month flag and set the month-value to
    #     * the month denoted by the date-token.  Skip the remaining sub-steps and
    #     * continue to the next date-token.
    #     
    unless found_month
      result = MONTH.exec(token)
      if result
        found_month = true
        date.setUTCMonth MONTH_TO_NUM[result[1].toLowerCase()]
        continue
    
    # 2.4. If the found-year flag is not set and the date-token matches the year
    #     * production, set the found-year flag and set the year-value to the number
    #     * denoted by the date-token.  Skip the remaining sub-steps and continue to
    #     * the next date-token.
    #     
    unless found_year
      result = YEAR.exec(token)
      if result
        year = result[0]
        
        # From S5.1.1:
        #         * 3.  If the year-value is greater than or equal to 70 and less
        #         * than or equal to 99, increment the year-value by 1900.
        #         * 4.  If the year-value is greater than or equal to 0 and less
        #         * than or equal to 69, increment the year-value by 2000.
        #         
        if 70 <= year and year <= 99
          year += 1900
        else year += 2000  if 0 <= year and year <= 69
        return  if year < 1601 # 5. ... the year-value is less than 1601
        found_year = true
        date.setUTCFullYear year
        continue
    i++
  return  unless found_time and found_dom and found_month and found_year # 5. ... at least one of the found-day-of-month, found-month, found-
  # year, or found-time flags is not set,
  date
formatDate = (date) ->
  d = date.getUTCDate()
  d = (if d >= 10 then d else "0" + d)
  h = date.getUTCHours()
  h = (if h >= 10 then h else "0" + h)
  m = date.getUTCMinutes()
  m = (if m >= 10 then m else "0" + m)
  s = date.getUTCSeconds()
  s = (if s >= 10 then s else "0" + s)
  NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT"

# S5.1.2 Canonicalized Host Names
canonicalDomain = (str) ->
  return null  unless str?
  str = str.trim().replace(/^\./, "") # S4.1.2.3 & S5.2.3: ignore leading .
  
  # convert to IDN if any non-ASCII characters
  str = punycode.toASCII(str)  if punycode and /[^\u0001-\u007f]/.test(str)
  str.toLowerCase()

# S5.1.3 Domain Matching
domainMatch = (str, domStr, canonicalize) ->
  return null  if not str? or not domStr?
  if canonicalize isnt false
    str = canonicalDomain(str)
    domStr = canonicalDomain(domStr)
  
  #
  #   * "The domain string and the string are identical. (Note that both the
  #   * domain string and the string will have been canonicalized to lower case at
  #   * this point)"
  #   
  return true  if str is domStr
  
  # "All of the following [three] conditions hold:" (order adjusted from the RFC) 
  
  # "* The string is a host name (i.e., not an IP address)." 
  return false  if net.isIP(str)
  
  # "* The domain string is a suffix of the string" 
  idx = str.indexOf(domStr)
  return false  if idx <= 0 # it's a non-match (-1) or prefix (0)
  
  # e.g "a.b.c".indexOf("b.c") === 2
  # 5 === 3+2
  # it's not a suffix
  return false  if str.length isnt domStr.length + idx
  
  # "* The last character of the string that is not included in the domain
  #  * string is a %x2E (".") character." 
  return false  if str.substr(idx - 1, 1) isnt "."
  true

# RFC6265 S5.1.4 Paths and Path-Match

#
# * "The user agent MUST use an algorithm equivalent to the following algorithm
# * to compute the default-path of a cookie:"
# *
# * Assumption: the path (and not query part or absolute uri) is passed in.
# 
defaultPath = (path) ->
  
  # "2. If the uri-path is empty or if the first character of the uri-path is not
  # a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
  return "/"  if not path or path.substr(0, 1) isnt "/"
  
  # "3. If the uri-path contains no more than one %x2F ("/") character, output
  # %x2F ("/") and skip the remaining step."
  return path  if path is "/"
  rightSlash = path.lastIndexOf("/")
  return "/"  if rightSlash is 0
  
  # "4. Output the characters of the uri-path from the first character up to,
  # but not including, the right-most %x2F ("/")."
  path.slice 0, rightSlash

#
# * "A request-path path-matches a given cookie-path if at least one of the
# * following conditions holds:"
# 
pathMatch = (reqPath, cookiePath) ->
  
  # "o  The cookie-path and the request-path are identical."
  return true  if cookiePath is reqPath
  idx = reqPath.indexOf(cookiePath)
  if idx is 0
    
    # "o  The cookie-path is a prefix of the request-path, and the last
    # character of the cookie-path is %x2F ("/")."
    return true  if cookiePath.substr(-1) is "/"
    
    # " o  The cookie-path is a prefix of the request-path, and the first
    # character of the request-path that is not included in the cookie- path
    # is a %x2F ("/") character."
    return true  if reqPath.substr(cookiePath.length, 1) is "/"
  false
parse = (str, strict) ->
  str = str.trim()
  
  # S4.1.1 Trailing semi-colons are not part of the specification.
  # If we are not in strict mode we remove the trailing semi-colons.
  semiColonCheck = TRAILING_SEMICOLON.exec(str)
  if semiColonCheck
    return  if strict
    str = str.slice(0, semiColonCheck.index)
  
  # We use a regex to parse the "name-value-pair" part of S5.2
  firstSemi = str.indexOf(";") # S5.2 step 1
  pairRx = (if strict then COOKIE_PAIR_STRICT else COOKIE_PAIR)
  result = pairRx.exec((if firstSemi is -1 then str else str.substr(0, firstSemi)))
  
  # Rx satisfies the "the name string is empty" and "lacks a %x3D ("=")"
  # constraints as well as trimming any whitespace.
  return  unless result
  c = new Cookie()
  c.key = result[1] # the regexp should trim() already
  c.value = result[3] # [2] is quotes or empty-string
  return c  if firstSemi is -1
  
  # S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  # (including the %x3B (";") in question)." plus later on in the same section
  # "discard the first ";" and trim".
  unparsed = str.slice(firstSemi).replace(/^\s*;\s*/, "").trim()
  
  # "If the unparsed-attributes string is empty, skip the rest of these
  # steps."
  return c  if unparsed.length is 0
  
  #
  #   * S5.2 says that when looping over the items "[p]rocess the attribute-name
  #   * and attribute-value according to the requirements in the following
  #   * subsections" for every item.  Plus, for many of the individual attributes
  #   * in S5.3 it says to use the "attribute-value of the last attribute in the
  #   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
  #   * the previous value.
  #   
  cookie_avs = unparsed.split(/\s*;\s*/)
  while cookie_avs.length
    av = cookie_avs.shift()
    return  if strict and not EXTENSION_AV.test(av)
    av_sep = av.indexOf("=")
    av_key = undefined
    av_value = undefined
    if av_sep is -1
      av_key = av
      av_value = null
    else
      av_key = av.substr(0, av_sep)
      av_value = av.substr(av_sep + 1)
    av_key = av_key.trim().toLowerCase()
    av_value = av_value.trim()  if av_value
    switch av_key
      when "expires" # S5.2.1
        unless av_value
          if strict
            return
          else
            break
        exp = parseDate(av_value, strict)
        
        # "If the attribute-value failed to parse as a cookie date, ignore the
        # cookie-av."
        unless exp?
          if strict
            return
          else
            break
        c.expires = exp
      
      # over and underflow not realistically a concern: V8's getTime() seems to
      # store something larger than a 32-bit time_t (even with 32-bit node)
      when "max-age" # S5.2.2
        unless av_value
          if strict
            return
          else
            break
        
        # "If the first character of the attribute-value is not a DIGIT or a "-"
        # character ...[or]... If the remainder of attribute-value contains a
        # non-DIGIT character, ignore the cookie-av."
        unless /^-?[0-9]+$/.test(av_value)
          if strict
            return
          else
            break
        delta = parseInt(av_value, 10)
        return  if strict and delta <= 0 # S4.1.1
        
        # "If delta-seconds is less than or equal to zero (0), let expiry-time
        # be the earliest representable date and time."
        c.setMaxAge delta
      when "domain" # S5.2.3
        # "If the attribute-value is empty, the behavior is undefined.  However,
        # the user agent SHOULD ignore the cookie-av entirely."
        unless av_value
          if strict
            return
          else
            break
        
        # S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
        # (".") character."
        domain = av_value.trim().replace(/^\./, "")
        unless domain # see "is empty" above
          if strict
            return
          else
            break
        # "Convert the cookie-domain to lower case."
        c.domain = domain.toLowerCase()
      when "path" # S5.2.4
        #
        #       * "If the attribute-value is empty or if the first character of the
        #       * attribute-value is not %x2F ("/"):
        #       *   Let cookie-path be the default-path.
        #       * Otherwise:
        #       *   Let cookie-path be the attribute-value."
        #       *
        #       * We'll represent the default-path as null since it depends on the
        #       * context of the parsing.
        #       
        if not av_value or av_value.substr(0, 1) isnt "/"
          if strict
            return
          else
            break
        c.path = av_value
      when "secure" # S5.2.5
        #
        #       * "If the attribute-name case-insensitively matches the string "Secure",
        #       * the user agent MUST append an attribute to the cookie-attribute-list
        #       * with an attribute-name of Secure and an empty attribute-value."
        #       
        return  if strict  if av_value?
        c.secure = true
      when "httponly" # S5.2.6 -- effectively the same as 'secure'
        return  if strict  if av_value?
        c.httpOnly = true
      else
        c.extensions = c.extensions or []
        c.extensions.push av
  
  # ensure a default date for sorting:
  c.creation = new Date()
  c
fromJSON = (str) ->
  return null  unless str
  obj = undefined
  try
    obj = JSON.parse(str)
  catch e
    return null
  c = new Cookie()
  i = 0

  while i < numCookieProperties
    prop = cookieProperties[i]
    continue  unless obj[prop]?
    if prop is "expires" or prop is "creation" or prop is "lastAccessed"
      c[prop] = (if obj[prop] is "Infinity" then "Infinity" else new Date(obj[prop]))
    else
      c[prop] = obj[prop]
    i++
  
  # ensure a default date for sorting:
  c.creation = c.creation or new Date()
  c

# Section 5.4 part 2:
# * "*  Cookies with longer paths are listed before cookies with
# *     shorter paths.
# *
# *  *  Among cookies that have equal-length path fields, cookies with
# *     earlier creation-times are listed before cookies with later
# *     creation-times."
# 
cookieCompare = (a, b) ->
  
  # descending for length: b CMP a
  deltaLen = ((if b.path then b.path.length else 0)) - ((if a.path then a.path.length else 0))
  return deltaLen  if deltaLen isnt 0
  
  # ascending for time: a CMP b
  ((if a.creation then a.creation.getTime() else MAX_TIME)) - ((if b.creation then b.creation.getTime() else MAX_TIME))

# Gives the permutation of all possible domainMatch()es of a given domain. The
# array is in shortest-to-longest order.  Handy for indexing.
permuteDomain = (domain) ->
  pubSuf = pubsuffix.getPublicSuffix(domain)
  return null  unless pubSuf
  return [domain]  if pubSuf is domain
  prefix = domain.slice(0, -(pubSuf.length + 1)) # ".example.com"
  parts = prefix.split(".").reverse()
  cur = pubSuf
  permutations = [cur]
  while parts.length
    cur = parts.shift() + "." + cur
    permutations.push cur
  permutations

# Gives the permutation of all possible pathMatch()es of a given path. The
# array is in longest-to-shortest order.  Handy for indexing.
permutePath = (path) ->
  return ["/"]  if path is "/"
  path = path.substr(0, path.length - 1)  if path.lastIndexOf("/") is path.length - 1
  permutations = [path]
  while path.length > 1
    lindex = path.lastIndexOf("/")
    break  if lindex is 0
    path = path.substr(0, lindex)
    permutations.push path
  permutations.push "/"
  permutations
Cookie = (opts) ->
  return  if typeof opts isnt "object"
  Object.keys(opts).forEach ((key) ->
    this[key] = opts[key] or Cookie::[key]  if Cookie::hasOwnProperty(key)
    return
  ).bind(this)
  return

# the order in which the RFC has them:
# coerces to literal Infinity
# takes precedence over expires for TTL

# set by the CookieJar:
# boolean when set
# boolean when set
# Date when set; defaulted by Cookie.parse
# Date when set
# "Max-Age=" non-zero-digit *DIGIT
# S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
# it's a public suffix
# so JSON.stringify() works

# gives Cookie header format

# gives Set-Cookie header format

# TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
# elsewhere)
# S5.3 says to give the "latest representable date" for which we use Infinity
# For "expired" we use 0

# RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
#   * attribute, the Max-Age attribute has precedence and controls the
#   * expiration date of the cookie.
#   * (Concurs with S5.3 step 3)
#   

# expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
# elsewhere)

# expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
# elsewhere), except it returns a Date

# This replaces the "persistent-flag" parts of S5.3 step 3

# Mostly S5.1.2 and S5.2.3:
CookieJar = (store, rejectPublicSuffixes) ->
  @rejectPublicSuffixes = rejectPublicSuffixes  if rejectPublicSuffixes?
  unless store
    memstore = memstore or require("./memstore")
    store = new memstore.MemoryCookieStore()
  @store = store
  return

# S5.3 step 1

# S5.3 step 2
# will assign later to save effort in the face of errors

# S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

# S5.3 step 4: NOOP; domain is null by default

# S5.3 step 5: public suffixes
# e.g. "com"

# S5.3 step 6:
# don't reset if already set

# S5.3 step 7: "Otherwise, set the cookie's path to the default-path of the
# request-uri"

# S5.3 step 8: NOOP; secure attribute
# S5.3 step 9: NOOP; httpOnly attribute

# S5.3 step 10

# S5.3 step 11 - "If the cookie store contains a cookie with the same name,
# domain, and path as the newly created cookie:"
# step 11.2
# step 11.3

# Step 11.4 (delete cookie) is implied by just setting the new one:
# step 12
# step 12

# RFC6365 S5.4

# "Either:
#   The cookie's host-only-flag is true and the canonicalized
#   request-host is identical to the cookie's domain.
# Or:
#   The cookie's host-only-flag is false and the canonicalized
#   request-host domain-matches the cookie's domain."

# "The request-uri's path path-matches the cookie's path."

# "If the cookie's secure-only-flag is true, then the request-uri's
# scheme must denote a "secure" protocol"

# "If the cookie's http-only-flag is true, then exclude the cookie if the
# cookie-string is being generated for a "non-HTTP" API"

# deferred from S5.3
# non-RFC: allow retention of expired cookies by choice
# result ignored

# sorting of S5.4 part 2

# S5.4 part 3

# TODO persist lastAccessed
#..., cb
#..., cb

# Use a closure to provide a true imperative API for synchronous stores.
syncWrap = (method) ->
  ->
    throw new Error("CookieJar store is not synchronous; use async API instead.")  unless @store.synchronous
    args = Array::slice.call(arguments)
    syncErr = undefined
    syncResult = undefined
    args.push syncCb = (err, result) ->
      syncErr = err
      syncResult = result
      return

    this[method].apply this, args
    throw syncErr  if syncErr
    syncResult
"use strict"
net = require("net")
urlParse = require("url").parse
pubsuffix = require("./pubsuffix")
Store = require("./store").Store
punycode = undefined
try
  punycode = require("punycode")
catch e
  console.warn "cookie: can't load punycode; won't use punycode for domain normalization"
DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/
TOKEN = /[\x21\x23-\x26\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/
COOKIE_OCTET = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/
COOKIE_OCTETS = new RegExp("^" + COOKIE_OCTET.source + "$")
COOKIE_PAIR_STRICT = new RegExp("^(" + TOKEN.source + "+)=(\"?)(" + COOKIE_OCTET.source + "*)\\2$")
COOKIE_PAIR = /^([^=\s]+)\s*=\s*("?)\s*(.*)\s*\2\s*$/
NON_CTL_SEMICOLON = /[\x20-\x3A\x3C-\x7E]+/
EXTENSION_AV = NON_CTL_SEMICOLON
PATH_VALUE = NON_CTL_SEMICOLON
TRAILING_SEMICOLON = /;+$/
DAY_OF_MONTH = /^(0?[1-9]|[12][0-9]|3[01])$/
TIME = /(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])/
STRICT_TIME = /^(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i
MONTH_TO_NUM =
  jan: 0
  feb: 1
  mar: 2
  apr: 3
  may: 4
  jun: 5
  jul: 6
  aug: 7
  sep: 8
  oct: 9
  nov: 10
  dec: 11

NUM_TO_MONTH = [
  "Jan"
  "Feb"
  "Mar"
  "Apr"
  "May"
  "Jun"
  "Jul"
  "Aug"
  "Sep"
  "Oct"
  "Nov"
  "Dec"
]
NUM_TO_DAY = [
  "Sun"
  "Mon"
  "Tue"
  "Wed"
  "Thu"
  "Fri"
  "Sat"
]
YEAR = /^([1-9][0-9]{1,3})$/
MAX_TIME = 2147483647000
MIN_TIME = 0
Cookie.parse = parse
Cookie.fromJSON = fromJSON
Cookie::key = ""
Cookie::value = ""
Cookie::expires = "Infinity"
Cookie::maxAge = null
Cookie::domain = null
Cookie::path = null
Cookie::secure = false
Cookie::httpOnly = false
Cookie::extensions = null
Cookie::hostOnly = null
Cookie::pathIsDefault = null
Cookie::creation = null
Cookie::lastAccessed = null
cookieProperties = Object.freeze(Object.keys(Cookie::).map((p) ->
  return  if p instanceof Function
  p
))
numCookieProperties = cookieProperties.length
Cookie::inspect = inspect = ->
  now = Date.now()
  "Cookie=\"" + @toString() + "; hostOnly=" + ((if @hostOnly? then @hostOnly else "?")) + "; aAge=" + ((if @lastAccessed then (now - @lastAccessed.getTime()) + "ms" else "?")) + "; cAge=" + ((if @creation then (now - @creation.getTime()) + "ms" else "?")) + "\""

Cookie::validate = validate = ->
  return false  unless COOKIE_OCTETS.test(@value)
  return false  if @expires isnt Infinity and (@expires not instanceof Date) and not parseDate(@expires, true)
  return false  if @maxAge? and @maxAge <= 0
  return false  if @path? and not PATH_VALUE.test(@path)
  cdomain = @cdomain()
  if cdomain
    return false  if cdomain.match(/\.$/)
    suffix = pubsuffix.getPublicSuffix(cdomain)
    return false  unless suffix?
  true

Cookie::setExpires = setExpires = (exp) ->
  if exp instanceof Date
    @expires = exp
  else
    @expires = parseDate(exp) or "Infinity"
  return

Cookie::setMaxAge = setMaxAge = (age) ->
  if age is Infinity or age is -Infinity
    @maxAge = age.toString()
  else
    @maxAge = age
  return

Cookie::cookieString = cookieString = ->
  val = @value
  val = ""  unless val?
  @key + "=" + val

Cookie::toString = toString = ->
  str = @cookieString()
  unless @expires is Infinity
    if @expires instanceof Date
      str += "; Expires=" + formatDate(@expires)
    else
      str += "; Expires=" + @expires
  str += "; Max-Age=" + @maxAge  if @maxAge? and @maxAge isnt Infinity
  str += "; Domain=" + @domain  if @domain and not @hostOnly
  str += "; Path=" + @path  if @path
  str += "; Secure"  if @secure
  str += "; HttpOnly"  if @httpOnly
  if @extensions
    @extensions.forEach (ext) ->
      str += "; " + ext
      return

  str

Cookie::TTL = TTL = (now) ->
  return (if @maxAge <= 0 then 0 else @maxAge * 1000)  if @maxAge?
  expires = @expires
  unless expires is Infinity
    expires = parseDate(expires) or Infinity  unless expires instanceof Date
    return Infinity  if expires is Infinity
    return expires.getTime() - (now or Date.now())
  Infinity

Cookie::expiryTime = expiryTime = (now) ->
  if @maxAge?
    relativeTo = @creation or now or new Date()
    age = (if (@maxAge <= 0) then -Infinity else @maxAge * 1000)
    return relativeTo.getTime() + age
  return Infinity  if @expires is Infinity
  @expires.getTime()

Cookie::expiryDate = expiryDate = (now) ->
  millisec = @expiryTime(now)
  if millisec is Infinity
    new Date(MAX_TIME)
  else if millisec is -Infinity
    new Date(MIN_TIME)
  else
    new Date(millisec)

Cookie::isPersistent = isPersistent = ->
  @maxAge? or @expires isnt Infinity

Cookie::cdomain = Cookie::canonicalizedDomain = canonicalizedDomain = ->
  return null  unless @domain?
  canonicalDomain @domain

memstore = undefined
CookieJar::store = null
CookieJar::rejectPublicSuffixes = true
CAN_BE_SYNC = []
CAN_BE_SYNC.push "setCookie"
CookieJar::setCookie = (cookie, url, options, cb) ->
  withCookie = (err, oldCookie) ->
    return cb(err)  if err
    next = (err) ->
      if err
        cb err
      else
        cb null, cookie
      return

    if oldCookie
      if options.http is false and oldCookie.httpOnly
        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API")
        return cb((if options.ignoreError then null else err))
      cookie.creation = oldCookie.creation
      cookie.lastAccessed = now
      store.updateCookie oldCookie, cookie, next
    else
      cookie.creation = cookie.lastAccessed = now
      store.putCookie cookie, next
    return
  err = undefined
  context = (if (url instanceof Object) then url else urlParse(url))
  if options instanceof Function
    cb = options
    options = {}
  host = canonicalDomain(context.hostname)
  cookie = Cookie.parse(cookie, options.strict is true)  unless cookie instanceof Cookie
  unless cookie
    err = new Error("Cookie failed to parse")
    return cb((if options.ignoreError then null else err))
  now = options.now or new Date()
  if @rejectPublicSuffixes and cookie.domain
    suffix = pubsuffix.getPublicSuffix(cookie.cdomain())
    unless suffix?
      err = new Error("Cookie has domain set to a public suffix")
      return cb((if options.ignoreError then null else err))
  if cookie.domain
    unless domainMatch(host, cookie.cdomain(), false)
      err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host)
      return cb((if options.ignoreError then null else err))
    cookie.hostOnly = false  unless cookie.hostOnly?
  else
    cookie.hostOnly = true
    cookie.domain = host
  unless cookie.path
    cookie.path = defaultPath(context.pathname)
    cookie.pathIsDefault = true
  else
    cookie.path = cookie.path.slice(0, -1)  if cookie.path.length > 1 and cookie.path.substr(-1) is "/"
  if options.http is false and cookie.httpOnly
    err = new Error("Cookie is HttpOnly and this isn't an HTTP API")
    return cb((if options.ignoreError then null else err))
  store = @store
  unless store.updateCookie
    store.updateCookie = (oldCookie, newCookie, cb) ->
      @putCookie newCookie, cb
      return
  store.findCookie cookie.domain, cookie.path, cookie.key, withCookie
  return

CAN_BE_SYNC.push "getCookies"
CookieJar::getCookies = (url, options, cb) ->
  matchingCookie = (c) ->
    if c.hostOnly
      return false  unless c.domain is host
    else
      return false  unless domainMatch(host, c.domain, false)
    return false  if not allPaths and not pathMatch(path, c.path)
    return false  if c.secure and not secure
    return false  if c.httpOnly and not http
    if expireCheck and c.expiryTime() <= now
      store.removeCookie c.domain, c.path, c.key, ->

      return false
    true
  context = (if (url instanceof Object) then url else urlParse(url))
  if options instanceof Function
    cb = options
    options = {}
  host = canonicalDomain(context.hostname)
  path = context.pathname or "/"
  secure = options.secure
  secure = true  if not secure? and context.protocol and (context.protocol is "https:" or context.protocol is "wss:")
  http = options.http
  http = true  unless http?
  now = options.now or Date.now()
  expireCheck = options.expire isnt false
  allPaths = !!options.allPaths
  store = @store
  store.findCookies host, (if allPaths then null else path), (err, cookies) ->
    return cb(err)  if err
    cookies = cookies.filter(matchingCookie)
    cookies = cookies.sort(cookieCompare)  if options.sort isnt false
    now = new Date()
    cookies.forEach (c) ->
      c.lastAccessed = now
      return

    cb null, cookies
    return

  return

CAN_BE_SYNC.push "getCookieString"
CookieJar::getCookieString = ->
  args = Array::slice.call(arguments, 0)
  cb = args.pop()
  next = (err, cookies) ->
    if err
      cb err
    else
      cb null, cookies.map((c) ->
        c.cookieString()
      ).join("; ")
    return

  args.push next
  @getCookies.apply this, args
  return

CAN_BE_SYNC.push "getSetCookieStrings"
CookieJar::getSetCookieStrings = ->
  args = Array::slice.call(arguments, 0)
  cb = args.pop()
  next = (err, cookies) ->
    if err
      cb err
    else
      cb null, cookies.map((c) ->
        c.toString()
      )
    return

  args.push next
  @getCookies.apply this, args
  return


# wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach (method) ->
  CookieJar::[method + "Sync"] = syncWrap(method)
  return

module.exports =
  CookieJar: CookieJar
  Cookie: Cookie
  Store: Store
  parseDate: parseDate
  formatDate: formatDate
  parse: parse
  fromJSON: fromJSON
  domainMatch: domainMatch
  defaultPath: defaultPath
  pathMatch: pathMatch
  getPublicSuffix: pubsuffix.getPublicSuffix
  cookieCompare: cookieCompare
  permuteDomain: permuteDomain
  permutePath: permutePath
  canonicalDomain: canonicalDomain
