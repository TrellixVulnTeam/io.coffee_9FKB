MemoryCookieStore = ->
  Store.call this
  @idx = {}
  return
"use strict"
tough = require("./cookie")
Store = require("./store").Store
permuteDomain = tough.permuteDomain
permutePath = tough.permutePath
util = require("util")
util.inherits MemoryCookieStore, Store
exports.MemoryCookieStore = MemoryCookieStore
MemoryCookieStore::idx = null
MemoryCookieStore::synchronous = true

# force a default depth:
MemoryCookieStore::inspect = ->
  "{ idx: " + util.inspect(@idx, false, 2) + " }"

MemoryCookieStore::findCookie = (domain, path, key, cb) ->
  return cb(null, `undefined`)  unless @idx[domain]
  return cb(null, `undefined`)  unless @idx[domain][path]
  cb null, @idx[domain][path][key] or null

MemoryCookieStore::findCookies = (domain, path, cb) ->
  results = []
  return cb(null, [])  unless domain
  pathMatcher = undefined
  unless path
    
    # null or '/' means "all paths"
    pathMatcher = matchAll = (domainIndex) ->
      for curPath of domainIndex
        pathIndex = domainIndex[curPath]
        for key of pathIndex
          results.push pathIndex[key]
      return
  else if path is "/"
    pathMatcher = matchSlash = (domainIndex) ->
      pathIndex = domainIndex["/"]
      return  unless pathIndex
      for key of pathIndex
        results.push pathIndex[key]
      return
  else
    paths = permutePath(path) or [path]
    pathMatcher = matchRFC = (domainIndex) ->
      paths.forEach (curPath) ->
        pathIndex = domainIndex[curPath]
        return  unless pathIndex
        for key of pathIndex
          results.push pathIndex[key]
        return

      return
  domains = permuteDomain(domain) or [domain]
  idx = @idx
  domains.forEach (curDomain) ->
    domainIndex = idx[curDomain]
    return  unless domainIndex
    pathMatcher domainIndex
    return

  cb null, results
  return

MemoryCookieStore::putCookie = (cookie, cb) ->
  @idx[cookie.domain] = {}  unless @idx[cookie.domain]
  @idx[cookie.domain][cookie.path] = {}  unless @idx[cookie.domain][cookie.path]
  @idx[cookie.domain][cookie.path][cookie.key] = cookie
  cb null
  return

MemoryCookieStore::updateCookie = updateCookie = (oldCookie, newCookie, cb) ->
  
  # updateCookie() may avoid updating cookies that are identical.  For example,
  # lastAccessed may not be important to some stores and an equality
  # comparison could exclude that field.
  @putCookie newCookie, cb
  return

MemoryCookieStore::removeCookie = removeCookie = (domain, path, key, cb) ->
  delete @idx[domain][path][key]  if @idx[domain] and @idx[domain][path] and @idx[domain][path][key]
  cb null
  return

MemoryCookieStore::removeCookies = removeCookies = (domain, path, cb) ->
  if @idx[domain]
    if path
      delete @idx[domain][path]
    else
      delete @idx[domain]
  cb null
