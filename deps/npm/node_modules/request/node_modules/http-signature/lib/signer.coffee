# Copyright 2012 Joyent, Inc.  All rights reserved.

#/--- Globals

#/--- Specific Errors
MissingHeaderError = (message) ->
  @name = "MissingHeaderError"
  @message = message
  @stack = (new Error()).stack
  return
InvalidAlgorithmError = (message) ->
  @name = "InvalidAlgorithmError"
  @message = message
  @stack = (new Error()).stack
  return

#/--- Internal Functions
_pad = (val) ->
  val = "0" + val  if parseInt(val, 10) < 10
  val
_rfc1123 = ->
  date = new Date()
  months = [
    "Jan"
    "Feb"
    "Mar"
    "Apr"
    "May"
    "Jun"
    "Jul"
    "Aug"
    "Sep"
    "Oct"
    "Nov"
    "Dec"
  ]
  days = [
    "Sun"
    "Mon"
    "Tue"
    "Wed"
    "Thu"
    "Fri"
    "Sat"
  ]
  days[date.getUTCDay()] + ", " + _pad(date.getUTCDate()) + " " + months[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + _pad(date.getUTCHours()) + ":" + _pad(date.getUTCMinutes()) + ":" + _pad(date.getUTCSeconds()) + " GMT"
assert = require("assert-plus")
crypto = require("crypto")
http = require("http")
sprintf = require("util").format
Algorithms =
  "rsa-sha1": true
  "rsa-sha256": true
  "rsa-sha512": true
  "dsa-sha1": true
  "hmac-sha1": true
  "hmac-sha256": true
  "hmac-sha512": true

Authorization = "Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\",signature=\"%s\""
MissingHeaderError:: = new Error()
InvalidAlgorithmError:: = new Error()

#/--- Exported API

###*
Adds an 'Authorization' header to an http.ClientRequest object.

Note that this API will add a Date header if it's not already set. Any
other headers in the options.headers array MUST be present, or this
will throw.

You shouldn't need to check the return type; it's just there if you want
to be pedantic.

@param {Object} request an instance of http.ClientRequest.
@param {Object} options signing parameters object:
- {String} keyId required.
- {String} key required (either a PEM or HMAC key).
- {Array} headers optional; defaults to ['date'].
- {String} algorithm optional; defaults to 'rsa-sha256'.
- {String} httpVersion optional; defaults to '1.1'.
@return {Boolean} true if Authorization (and optionally Date) were added.
@throws {TypeError} on bad parameter types (input).
@throws {InvalidAlgorithmError} if algorithm was bad.
@throws {MissingHeaderError} if a header to be signed was specified but
was not present.
###
module.exports = signRequest: signRequest = (request, options) ->
  assert.object request, "request"
  assert.object options, "options"
  assert.optionalString options.algorithm, "options.algorithm"
  assert.string options.keyId, "options.keyId"
  assert.optionalArrayOfString options.headers, "options.headers"
  assert.optionalString options.httpVersion, "options.httpVersion"
  request.setHeader "Date", _rfc1123()  unless request.getHeader("Date")
  options.headers = ["date"]  unless options.headers
  options.algorithm = "rsa-sha256"  unless options.algorithm
  options.httpVersion = "1.1"  unless options.httpVersion
  options.algorithm = options.algorithm.toLowerCase()
  throw new InvalidAlgorithmError(options.algorithm + " is not supported")  unless Algorithms[options.algorithm]
  i = undefined
  stringToSign = ""
  i = 0
  while i < options.headers.length
    throw new TypeError("options.headers must be an array of Strings")  if typeof (options.headers[i]) isnt "string"
    h = options.headers[i].toLowerCase()
    if h isnt "request-line"
      value = request.getHeader(h)
      throw new MissingHeaderError(h + " was not in the request")  unless value
      stringToSign += h + ": " + value
    else
      value = stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion
    stringToSign += "\n"  if (i + 1) < options.headers.length
    i++
  alg = options.algorithm.match(/(hmac|rsa)-(\w+)/)
  signature = undefined
  if alg[1] is "hmac"
    hmac = crypto.createHmac(alg[2].toUpperCase(), options.key)
    hmac.update stringToSign
    signature = hmac.digest("base64")
  else
    signer = crypto.createSign(options.algorithm.toUpperCase())
    signer.update stringToSign
    signature = signer.sign(options.key, "base64")
  request.setHeader "Authorization", sprintf(Authorization, options.keyId, options.algorithm, options.headers.join(" "), signature)
  true
