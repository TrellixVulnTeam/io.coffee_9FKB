# Copyright 2012 Joyent, Inc.  All rights reserved.

#/--- Helpers
readNext = (buffer, offset) ->
  len = ctype.ruint32(buffer, "big", offset)
  offset += 4
  newOffset = offset + len
  data: buffer.slice(offset, newOffset)
  offset: newOffset
writeInt = (writer, buffer) ->
  writer.writeByte 0x02 # ASN1.Integer
  writer.writeLength buffer.length
  i = 0

  while i < buffer.length
    writer.writeByte buffer[i]
    i++
  writer
rsaToPEM = (key) ->
  buffer = undefined
  der = undefined
  exponent = undefined
  i = undefined
  modulus = undefined
  newKey = ""
  offset = 0
  type = undefined
  tmp = undefined
  try
    buffer = new Buffer(key.split(" ")[1], "base64")
    tmp = readNext(buffer, offset)
    type = tmp.data.toString()
    offset = tmp.offset
    throw new Error("Invalid ssh key type: " + type)  if type isnt "ssh-rsa"
    tmp = readNext(buffer, offset)
    exponent = tmp.data
    offset = tmp.offset
    tmp = readNext(buffer, offset)
    modulus = tmp.data
  catch e
    throw new Error("Invalid ssh key: " + key)
  
  # DER is a subset of BER
  der = new asn1.BerWriter()
  der.startSequence()
  der.startSequence()
  der.writeOID "1.2.840.113549.1.1.1"
  der.writeNull()
  der.endSequence()
  der.startSequence 0x03 # bit string
  der.writeByte 0x00
  
  # Actual key
  der.startSequence()
  writeInt der, modulus
  writeInt der, exponent
  der.endSequence()
  
  # bit string
  der.endSequence()
  der.endSequence()
  tmp = der.buffer.toString("base64")
  i = 0
  while i < tmp.length
    newKey += "\n"  if (i % 64) is 0
    newKey += tmp.charAt(i)
    i++
  newKey += "\n"  unless /\\n$/.test(newKey)
  "-----BEGIN PUBLIC KEY-----" + newKey + "-----END PUBLIC KEY-----\n"
dsaToPEM = (key) ->
  buffer = undefined
  offset = 0
  tmp = undefined
  der = undefined
  newKey = ""
  type = undefined
  p = undefined
  q = undefined
  g = undefined
  y = undefined
  try
    buffer = new Buffer(key.split(" ")[1], "base64")
    tmp = readNext(buffer, offset)
    type = tmp.data.toString()
    offset = tmp.offset
    
    # JSSTYLED 
    throw new Error("Invalid ssh key type: " + type)  unless /^ssh-ds[as].*/.test(type)
    tmp = readNext(buffer, offset)
    p = tmp.data
    offset = tmp.offset
    tmp = readNext(buffer, offset)
    q = tmp.data
    offset = tmp.offset
    tmp = readNext(buffer, offset)
    g = tmp.data
    offset = tmp.offset
    tmp = readNext(buffer, offset)
    y = tmp.data
  catch e
    console.log e.stack
    throw new Error("Invalid ssh key: " + key)
  
  # DER is a subset of BER
  der = new asn1.BerWriter()
  der.startSequence()
  der.startSequence()
  der.writeOID "1.2.840.10040.4.1"
  der.startSequence()
  writeInt der, p
  writeInt der, q
  writeInt der, g
  der.endSequence()
  der.endSequence()
  der.startSequence 0x03 # bit string
  der.writeByte 0x00
  writeInt der, y
  der.endSequence()
  der.endSequence()
  tmp = der.buffer.toString("base64")
  i = 0

  while i < tmp.length
    newKey += "\n"  if (i % 64) is 0
    newKey += tmp.charAt(i)
    i++
  newKey += "\n"  unless /\\n$/.test(newKey)
  "-----BEGIN PUBLIC KEY-----" + newKey + "-----END PUBLIC KEY-----\n"
assert = require("assert-plus")
crypto = require("crypto")
asn1 = require("asn1")
ctype = require("ctype")

#/--- API
module.exports =
  
  ###*
  Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
  
  The intent of this module is to interoperate with OpenSSL only,
  specifically the node crypto module's `verify` method.
  
  @param {String} key an OpenSSH public key.
  @return {String} PEM encoded form of the RSA public key.
  @throws {TypeError} on bad input.
  @throws {Error} on invalid ssh key formatted data.
  ###
  sshKeyToPEM: sshKeyToPEM = (key) ->
    assert.string key, "ssh_key"
    
    # JSSTYLED 
    return rsaToPEM(key)  if /^ssh-rsa.*/.test(key)
    
    # JSSTYLED 
    return dsaToPEM(key)  if /^ssh-ds[as].*/.test(key)
    throw new Error("Only RSA and DSA public keys are allowed")return

  
  ###*
  Generates an OpenSSH fingerprint from an ssh public key.
  
  @param {String} key an OpenSSH public key.
  @return {String} key fingerprint.
  @throws {TypeError} on bad input.
  @throws {Error} if what you passed doesn't look like an ssh public key.
  ###
  fingerprint: fingerprint = (key) ->
    assert.string key, "ssh_key"
    pieces = key.split(" ")
    throw new Error("invalid ssh key")  if not pieces or not pieces.length or pieces.length < 2
    data = new Buffer(pieces[1], "base64")
    hash = crypto.createHash("md5")
    hash.update data
    digest = hash.digest("hex")
    fp = ""
    i = 0

    while i < digest.length
      fp += ":"  if i and i % 2 is 0
      fp += digest[i]
      i++
    fp
