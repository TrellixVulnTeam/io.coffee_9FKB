#
# * rm - Feb 2011
# * ctype.js
# *
# * This module provides a simple abstraction towards reading and writing
# * different types of binary data. It is designed to use ctio.js and provide a
# * richer and more expressive API on top of it.
# *
# * By default we support the following as built in basic types:
# *	int8_t
# *	int16_t
# *	int32_t
# *	uint8_t
# *	uint16_t
# *	uint32_t
# *	uint64_t
# *	float
# *	double
# *	char
# *	char[]
# *
# * Each type is returned as a Number, with the exception of char and char[]
# * which are returned as Node Buffers. A char is considered a uint8_t.
# *
# * Requests to read and write data are specified as an array of JSON objects.
# * This is also the same way that one declares structs. Even if just a single
# * value is requested, it must be done as a struct. The array order determines
# * the order that we try and read values. Each entry has the following format
# * with values marked with a * being optional.
# *
# * { key: { type: /type/, value*: /value/, offset*: /offset/ }
# *
# * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
# * value. Value is defined when we're writing out data, otherwise it's ignored.
# *
# 

#
# * This is the set of basic types that we support.
# *
# *	read		The function to call to read in a value from a buffer
# *
# *	write		The function to call to write a value to a buffer
# *
# 

#
# * The following are wrappers around the CType IO low level API. They encode
# * knowledge about the size and return something in the expected format.
# 
ctReadUint8 = (endian, buffer, offset) ->
  val = mod_ctio.ruint8(buffer, endian, offset)
  value: val
  size: 1
ctReadUint16 = (endian, buffer, offset) ->
  val = mod_ctio.ruint16(buffer, endian, offset)
  value: val
  size: 2
ctReadUint32 = (endian, buffer, offset) ->
  val = mod_ctio.ruint32(buffer, endian, offset)
  value: val
  size: 4
ctReadUint64 = (endian, buffer, offset) ->
  val = mod_ctio.ruint64(buffer, endian, offset)
  value: val
  size: 8
ctReadSint8 = (endian, buffer, offset) ->
  val = mod_ctio.rsint8(buffer, endian, offset)
  value: val
  size: 1
ctReadSint16 = (endian, buffer, offset) ->
  val = mod_ctio.rsint16(buffer, endian, offset)
  value: val
  size: 2
ctReadSint32 = (endian, buffer, offset) ->
  val = mod_ctio.rsint32(buffer, endian, offset)
  value: val
  size: 4
ctReadSint64 = (endian, buffer, offset) ->
  val = mod_ctio.rsint64(buffer, endian, offset)
  value: val
  size: 8
ctReadFloat = (endian, buffer, offset) ->
  val = mod_ctio.rfloat(buffer, endian, offset)
  value: val
  size: 4
ctReadDouble = (endian, buffer, offset) ->
  val = mod_ctio.rdouble(buffer, endian, offset)
  value: val
  size: 8

#
# * Reads a single character into a node buffer
# 
ctReadChar = (endian, buffer, offset) ->
  res = new Buffer(1)
  res[0] = mod_ctio.ruint8(buffer, endian, offset)
  value: res
  size: 1
ctReadCharArray = (length, endian, buffer, offset) ->
  ii = undefined
  res = new Buffer(length)
  ii = 0
  while ii < length
    res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii)
    ii++
  value: res
  size: length
ctWriteUint8 = (value, endian, buffer, offset) ->
  mod_ctio.wuint8 value, endian, buffer, offset
  1
ctWriteUint16 = (value, endian, buffer, offset) ->
  mod_ctio.wuint16 value, endian, buffer, offset
  2
ctWriteUint32 = (value, endian, buffer, offset) ->
  mod_ctio.wuint32 value, endian, buffer, offset
  4
ctWriteUint64 = (value, endian, buffer, offset) ->
  mod_ctio.wuint64 value, endian, buffer, offset
  8
ctWriteSint8 = (value, endian, buffer, offset) ->
  mod_ctio.wsint8 value, endian, buffer, offset
  1
ctWriteSint16 = (value, endian, buffer, offset) ->
  mod_ctio.wsint16 value, endian, buffer, offset
  2
ctWriteSint32 = (value, endian, buffer, offset) ->
  mod_ctio.wsint32 value, endian, buffer, offset
  4
ctWriteSint64 = (value, endian, buffer, offset) ->
  mod_ctio.wsint64 value, endian, buffer, offset
  8
ctWriteFloat = (value, endian, buffer, offset) ->
  mod_ctio.wfloat value, endian, buffer, offset
  4
ctWriteDouble = (value, endian, buffer, offset) ->
  mod_ctio.wdouble value, endian, buffer, offset
  8

#
# * Writes a single character into a node buffer
# 
ctWriteChar = (value, endian, buffer, offset) ->
  throw (new Error("Input must be a buffer"))  unless value instanceof Buffer
  mod_ctio.ruint8 value[0], endian, buffer, offset
  1

#
# * We're going to write 0s into the buffer if the string is shorter than the
# * length of the array.
# 
ctWriteCharArray = (value, length, endian, buffer, offset) ->
  ii = undefined
  throw (new Error("Input must be a buffer"))  unless value instanceof Buffer
  throw (new Error("value length greater than array length"))  if value.length > length
  ii = 0
  while ii < value.length and ii < length
    mod_ctio.wuint8 value[ii], endian, buffer, offset + ii
    ii++
  while ii < length
    mod_ctio.wuint8 0, endian, offset + ii
    ii++
  length

#
# * Each parser has their own set of types. We want to make sure that they each
# * get their own copy as they may need to modify it.
# 
ctGetBasicTypes = ->
  ret = {}
  key = undefined
  for key of deftypes
    ret[key] = deftypes[key]
  ret

#
# * Given a string in the form of type[length] we want to split this into an
# * object that extracts that information. We want to note that we could possibly
# * have nested arrays so this should only check the furthest one. It may also be
# * the case that we have no [] pieces, in which case we just return the current
# * type.
# 
ctParseType = (str) ->
  begInd = undefined
  endInd = undefined
  type = undefined
  len = undefined
  throw (new Error("type must be a Javascript string"))  unless typeof (str) is "string"
  endInd = str.lastIndexOf("]")
  if endInd is -1
    throw (new Error("found invalid type with '[' but " + "no corresponding ']'"))  unless str.lastIndexOf("[") is -1
    return (type: str)
  begInd = str.lastIndexOf("[")
  throw (new Error("found invalid type with ']' but " + "no corresponding '['"))  if begInd is -1
  throw (new Error("malformed type, ']' appears before '['"))  if begInd >= endInd
  type = str.substring(0, begInd)
  len = str.substring(begInd + 1, endInd)
  type: type
  len: len

#
# * Given a request validate that all of the fields for it are valid and make
# * sense. This includes verifying the following notions:
# *  - Each type requested is present in types
# *  - Only allow a name for a field to be specified once
# *  - If an array is specified, validate that the requested field exists and
# *    comes before it.
# *  - If fields is defined, check that each entry has the occurrence of field
# 
ctCheckReq = (def, types, fields) ->
  ii = undefined
  jj = undefined
  req = undefined
  keys = undefined
  key = undefined
  found = {}
  throw (new Error("definition is not an array"))  unless def instanceof Array
  throw (new Error("definition must have at least one element"))  if def.length is 0
  ii = 0
  while ii < def.length
    req = def[ii]
    throw (new Error("definition must be an array of" + "objects"))  unless req instanceof Object
    keys = Object.keys(req)
    throw (new Error("definition entry must only have " + "one key"))  unless keys.length is 1
    throw (new Error("Specified name already " + "specified: " + keys[0]))  if keys[0] of found
    throw (new Error("missing required type definition"))  unless "type" of req[keys[0]]
    key = ctParseType(req[keys[0]]["type"])
    
    #
    #		 * We may have nested arrays, we need to check the validity of
    #		 * the types until the len field is undefined in key. However,
    #		 * each time len is defined we need to verify it is either an
    #		 * integer or corresponds to an already seen key.
    #		 
    while key["len"] isnt `undefined`
      throw (new Error("Given an array " + "length without a matching type"))  unless key["len"] of found  if isNaN(parseInt(key["len"], 10))
      key = ctParseType(key["type"])
    
    # Now we can validate if the type is valid 
    throw (new Error("type not found or typdefed: " + key["type"]))  unless key["type"] of types
    
    # Check for any required fields 
    if fields isnt `undefined`
      jj = 0
      while jj < fields.length
        throw (new Error("Missing required " + "field: " + fields[jj]))  unless fields[jj] of req[keys[0]]
        jj++
    found[keys[0]] = true
    ii++
  return

#
# * Create a new instance of the parser. Each parser has its own store of
# * typedefs and endianness. Conf is an object with the following required
# * values:
# *
# *	endian		Either 'big' or 'little' do determine the endianness we
# *			want to read from or write to.
# *
# * And the following optional values:
# *
# * 	char-type	Valid options here are uint8 and int8. If uint8 is
# * 			specified this changes the default behavior of a single
# * 			char from being a buffer of a single character to being
# * 			a uint8_t. If int8, it becomes an int8_t instead.
# 
CTypeParser = (conf) ->
  throw (new Error("missing required argument"))  unless conf
  throw (new Error("missing required endian value"))  unless "endian" of conf
  throw (new Error("Invalid endian type"))  if conf["endian"] isnt "big" and conf["endian"] isnt "little"
  throw (new Error("invalid option for char-type: " + conf["char-type"]))  if "char-type" of conf and (conf["char-type"] isnt "uint8" and conf["char-type"] isnt "int8")
  @endian = conf["endian"]
  @types = ctGetBasicTypes()
  
  #
  #	 * There may be a more graceful way to do this, but this will have to
  #	 * serve.
  #	 
  @types["char"] = @types["uint8_t"]  if "char-type" of conf and conf["char-type"] is "uint8"
  @types["char"] = @types["int8_t"]  if "char-type" of conf and conf["char-type"] is "int8"
  return

#
# * Sets the current endian value for the Parser. If the value is not valid,
# * throws an Error.
# *
# *	endian		Either 'big' or 'little' do determine the endianness we
# *			want to read from or write to.
# *
# 

#
# * Returns the current value of the endian value for the parser.
# 

#
# * A user has requested to add a type, let us honor their request. Yet, if their
# * request doth spurn us, send them unto the Hells which Dante describes.
# *
# * 	name		The string for the type definition we're adding
# *
# *	value		Either a string that is a type/array name or an object
# *			that describes a struct.
# 

# We have a struct, validate it 

#
# * Include all of the typedefs, but none of the built in types. This should be
# * treated as read-only.
# 

#
# * Given a type string that may have array types that aren't numbers, try and
# * fill them in from the values object. The object should be of the format where
# * indexing into it should return a number for that type.
# *
# *	str		The type string
# *
# *	values		An object that can be used to fulfill type information
# 
ctResolveArray = (str, values) ->
  ret = ""
  type = ctParseType(str)
  while type["len"] isnt `undefined`
    if isNaN(parseInt(type["len"], 10))
      throw (new Error("cannot sawp in non-number " + "for array value"))  unless typeof (values[type["len"]]) is "number"
      ret = "[" + values[type["len"]] + "]" + ret
    else
      ret = "[" + type["len"] + "]" + ret
    type = ctParseType(type["type"])
  ret = type["type"] + ret
  ret

#
# * [private] Either the typedef resolves to another type string or to a struct.
# * If it resolves to a struct, we just pass it off to read struct. If not, we
# * can just pass it off to read entry.
# 

#
# * [private] Try and read in the specific entry.
# 

#
#	 * Because we want to special case char[]s this is unfortunately
#	 * a bit uglier than it really should be. We want to special
#	 * case char[]s so that we return a node buffer, thus they are a
#	 * first class type where as all other arrays just call into a
#	 * generic array routine which calls their data-specific routine
#	 * the specified number of times.
#	 *
#	 * The valid dispatch options we have are:
#	 *  - Array and char => char[] handler
#	 *  - Generic array handler
#	 *  - Generic typedef handler
#	 *  - Basic type handler
#	 

#
# * [private] Read an array of data
# 

#
# * [private] Read a single struct in.
# 

# Walk it and handle doing what's necessary 

# Resolve all array values 

#
# * This is what we were born to do. We read the data from a buffer and return it
# * in an object whose keys match the values from the object.
# *
# *	def		The array definition of the data to read in
# *
# *	buffer		The buffer to read data from
# *
# *	offset		The offset to start writing to
# *
# * Returns an object where each key corresponds to an entry in def and the value
# * is the read value.
# 

# Sanity check for arguments 

# Sanity check the object definition 

#
# * [private] Write out an array of data
# 

#
# * [private] Write the specific entry
# 

#
# * [private] Write a single struct out.
# 

# Now that we've written it out, we can use it for arrays 

#
# * Unfortunately, we're stuck with the sins of an initial poor design. Because
# * of that, we are going to have to support the old way of writing data via
# * writeData. There we insert the values that you want to write into the
# * definition. A little baroque. Internally, we use the new model. So we need to
# * just get those values out of there. But to maintain the principle of least
# * surprise, we're not going to modify the input data.
# 
getValues = (def) ->
  ii = undefined
  out = undefined
  key = undefined
  out = []
  ii = 0
  while ii < def.length
    key = Object.keys(def[ii])[0]
    mod_assert.ok "value" of def[ii][key]
    out.push def[ii][key]["value"]
    ii++
  out

#
# * This is the second half of what we were born to do, write out the data
# * itself. Historically this function required you to put your values in the
# * definition section. This was not the smartest thing to do and a bit of an
# * oversight to be honest. As such, this function now takes a values argument.
# * If values is non-null and non-undefined, it will be used to determine the
# * values. This means that the old method is still supported, but is no longer
# * acceptable.
# *
# *	def		The array definition of the data to write out with
# *			values
# *
# *	buffer		The buffer to write to
# *
# *	offset		The offset in the buffer to write to
# *
# *	values		An array of values to write.
# 

#
# * Functions to go to and from 64 bit numbers in a way that is compatible with
# * Javascript limitations. There are two sets. One where the user is okay with
# * an approximation and one where they are definitely not okay with an
# * approximation.
# 

#
# * Attempts to convert an array of two integers returned from rsint64 / ruint64
# * into an absolute 64 bit number. If however the value would exceed 2^52 this
# * will instead throw an error. The mantissa in a double is a 52 bit number and
# * rather than potentially give you a value that is an approximation this will
# * error. If you would rather an approximation, please see toApprox64.
# *
# *	val		An array of two 32-bit integers
# 
toAbs64 = (val) ->
  throw (new Error("missing required arg: value"))  if val is `undefined`
  throw (new Error("value must be an array"))  unless Array.isArray(val)
  throw (new Error("value must be an array of length 2"))  unless val.length is 2
  
  # We have 20 bits worth of precision in this range 
  throw (new Error("value would become approximated"))  if val[0] >= 0x100000
  val[0] * Math.pow(2, 32) + val[1]

#
# * Will return the 64 bit value as returned in an array from rsint64 / ruint64
# * to a value as close as it can. Note that Javascript stores all numbers as a
# * double and the mantissa only has 52 bits. Thus this version may approximate
# * the value.
# *
# *	val		An array of two 32-bit integers
# 
toApprox64 = (val) ->
  throw (new Error("missing required arg: value"))  if val is `undefined`
  throw (new Error("value must be an array"))  unless Array.isArray(val)
  throw (new Error("value must be an array of length 2"))  unless val.length is 2
  Math.pow(2, 32) * val[0] + val[1]
parseCTF = (json, conf) ->
  ctype = new CTypeParser(conf)
  mod_ctf.ctfParseJson json, ctype
  ctype
mod_ctf = require("./ctf.js")
mod_ctio = require("./ctio.js")
mod_assert = require("assert")
deftypes =
  uint8_t:
    read: ctReadUint8
    write: ctWriteUint8

  uint16_t:
    read: ctReadUint16
    write: ctWriteUint16

  uint32_t:
    read: ctReadUint32
    write: ctWriteUint32

  uint64_t:
    read: ctReadUint64
    write: ctWriteUint64

  int8_t:
    read: ctReadSint8
    write: ctWriteSint8

  int16_t:
    read: ctReadSint16
    write: ctWriteSint16

  int32_t:
    read: ctReadSint32
    write: ctWriteSint32

  int64_t:
    read: ctReadSint64
    write: ctWriteSint64

  float:
    read: ctReadFloat
    write: ctWriteFloat

  double:
    read: ctReadDouble
    write: ctWriteDouble

  char:
    read: ctReadChar
    write: ctWriteChar

  "char[]":
    read: ctReadCharArray
    write: ctWriteCharArray

CTypeParser::setEndian = (endian) ->
  throw (new Error("invalid endian type, must be big or " + "little"))  if endian isnt "big" and endian isnt "little"
  @endian = endian
  return

CTypeParser::getEndian = ->
  @endian

CTypeParser::typedef = (name, value) ->
  type = undefined
  throw (new (Error("missing required typedef argument: name")))  if name is `undefined`
  throw (new (Error("missing required typedef argument: value")))  if value is `undefined`
  throw (new (Error("the name of a type must be a string")))  unless typeof (name) is "string"
  type = ctParseType(name)
  throw (new Error("Cannot have an array in the typedef name"))  if type["len"] isnt `undefined`
  throw (new Error("typedef name already present: " + name))  if name of @types
  throw (new Error("typedef value must either be a string or " + "struct"))  if typeof (value) isnt "string" and (value not instanceof Array)
  if typeof (value) is "string"
    type = ctParseType(value)
    throw (new (Error("typedef value must use " + "fixed size array when outside of a " + "struct")))  if isNaN(parseInt(type["len"], 10))  if type["len"] isnt `undefined`
    @types[name] = value
  else
    ctCheckReq value, @types
    @types[name] = value
  return

CTypeParser::lstypes = ->
  key = undefined
  ret = {}
  for key of @types
    continue  if key of deftypes
    ret[key] = @types[key]
  ret

CTypeParser::resolveTypedef = (type, dispatch, buffer, offset, value) ->
  pt = undefined
  mod_assert.ok type of @types
  if typeof (@types[type]) is "string"
    pt = ctParseType(@types[type])
    if dispatch is "read"
      @readEntry pt, buffer, offset
    else if dispatch is "write"
      @writeEntry value, pt, buffer, offset
    else
      throw (new Error("invalid dispatch type to " + "resolveTypedef"))
  else
    if dispatch is "read"
      @readStruct @types[type], buffer, offset
    else if dispatch is "write"
      @writeStruct value, @types[type], buffer, offset
    else
      throw (new Error("invalid dispatch type to " + "resolveTypedef"))
  return

CTypeParser::readEntry = (type, buffer, offset) ->
  parse = undefined
  len = undefined
  if type["len"] isnt `undefined`
    len = parseInt(type["len"], 10)
    throw (new Error("somehow got a non-numeric length"))  if isNaN(len)
    if type["type"] is "char"
      parse = @types["char[]"]["read"](len, @endian, buffer, offset)
    else
      parse = @readArray(type["type"], len, buffer, offset)
  else
    if type["type"] of deftypes
      parse = @types[type["type"]]["read"](@endian, buffer, offset)
    else
      parse = @resolveTypedef(type["type"], "read", buffer, offset)
  parse

CTypeParser::readArray = (type, length, buffer, offset) ->
  ii = undefined
  ent = undefined
  pt = undefined
  baseOffset = offset
  ret = new Array(length)
  pt = ctParseType(type)
  ii = 0
  while ii < length
    ent = @readEntry(pt, buffer, offset)
    offset += ent["size"]
    ret[ii] = ent["value"]
    ii++
  value: ret
  size: offset - baseOffset

CTypeParser::readStruct = (def, buffer, offset) ->
  parse = undefined
  ii = undefined
  type = undefined
  entry = undefined
  key = undefined
  baseOffset = offset
  ret = {}
  ii = 0
  while ii < def.length
    key = Object.keys(def[ii])[0]
    entry = def[ii][key]
    type = ctParseType(ctResolveArray(entry["type"], ret))
    offset = baseOffset + entry["offset"]  if "offset" of entry
    parse = @readEntry(type, buffer, offset)
    offset += parse["size"]
    ret[key] = parse["value"]
    ii++
  value: ret
  size: (offset - baseOffset)

CTypeParser::readData = (def, buffer, offset) ->
  throw (new Error("missing definition for what we should be" + "parsing"))  if def is `undefined`
  throw (new Error("missing buffer for what we should be " + "parsing"))  if buffer is `undefined`
  throw (new Error("missing offset for what we should be " + "parsing"))  if offset is `undefined`
  ctCheckReq def, @types
  @readStruct(def, buffer, offset)["value"]

CTypeParser::writeArray = (value, type, length, buffer, offset) ->
  ii = undefined
  pt = undefined
  baseOffset = offset
  throw (new Error("asked to write an array, but value is not " + "an array"))  unless value instanceof Array
  throw (new Error("asked to write array of length " + length + " but that does not match value length: " + value.length))  unless value.length is length
  pt = ctParseType(type)
  ii = 0
  while ii < length
    offset += @writeEntry(value[ii], pt, buffer, offset)
    ii++
  offset - baseOffset

CTypeParser::writeEntry = (value, type, buffer, offset) ->
  len = undefined
  ret = undefined
  if type["len"] isnt `undefined`
    len = parseInt(type["len"], 10)
    throw (new Error("somehow got a non-numeric length"))  if isNaN(len)
    if type["type"] is "char"
      ret = @types["char[]"]["write"](value, len, @endian, buffer, offset)
    else
      ret = @writeArray(value, type["type"], len, buffer, offset)
  else
    if type["type"] of deftypes
      ret = @types[type["type"]]["write"](value, @endian, buffer, offset)
    else
      ret = @resolveTypedef(type["type"], "write", buffer, offset, value)
  ret

CTypeParser::writeStruct = (value, def, buffer, offset) ->
  ii = undefined
  entry = undefined
  type = undefined
  key = undefined
  baseOffset = offset
  vals = {}
  ii = 0
  while ii < def.length
    key = Object.keys(def[ii])[0]
    entry = def[ii][key]
    type = ctParseType(ctResolveArray(entry["type"], vals))
    offset = baseOffset + entry["offset"]  if "offset" of entry
    offset += @writeEntry(value[ii], type, buffer, offset)
    vals[key] = value[ii]
    ii++
  offset

CTypeParser::writeData = (def, buffer, offset, values) ->
  hv = undefined
  throw (new Error("missing definition for what we should be" + "parsing"))  if def is `undefined`
  throw (new Error("missing buffer for what we should be " + "parsing"))  if buffer is `undefined`
  throw (new Error("missing offset for what we should be " + "parsing"))  if offset is `undefined`
  hv = (values? and values?)
  if hv
    throw (new Error("missing values for writing"))  unless Array.isArray(values)
    ctCheckReq def, @types
  else
    ctCheckReq def, @types, ["value"]
  @writeStruct (if hv then values else getValues(def)), def, buffer, offset
  return


#
# * Export the few things we actually want to. Currently this is just the CType
# * Parser and ctio.
# 
exports.Parser = CTypeParser
exports.toAbs64 = toAbs64
exports.toApprox64 = toApprox64
exports.parseCTF = parseCTF
exports.ruint8 = mod_ctio.ruint8
exports.ruint16 = mod_ctio.ruint16
exports.ruint32 = mod_ctio.ruint32
exports.ruint64 = mod_ctio.ruint64
exports.wuint8 = mod_ctio.wuint8
exports.wuint16 = mod_ctio.wuint16
exports.wuint32 = mod_ctio.wuint32
exports.wuint64 = mod_ctio.wuint64
exports.rsint8 = mod_ctio.rsint8
exports.rsint16 = mod_ctio.rsint16
exports.rsint32 = mod_ctio.rsint32
exports.rsint64 = mod_ctio.rsint64
exports.wsint8 = mod_ctio.wsint8
exports.wsint16 = mod_ctio.wsint16
exports.wsint32 = mod_ctio.wsint32
exports.wsint64 = mod_ctio.wsint64
exports.rfloat = mod_ctio.rfloat
exports.rdouble = mod_ctio.rdouble
exports.wfloat = mod_ctio.wfloat
exports.wdouble = mod_ctio.wdouble
