#
# * ctf.js
# *
# * Understand and parse all of the different JSON formats of CTF data and
# * translate that into a series of node-ctype friendly pieces. The reason for
# * the abstraction is to handle different changes in the file format.
# *
# * We have to be careful here that we don't end up using a name that is already
# * a built in type.
# 
ctfParseInteger = (entry, ctype) ->
  name = undefined
  sign = undefined
  len = undefined
  type = undefined
  name = entry["name"]
  throw (new Error("Malformed CTF JSON: integer missing " + "signed value"))  unless "signed" of entry["integer"]
  throw (new Error("Malformed CTF JSON: integer missing " + "length value"))  unless "length" of entry["integer"]
  sign = entry["integer"]["signed"]
  len = entry["integer"]["length"]
  type = null
  if sign and len is 1
    type = "int8_t"
  else if len is 1
    type = "uint8_t"
  else if sign and len is 2
    type = "int16_t"
  else if len is 2
    type = "uint16_t"
  else if sign and len is 4
    type = "int32_t"
  else if len is 4
    type = "uint32_t"
  else if sign and len is 8
    type = "int64_t"
  else type = "uint64_t"  if len is 8
  throw (new Error("Malformed CTF JSON: integer has " + "unsupported length and sign - " + len + "/" + sign))  if type is null
  
  #
  #	 * This means that this is the same as one of our built in types. If
  #	 * that's the case defining it would be an error. So instead of trying
  #	 * to typedef it, we'll return here.
  #	 
  return  if name is type
  if name is "char"
    ASSERT type is "int8_t"
    return
  ctype.typedef name, type
  return
ctfParseFloat = (entry, ctype) ->
  name = undefined
  len = undefined
  name = entry["name"]
  throw (new Error("Malformed CTF JSON: float missing " + "length value"))  unless "length" of entry["float"]
  len = entry["float"]["length"]
  throw (new Error("Malformed CTF JSON: float has invalid " + "length value"))  if len isnt 4 and len isnt 8
  if len is 4
    return  if name is "float"
    ctype.typedef name, "float"
  else if len is 8
    return  if name is "double"
    ctype.typedef name, "double"
  return
ctfParseTypedef = (entry, ctype) ->
  name = undefined
  type = undefined
  ii = undefined
  name = entry["name"]
  throw (new Error("Malformed CTF JSON: typedef value in not " + "a string"))  unless typeof (entry["typedef"]) is "string"
  type = entry["typedef"]
  
  #
  #	 * We need to ensure that we're not looking at type that's one of our
  #	 * built in types. Traditionally in C a uint32_t would be a typedef to
  #	 * some kind of integer. However, those size types are built ins.
  #	 
  ii = 0
  while ii < ctf_deftypes.length
    return  if name is ctf_deftypes[ii]
    ii++
  ctype.typedef name, type
  return
ctfParseStruct = (entry, ctype) ->
  name = undefined
  type = undefined
  ii = undefined
  val = undefined
  index = undefined
  member = undefined
  push = undefined
  member = []
  throw (new Error("Malformed CTF JSON: struct value is not " + "an array"))  unless Array.isArray(entry["struct"])
  ii = 0
  while ii < entry["struct"].length
    val = entry["struct"][ii]
    throw (new Error("Malformed CTF JSON: struct member " + "missing name"))  unless "name" of val
    throw (new Error("Malformed CTF JSON: struct member " + "missing type"))  unless "type" of val
    throw (new Error("Malformed CTF JSON: struct member " + "name isn't a string"))  unless typeof (val["name"]) is "string"
    throw (new Error("Malformed CTF JSON: struct member " + "type isn't a string"))  unless typeof (val["type"]) is "string"
    
    #
    #		 * CTF version 2 specifies array names as <type> [<num>] where
    #		 * as node-ctype does this as <type>[<num>].
    #		 
    name = val["name"]
    type = val["type"]
    index = type.indexOf(" [")
    type = type.substring(0, index) + type.substring(index + 1, type.length)  unless index is -1
    push = {}
    push[name] = type: type
    member.push push
    ii++
  name = entry["name"]
  ctype.typedef name, member
  return
ctfParseEntry = (entry, ctype) ->
  ii = undefined
  found = undefined
  throw (new Error("Malformed CTF JSON: entry missing \"name\" " + "section"))  unless "name" of entry
  ii = 0
  while ii < ctf_entries.length
    found++  if ctf_entries[ii] of entry
    ii++
  throw (new Error("Malformed CTF JSON: found no entries"))  if found is 0
  throw (new Error("Malformed CTF JSON: found more than one " + "entry"))  if found >= 2
  if "integer" of entry
    ctfParseInteger entry, ctype
    return
  if "float" of entry
    ctfParseFloat entry, ctype
    return
  if "typedef" of entry
    ctfParseTypedef entry, ctype
    return
  if "struct" of entry
    ctfParseStruct entry, ctype
    return
  ASSERT false, "shouldn't reach here"
  return
ctfParseJson = (json, ctype) ->
  version = undefined
  ii = undefined
  ASSERT json
  ASSERT ctype
  throw (new Error("Invalid CTF JSON: missing metadata section"))  unless "metadata" of json
  throw (new Error("Invalid CTF JSON: missing ctf2json_version"))  unless "ctf2json_version" of json["metadata"]
  version = json["metadata"]["ctf2json_version"]
  ii = 0
  while ii < ctf_versions.length
    break  if ctf_versions[ii] is version
    ii++
  throw (new Error("Unsuported ctf2json_version: " + version))  if ii is ctf_versions.length
  throw (new Error("Invalid CTF JSON: missing data section"))  unless "data" of json
  throw (new Error("Malformed CTF JSON: data section is not " + "an array"))  unless Array.isArray(json["data"])
  ii = 0
  while ii < json["data"].length
    ctfParseEntry json["data"][ii], ctype
    ii++
  return
mod_assert = require("assert")
ASSERT = mod_assert.ok
ctf_versions = ["1.0"]
ctf_entries = [
  "integer"
  "float"
  "typedef"
  "struct"
]
ctf_deftypes = [
  "int8_t"
  "uint8_t"
  "int16_t"
  "uint16_t"
  "int32_t"
  "uint32_t"
  "float"
  "double"
]
exports.ctfParseJson = ctfParseJson
