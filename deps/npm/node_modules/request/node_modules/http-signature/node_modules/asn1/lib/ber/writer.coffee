# Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

#/--- Globals

#/--- Helpers
merge = (from, to) ->
  assert.ok from
  assert.equal typeof (from), "object"
  assert.ok to
  assert.equal typeof (to), "object"
  keys = Object.getOwnPropertyNames(from)
  keys.forEach (key) ->
    return  if to[key]
    value = Object.getOwnPropertyDescriptor(from, key)
    Object.defineProperty to, key, value
    return

  to

#/--- API
Writer = (options) ->
  options = merge(DEFAULT_OPTS, options or {})
  @_buf = new Buffer(options.size or 1024)
  @_size = @_buf.length
  @_offset = 0
  @_options = options
  
  # A list of offsets in the buffer where we need to insert
  # sequence tag/len pairs.
  @_seq = []
  self = this
  @__defineGetter__ "buffer", ->
    throw new InvalidAsn1Error(self._seq.length + " unended sequence(s)")  if self._seq.length
    self._buf.slice 0, self._offset

  return
assert = require("assert")
ASN1 = require("./types")
errors = require("./errors")
newInvalidAsn1Error = errors.newInvalidAsn1Error
DEFAULT_OPTS =
  size: 1024
  growthFactor: 8

Writer::writeByte = (b) ->
  throw new TypeError("argument must be a Number")  if typeof (b) isnt "number"
  @_ensure 1
  @_buf[@_offset++] = b
  return

Writer::writeInt = (i, tag) ->
  throw new TypeError("argument must be a Number")  if typeof (i) isnt "number"
  tag = ASN1.Integer  if typeof (tag) isnt "number"
  sz = 4
  while (((i & 0xff800000) is 0) or ((i & 0xff800000) is 0xff800000)) and (sz > 1)
    sz--
    i <<= 8
  throw new InvalidAsn1Error("BER ints cannot be > 0xffffffff")  if sz > 4
  @_ensure 2 + sz
  @_buf[@_offset++] = tag
  @_buf[@_offset++] = sz
  while sz-- > 0
    @_buf[@_offset++] = ((i & 0xff000000) >> 24)
    i <<= 8
  return

Writer::writeNull = ->
  @writeByte ASN1.Null
  @writeByte 0x00
  return

Writer::writeEnumeration = (i, tag) ->
  throw new TypeError("argument must be a Number")  if typeof (i) isnt "number"
  tag = ASN1.Enumeration  if typeof (tag) isnt "number"
  @writeInt i, tag

Writer::writeBoolean = (b, tag) ->
  throw new TypeError("argument must be a Boolean")  if typeof (b) isnt "boolean"
  tag = ASN1.Boolean  if typeof (tag) isnt "number"
  @_ensure 3
  @_buf[@_offset++] = tag
  @_buf[@_offset++] = 0x01
  @_buf[@_offset++] = (if b then 0xff else 0x00)
  return

Writer::writeString = (s, tag) ->
  throw new TypeError("argument must be a string (was: " + typeof (s) + ")")  if typeof (s) isnt "string"
  tag = ASN1.OctetString  if typeof (tag) isnt "number"
  len = Buffer.byteLength(s)
  @writeByte tag
  @writeLength len
  if len
    @_ensure len
    @_buf.write s, @_offset
    @_offset += len
  return

Writer::writeBuffer = (buf, tag) ->
  throw new TypeError("tag must be a number")  if typeof (tag) isnt "number"
  throw new TypeError("argument must be a buffer")  unless Buffer.isBuffer(buf)
  @writeByte tag
  @writeLength buf.length
  @_ensure buf.length
  buf.copy @_buf, @_offset, 0, buf.length
  @_offset += buf.length
  return

Writer::writeStringArray = (strings) ->
  throw new TypeError("argument must be an Array[String]")  if not strings instanceof Array
  self = this
  strings.forEach (s) ->
    self.writeString s
    return

  return


# This is really to solve DER cases, but whatever for now
Writer::writeOID = (s, tag) ->
  encodeOctet = (bytes, octet) ->
    if octet < 128
      bytes.push octet
    else if octet < 16384
      bytes.push (octet >>> 7) | 0x80
      bytes.push octet & 0x7f
    else if octet < 2097152
      bytes.push (octet >>> 14) | 0x80
      bytes.push ((octet >>> 7) | 0x80) & 0xff
      bytes.push octet & 0x7f
    else if octet < 268435456
      bytes.push (octet >>> 21) | 0x80
      bytes.push ((octet >>> 14) | 0x80) & 0xff
      bytes.push ((octet >>> 7) | 0x80) & 0xff
      bytes.push octet & 0x7f
    else
      bytes.push ((octet >>> 28) | 0x80) & 0xff
      bytes.push ((octet >>> 21) | 0x80) & 0xff
      bytes.push ((octet >>> 14) | 0x80) & 0xff
      bytes.push ((octet >>> 7) | 0x80) & 0xff
      bytes.push octet & 0x7f
    return
  throw new TypeError("argument must be a string")  if typeof (s) isnt "string"
  tag = ASN1.OID  if typeof (tag) isnt "number"
  throw new Error("argument is not a valid OID string")  unless /^([0-9]+\.){3,}[0-9]+$/.test(s)
  tmp = s.split(".")
  bytes = []
  bytes.push parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10)
  tmp.slice(2).forEach (b) ->
    encodeOctet bytes, parseInt(b, 10)
    return

  self = this
  @_ensure 2 + bytes.length
  @writeByte tag
  @writeLength bytes.length
  bytes.forEach (b) ->
    self.writeByte b
    return

  return

Writer::writeLength = (len) ->
  throw new TypeError("argument must be a Number")  if typeof (len) isnt "number"
  @_ensure 4
  if len <= 0x7f
    @_buf[@_offset++] = len
  else if len <= 0xff
    @_buf[@_offset++] = 0x81
    @_buf[@_offset++] = len
  else if len <= 0xffff
    @_buf[@_offset++] = 0x82
    @_buf[@_offset++] = len >> 8
    @_buf[@_offset++] = len
  else if len <= 0xffffff
    @_shift start, len, 1
    @_buf[@_offset++] = 0x83
    @_buf[@_offset++] = len >> 16
    @_buf[@_offset++] = len >> 8
    @_buf[@_offset++] = len
  else
    throw new InvalidAsn1ERror("Length too long (> 4 bytes)")
  return

Writer::startSequence = (tag) ->
  tag = ASN1.Sequence | ASN1.Constructor  if typeof (tag) isnt "number"
  @writeByte tag
  @_seq.push @_offset
  @_ensure 3
  @_offset += 3
  return

Writer::endSequence = ->
  seq = @_seq.pop()
  start = seq + 3
  len = @_offset - start
  if len <= 0x7f
    @_shift start, len, -2
    @_buf[seq] = len
  else if len <= 0xff
    @_shift start, len, -1
    @_buf[seq] = 0x81
    @_buf[seq + 1] = len
  else if len <= 0xffff
    @_buf[seq] = 0x82
    @_buf[seq + 1] = len >> 8
    @_buf[seq + 2] = len
  else if len <= 0xffffff
    @_shift start, len, 1
    @_buf[seq] = 0x83
    @_buf[seq + 1] = len >> 16
    @_buf[seq + 2] = len >> 8
    @_buf[seq + 3] = len
  else
    throw new InvalidAsn1Error("Sequence too long")
  return

Writer::_shift = (start, len, shift) ->
  assert.ok start isnt `undefined`
  assert.ok len isnt `undefined`
  assert.ok shift
  @_buf.copy @_buf, start + shift, start, start + len
  @_offset += shift
  return

Writer::_ensure = (len) ->
  assert.ok len
  if @_size - @_offset < len
    sz = @_size * @_options.growthFactor
    sz += len  if sz - @_offset < len
    buf = new Buffer(sz)
    @_buf.copy buf, 0, 0, @_offset
    @_buf = buf
    @_size = sz
  return


#/--- Exported API
module.exports = Writer
