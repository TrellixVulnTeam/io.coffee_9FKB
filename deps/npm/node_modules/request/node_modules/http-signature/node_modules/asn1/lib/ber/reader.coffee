# Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

#/--- Globals

#/--- API
Reader = (data) ->
  throw new TypeError("data must be a node Buffer")  if not data or not Buffer.isBuffer(data)
  @_buf = data
  @_size = data.length
  
  # These hold the "current" state
  @_len = 0
  @_offset = 0
  self = this
  @__defineGetter__ "length", ->
    self._len

  @__defineGetter__ "offset", ->
    self._offset

  @__defineGetter__ "remain", ->
    self._size - self._offset

  @__defineGetter__ "buffer", ->
    self._buf.slice self._offset

  return
assert = require("assert")
ASN1 = require("./types")
errors = require("./errors")
newInvalidAsn1Error = errors.newInvalidAsn1Error

###*
Reads a single byte and advances offset; you can pass in `true` to make this
a "peek" operation (i.e., get the byte, but don't advance the offset).

@param {Boolean} peek true means don't move offset.
@return {Number} the next byte, null if not enough data.
###
Reader::readByte = (peek) ->
  return null  if @_size - @_offset < 1
  b = @_buf[@_offset] & 0xff
  @_offset += 1  unless peek
  b

Reader::peek = ->
  @readByte true


###*
Reads a (potentially) variable length off the BER buffer.  This call is
not really meant to be called directly, as callers have to manipulate
the internal buffer afterwards.

As a result of this call, you can call `Reader.length`, until the
next thing called that does a readLength.

@return {Number} the amount of offset to advance the buffer.
@throws {InvalidAsn1Error} on bad ASN.1
###
Reader::readLength = (offset) ->
  offset = @_offset  if offset is `undefined`
  return null  if offset >= @_size
  lenB = @_buf[offset++] & 0xff
  return null  if lenB is null
  if (lenB & 0x80) is 0x80
    lenB &= 0x7f
    throw newInvalidAsn1Error("Indefinite length not supported")  if lenB is 0
    throw newInvalidAsn1Error("encoding too long")  if lenB > 4
    return null  if @_size - offset < lenB
    @_len = 0
    i = 0

    while i < lenB
      @_len = (@_len << 8) + (@_buf[offset++] & 0xff)
      i++
  else
    
    # Wasn't a variable length
    @_len = lenB
  offset


###*
Parses the next sequence in this BER buffer.

To get the length of the sequence, call `Reader.length`.

@return {Number} the sequence's tag.
###
Reader::readSequence = (tag) ->
  seq = @peek()
  return null  if seq is null
  throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16))  if tag isnt `undefined` and tag isnt seq
  o = @readLength(@_offset + 1) # stored in `length`
  return null  if o is null
  @_offset = o
  seq

Reader::readInt = ->
  @_readTag ASN1.Integer

Reader::readBoolean = ->
  (if @_readTag(ASN1.Boolean) is 0 then false else true)

Reader::readEnumeration = ->
  @_readTag ASN1.Enumeration

Reader::readString = (tag, retbuf) ->
  tag = ASN1.OctetString  unless tag
  b = @peek()
  return null  if b is null
  throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16))  if b isnt tag
  o = @readLength(@_offset + 1) # stored in `length`
  return null  if o is null
  return null  if @length > @_size - o
  @_offset = o
  return ""  if @length is 0
  str = @_buf.slice(@_offset, @_offset + @length)
  @_offset += @length
  (if retbuf then str else str.toString("utf8"))

Reader::readOID = (tag) ->
  tag = ASN1.OID  unless tag
  b = @peek()
  return null  if b is null
  throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16))  if b isnt tag
  o = @readLength(@_offset + 1) # stored in `length`
  return null  if o is null
  return null  if @length > @_size - o
  @_offset = o
  values = []
  value = 0
  i = 0

  while i < @length
    byte = @_buf[@_offset++] & 0xff
    value <<= 7
    value += byte & 0x7f
    if (byte & 0x80) is 0
      values.push value
      value = 0
    i++
  value = values.shift()
  values.unshift value % 40
  values.unshift (value / 40) >> 0
  values.join "."

Reader::_readTag = (tag) ->
  assert.ok tag isnt `undefined`
  b = @peek()
  return null  if b is null
  throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16))  if b isnt tag
  o = @readLength(@_offset + 1) # stored in `length`
  return null  if o is null
  throw newInvalidAsn1Error("Integer too long: " + @length)  if @length > 4
  return null  if @length > @_size - o
  @_offset = o
  fb = @_buf[@_offset++]
  value = 0
  value = fb & 0x7f
  i = 1

  while i < @length
    value <<= 8
    value |= (@_buf[@_offset++] & 0xff)
    i++
  value = -value  if (fb & 0x80) is 0x80
  value


#/--- Exported API
module.exports = Reader
