# Load modules
Boom = require("boom")
Hoek = require("hoek")
Cryptiles = require("cryptiles")
Crypto = require("./crypto")
Utils = require("./utils")

# Declare internals
internals = {}

# Hawk authentication

#
#   req:                 node's HTTP request object or an object as follows:
#  
#                        var request = {
#                            method: 'GET',
#                            url: '/resource/4?a=1&b=2',
#                            host: 'example.com',
#                            port: 8080,
#                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
#                        };
#  
#   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
#                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
#                        needed by the application. This function is the equivalent of verifying the username and
#                        password in Basic authentication.
#  
#                        var credentialsFunc = function (id, callback) {
#    
#                            // Lookup credentials in database
#                            db.lookup(id, function (err, item) {
#    
#                                if (err || !item) {
#                                    return callback(err);
#                                }
#    
#                                var credentials = {
#                                    // Required
#                                    key: item.key,
#                                    algorithm: item.algorithm,
#                                    // Application specific
#                                    user: item.user
#                                };
#    
#                                return callback(null, credentials);
#                            });
#                        };
#  
#   options: {
#
#        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
#                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
#                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
#                               Only used when passed a node Http.ServerRequest object.
#  
#        nonceFunc:             optional nonce validation function. The function signature is function(nonce, ts, callback)
#                               where 'callback' must be called using the signature function(err).
#  
#        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
#                               Provides a +/- skew which means actual allowed window is double the number of seconds.
#  
#        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
#                               Defaults to 0.
#  
#        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
#                               header attribute. The server always ensures the value provided has been included in the request
#                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
#                               a hash value over the entire payload (assuming it has already be normalized to the same format and
#                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
#                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
#                               attributes.hash returned in the authenticate callback.
#
#        host:                  optional host name override. Only used when passed a node request object.
#        port:                  optional port override. Only used when passed a node request object.
#    }
#
#    callback: function (err, credentials, artifacts) { }
# 
exports.authenticate = (req, credentialsFunc, options, callback) ->
  callback = Utils.nextTick(callback)
  
  # Default options
  options.nonceFunc = options.nonceFunc or (nonce, ts, nonceCallback) -> # No validation
    nonceCallback()

  options.timestampSkewSec = options.timestampSkewSec or 60 # 60 seconds
  
  # Application time
  now = Utils.now() + (options.localtimeOffsetMsec or 0) # Measure now before any other processing
  
  # Convert node Http request object to a request configuration object
  request = Utils.parseRequest(req, options)
  return callback(Boom.badRequest(request.message))  if request instanceof Error
  
  # Parse HTTP Authorization header
  attributes = Utils.parseAuthorizationHeader(request.authorization)
  return callback(attributes)  if attributes instanceof Error
  
  # Construct artifacts container
  artifacts =
    method: request.method
    host: request.host
    port: request.port
    resource: request.url
    ts: attributes.ts
    nonce: attributes.nonce
    hash: attributes.hash
    ext: attributes.ext
    app: attributes.app
    dlg: attributes.dlg
    mac: attributes.mac
    id: attributes.id

  
  # Verify required header attributes
  return callback(Boom.badRequest("Missing attributes"), null, artifacts)  if not attributes.id or not attributes.ts or not attributes.nonce or not attributes.mac
  
  # Fetch Hawk credentials
  credentialsFunc attributes.id, (err, credentials) ->
    return callback(err, credentials or null, artifacts)  if err
    return callback(Boom.unauthorized("Unknown credentials", "Hawk"), null, artifacts)  unless credentials
    return callback(Boom.internal("Invalid credentials"), credentials, artifacts)  if not credentials.key or not credentials.algorithm
    return callback(Boom.internal("Unknown algorithm"), credentials, artifacts)  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
    
    # Calculate MAC
    mac = Crypto.calculateMac("header", credentials, artifacts)
    return callback(Boom.unauthorized("Bad mac", "Hawk"), credentials, artifacts)  unless Cryptiles.fixedTimeComparison(mac, attributes.mac)
    
    # Check payload hash
    if options.payload isnt null and options.payload isnt `undefined` # '' is valid
      return callback(Boom.unauthorized("Missing required payload hash", "Hawk"), credentials, artifacts)  unless attributes.hash
      hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType)
      return callback(Boom.unauthorized("Bad payload hash", "Hawk"), credentials, artifacts)  unless Cryptiles.fixedTimeComparison(hash, attributes.hash)
    
    # Check nonce
    options.nonceFunc attributes.nonce, attributes.ts, (err) ->
      return callback(Boom.unauthorized("Invalid nonce", "Hawk"), credentials, artifacts)  if err
      
      # Check timestamp staleness
      if Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)
        tsm = Crypto.timestampMessage(credentials, options.localtimeOffsetMsec)
        return callback(Boom.unauthorized("Stale timestamp", "Hawk", tsm), credentials, artifacts)
      
      # Successful authentication
      callback null, credentials, artifacts

    return

  return


# Authenticate payload hash - used when payload cannot be provided during authenticate()

#
#    payload:        raw request payload
#    credentials:    from authenticate callback
#    artifacts:      from authenticate callback
#    contentType:    req.headers['content-type']
#
exports.authenticatePayload = (payload, credentials, artifacts, contentType) ->
  calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType)
  Cryptiles.fixedTimeComparison calculatedHash, artifacts.hash


# Generate a Server-Authorization header for a given response

#
#    credentials: {},                                        // Object received from authenticate()
#    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
#    options: {
#        ext: 'application-specific',                        // Application specific data sent via the ext attribute
#        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
#        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
#        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
#    }
#
exports.header = (credentials, artifacts, options) ->
  
  # Prepare inputs
  options = options or {}
  return ""  if not artifacts or typeof artifacts isnt "object" or typeof options isnt "object"
  artifacts = Hoek.clone(artifacts)
  delete artifacts.mac

  artifacts.hash = options.hash
  artifacts.ext = options.ext
  
  # Validate credentials
  
  # Invalid credential object
  return ""  if not credentials or not credentials.key or not credentials.algorithm
  return ""  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
  
  # Calculate payload hash
  artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType)  if not artifacts.hash and options.hasOwnProperty("payload")
  mac = Crypto.calculateMac("response", credentials, artifacts)
  
  # Construct header
  header = "Hawk mac=\"" + mac + "\"" + ((if artifacts.hash then ", hash=\"" + artifacts.hash + "\"" else ""))
  # Other falsey values allowed
  header += ", ext=\"" + Utils.escapeHeaderAttribute(artifacts.ext) + "\""  if artifacts.ext isnt null and artifacts.ext isnt `undefined` and artifacts.ext isnt ""
  header


#
# * Arguments and options are the same as authenticate() with the exception that the only supported options are:
# * 'hostHeaderName', 'localtimeOffsetMsec', 'host', 'port'
# 
exports.authenticateBewit = (req, credentialsFunc, options, callback) ->
  callback = Utils.nextTick(callback)
  
  # Application time
  now = Utils.now() + (options.localtimeOffsetMsec or 0)
  
  # Convert node Http request object to a request configuration object
  request = Utils.parseRequest(req, options)
  return callback(Boom.badRequest(request.message))  if request instanceof Error
  
  # Extract bewit
  
  #                                 1     2             3           4     
  resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/)
  return callback(Boom.unauthorized(null, "Hawk"))  unless resource
  
  # Bewit not empty
  return callback(Boom.unauthorized("Empty bewit", "Hawk"))  unless resource[3]
  
  # Verify method is GET
  return callback(Boom.unauthorized("Invalid method", "Hawk"))  if request.method isnt "GET" and request.method isnt "HEAD"
  
  # No other authentication
  return callback(Boom.badRequest("Multiple authentications", "Hawk"))  if request.authorization
  
  # Parse bewit
  bewitString = Utils.base64urlDecode(resource[3])
  return callback(Boom.badRequest("Invalid bewit encoding"))  if bewitString instanceof Error
  
  # Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)
  bewitParts = bewitString.split("\\")
  return callback(Boom.badRequest("Invalid bewit structure"))  if not bewitParts or bewitParts.length isnt 4
  bewit =
    id: bewitParts[0]
    exp: parseInt(bewitParts[1], 10)
    mac: bewitParts[2]
    ext: bewitParts[3] or ""

  return callback(Boom.badRequest("Missing bewit attributes"))  if not bewit.id or not bewit.exp or not bewit.mac
  
  # Construct URL without bewit
  url = resource[1]
  url += resource[2] + resource[4]  if resource[4]
  
  # Check expiration
  return callback(Boom.unauthorized("Access expired", "Hawk"), null, bewit)  if bewit.exp * 1000 <= now
  
  # Fetch Hawk credentials
  credentialsFunc bewit.id, (err, credentials) ->
    return callback(err, credentials or null, bewit.ext)  if err
    return callback(Boom.unauthorized("Unknown credentials", "Hawk"), null, bewit)  unless credentials
    return callback(Boom.internal("Invalid credentials"), credentials, bewit)  if not credentials.key or not credentials.algorithm
    return callback(Boom.internal("Unknown algorithm"), credentials, bewit)  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
    
    # Calculate MAC
    mac = Crypto.calculateMac("bewit", credentials,
      ts: bewit.exp
      nonce: ""
      method: "GET"
      resource: url
      host: request.host
      port: request.port
      ext: bewit.ext
    )
    return callback(Boom.unauthorized("Bad mac", "Hawk"), credentials, bewit)  unless Cryptiles.fixedTimeComparison(mac, bewit.mac)
    
    # Successful authentication
    callback null, credentials, bewit

  return


#
# *  options are the same as authenticate() with the exception that the only supported options are:
# * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
# 
exports.authenticateMessage = (host, port, message, authorization, credentialsFunc, options, callback) ->
  callback = Utils.nextTick(callback)
  
  # Default options
  options.nonceFunc = options.nonceFunc or (nonce, ts, nonceCallback) -> # No validation
    nonceCallback()

  options.timestampSkewSec = options.timestampSkewSec or 60 # 60 seconds
  
  # Application time
  now = Utils.now() + (options.localtimeOffsetMsec or 0) # Measure now before any other processing
  
  # Validate authorization
  return callback(Boom.badRequest("Invalid authorization"))  if not authorization.id or not authorization.ts or not authorization.nonce or not authorization.hash or not authorization.mac
  
  # Fetch Hawk credentials
  credentialsFunc authorization.id, (err, credentials) ->
    return callback(err, credentials or null)  if err
    return callback(Boom.unauthorized("Unknown credentials", "Hawk"))  unless credentials
    return callback(Boom.internal("Invalid credentials"), credentials)  if not credentials.key or not credentials.algorithm
    return callback(Boom.internal("Unknown algorithm"), credentials)  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
    
    # Construct artifacts container
    artifacts =
      ts: authorization.ts
      nonce: authorization.nonce
      host: host
      port: port
      hash: authorization.hash

    
    # Calculate MAC
    mac = Crypto.calculateMac("message", credentials, artifacts)
    return callback(Boom.unauthorized("Bad mac", "Hawk"), credentials)  unless Cryptiles.fixedTimeComparison(mac, authorization.mac)
    
    # Check payload hash
    hash = Crypto.calculatePayloadHash(message, credentials.algorithm)
    return callback(Boom.unauthorized("Bad message hash", "Hawk"), credentials)  unless Cryptiles.fixedTimeComparison(hash, authorization.hash)
    
    # Check nonce
    options.nonceFunc authorization.nonce, authorization.ts, (err) ->
      return callback(Boom.unauthorized("Invalid nonce", "Hawk"), credentials)  if err
      
      # Check timestamp staleness
      return callback(Boom.unauthorized("Stale timestamp"), credentials)  if Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)
      
      # Successful authentication
      callback null, credentials

    return

  return
