# Load modules
Hoek = require("hoek")
Sntp = require("sntp")
Boom = require("boom")

# Declare internals
internals = {}

# Import Hoek Utilities
internals.import = ->
  for i of Hoek
    exports[i] = Hoek[i]  if Hoek.hasOwnProperty(i)
  return

internals.import()

# Hawk version
exports.version = ->
  exports.loadPackage(__dirname + "/..").version


# Extract host and port from request
exports.parseHost = (req, hostHeaderName) ->
  hostHeaderName = ((if hostHeaderName then hostHeaderName.toLowerCase() else "host"))
  hostHeader = req.headers[hostHeaderName]
  return null  unless hostHeader
  hostHeaderRegex = undefined
  if hostHeader[0] is "["
    hostHeaderRegex = /^(?:(?:\r\n)?\s)*(\[[^\]]+\])(?::(\d+))?(?:(?:\r\n)?\s)*$/ # IPv6
  else
    hostHeaderRegex = /^(?:(?:\r\n)?\s)*([^:]+)(?::(\d+))?(?:(?:\r\n)?\s)*$/ # IPv4, hostname
  hostParts = hostHeader.match(hostHeaderRegex)
  return null  if not hostParts or hostParts.length isnt 3 or not hostParts[1]
  name: hostParts[1]
  port: ((if hostParts[2] then hostParts[2] else ((if req.connection and req.connection.encrypted then 443 else 80))))


# Parse Content-Type header content
exports.parseContentType = (header) ->
  return ""  unless header
  header.split(";")[0].trim().toLowerCase()


# Convert node's  to request configuration object
exports.parseRequest = (req, options) ->
  return req  unless req.headers
  
  # Obtain host and port information
  if not options.host or not options.port
    host = exports.parseHost(req, options.hostHeaderName)
    return new Error("Invalid Host header")  unless host
  request =
    method: req.method
    url: req.url
    host: options.host or host.name
    port: options.port or host.port
    authorization: req.headers.authorization
    contentType: req.headers["content-type"] or ""

  request

exports.now = ->
  Sntp.now()


# Parse Hawk HTTP Authorization header
exports.parseAuthorizationHeader = (header, keys) ->
  keys = keys or [
    "id"
    "ts"
    "nonce"
    "hash"
    "ext"
    "mac"
    "app"
    "dlg"
  ]
  return Boom.unauthorized(null, "Hawk")  unless header
  headerParts = header.match(/^(\w+)(?:\s+(.*))?$/) # Header: scheme[ something]
  return Boom.badRequest("Invalid header syntax")  unless headerParts
  scheme = headerParts[1]
  return Boom.unauthorized(null, "Hawk")  if scheme.toLowerCase() isnt "hawk"
  attributesString = headerParts[2]
  return Boom.badRequest("Invalid header syntax")  unless attributesString
  attributes = {}
  errorMessage = ""
  verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, ($0, $1, $2) ->
    
    # Check valid attribute names
    if keys.indexOf($1) is -1
      errorMessage = "Unknown attribute: " + $1
      return
    
    # Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9
    if $2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) is null
      errorMessage = "Bad attribute value: " + $1
      return
    
    # Check for duplicates
    if attributes.hasOwnProperty($1)
      errorMessage = "Duplicate attribute: " + $1
      return
    attributes[$1] = $2
    ""
  )
  return Boom.badRequest(errorMessage or "Bad header format")  if verify isnt ""
  attributes

exports.unauthorized = (message) ->
  Boom.unauthorized message, "Hawk"
