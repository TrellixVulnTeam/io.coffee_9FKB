# Load modules
Url = require("url")
Hoek = require("hoek")
Cryptiles = require("cryptiles")
Crypto = require("./crypto")
Utils = require("./utils")

# Declare internals
internals = {}

# Generate an Authorization header for a given request

#
#    uri: 'http://example.com/resource?a=b' or object from Url.parse()
#    method: HTTP verb (e.g. 'GET', 'POST')
#    options: {
#
#        // Required
#
#        credentials: {
#            id: 'dh37fgj492je',
#            key: 'aoijedoaijsdlaksjdl',
#            algorithm: 'sha256'                                 // 'sha1', 'sha256'
#        },
#
#        // Optional
#
#        ext: 'application-specific',                        // Application specific data sent via the ext attribute
#        timestamp: Date.now(),                              // A pre-calculated timestamp
#        nonce: '2334f34f',                                  // A pre-generated nonce
#        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
#        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
#        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
#        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
#        app: '24s23423f34dx',                               // Oz application id
#        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
#    }
#
exports.header = (uri, method, options) ->
  result =
    field: ""
    artifacts: {}

  
  # Validate inputs
  if not uri or (typeof uri isnt "string" and typeof uri isnt "object") or not method or typeof method isnt "string" or not options or typeof options isnt "object"
    result.err = "Invalid argument type"
    return result
  
  # Application time
  timestamp = options.timestamp or Math.floor((Utils.now() + (options.localtimeOffsetMsec or 0)) / 1000)
  
  # Validate credentials
  credentials = options.credentials
  if not credentials or not credentials.id or not credentials.key or not credentials.algorithm
    result.err = "Invalid credential object"
    return result
  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
    result.err = "Unknown algorithm"
    return result
  
  # Parse URI
  uri = Url.parse(uri)  if typeof uri is "string"
  
  # Calculate signature
  artifacts =
    ts: timestamp
    nonce: options.nonce or Cryptiles.randomString(6)
    method: method
    resource: uri.pathname + (uri.search or "") # Maintain trailing '?'
    host: uri.hostname
    port: uri.port or ((if uri.protocol is "http:" then 80 else 443))
    hash: options.hash
    ext: options.ext
    app: options.app
    dlg: options.dlg

  result.artifacts = artifacts
  
  # Calculate payload hash
  artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType)  if not artifacts.hash and options.hasOwnProperty("payload")
  mac = Crypto.calculateMac("header", credentials, artifacts)
  
  # Construct header
  hasExt = artifacts.ext isnt null and artifacts.ext isnt `undefined` and artifacts.ext isnt "" # Other falsey values allowed
  header = "Hawk id=\"" + credentials.id + "\", ts=\"" + artifacts.ts + "\", nonce=\"" + artifacts.nonce + ((if artifacts.hash then "\", hash=\"" + artifacts.hash else "")) + ((if hasExt then "\", ext=\"" + Utils.escapeHeaderAttribute(artifacts.ext) else "")) + "\", mac=\"" + mac + "\""
  header += ", app=\"" + artifacts.app + ((if artifacts.dlg then "\", dlg=\"" + artifacts.dlg else "")) + "\""  if artifacts.app
  result.field = header
  result


# Validate server response

#
#    res:        node's response object
#    artifacts:  object recieved from header().artifacts
#    options: {
#        payload:    optional payload received
#        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
#    }
#
exports.authenticate = (res, credentials, artifacts, options) ->
  artifacts = Hoek.clone(artifacts)
  options = options or {}
  if res.headers["www-authenticate"]
    
    # Parse HTTP WWW-Authenticate header
    attributes = Utils.parseAuthorizationHeader(res.headers["www-authenticate"], [
      "ts"
      "tsm"
      "error"
    ])
    return false  if attributes instanceof Error
    
    # Validate server timestamp (not used to update clock since it is done via the SNPT client)
    if attributes.ts
      tsm = Crypto.calculateTsMac(attributes.ts, credentials)
      return false  if tsm isnt attributes.tsm
  
  # Parse HTTP Server-Authorization header
  return true  if not res.headers["server-authorization"] and not options.required
  attributes = Utils.parseAuthorizationHeader(res.headers["server-authorization"], [
    "mac"
    "ext"
    "hash"
  ])
  return false  if attributes instanceof Error
  artifacts.ext = attributes.ext
  artifacts.hash = attributes.hash
  mac = Crypto.calculateMac("response", credentials, artifacts)
  return false  if mac isnt attributes.mac
  return true  unless options.hasOwnProperty("payload")
  return false  unless attributes.hash
  calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers["content-type"])
  calculatedHash is attributes.hash


# Generate a bewit value for a given URI

#
# * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
# * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
# 

#
#    uri: 'http://example.com/resource?a=b' or object from Url.parse()
#    options: {
#
#        // Required
#
#        credentials: {
#            id: 'dh37fgj492je',
#            key: 'aoijedoaijsdlaksjdl',
#            algorithm: 'sha256'                             // 'sha1', 'sha256'
#        },
#        ttlSec: 60 * 60,                                    // TTL in seconds
#
#        // Optional
#
#        ext: 'application-specific',                        // Application specific data sent via the ext attribute
#        localtimeOffsetMsec: 400                            // Time offset to sync with server time
#    };
#
exports.getBewit = (uri, options) ->
  
  # Validate inputs
  return ""  if not uri or (typeof uri isnt "string" and typeof uri isnt "object") or not options or typeof options isnt "object" or not options.ttlSec
  options.ext = ((if options.ext is null or options.ext is `undefined` then "" else options.ext)) # Zero is valid value
  
  # Application time
  now = Utils.now() + (options.localtimeOffsetMsec or 0)
  
  # Validate credentials
  credentials = options.credentials
  return ""  if not credentials or not credentials.id or not credentials.key or not credentials.algorithm
  return ""  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
  
  # Parse URI
  uri = Url.parse(uri)  if typeof uri is "string"
  
  # Calculate signature
  exp = Math.floor(now / 1000) + options.ttlSec
  mac = Crypto.calculateMac("bewit", credentials,
    ts: exp
    nonce: ""
    method: "GET"
    resource: uri.pathname + (uri.search or "") # Maintain trailing '?'
    host: uri.hostname
    port: uri.port or ((if uri.protocol is "http:" then 80 else 443))
    ext: options.ext
  )
  
  # Construct bewit: id\exp\mac\ext
  bewit = credentials.id + "\\" + exp + "\\" + mac + "\\" + options.ext
  Utils.base64urlEncode bewit


# Generate an authorization string for a message

#
#    host: 'example.com',
#    port: 8000,
#    message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
#    options: {
#
#        // Required
#
#        credentials: {
#            id: 'dh37fgj492je',
#            key: 'aoijedoaijsdlaksjdl',
#            algorithm: 'sha256'                             // 'sha1', 'sha256'
#        },
#
#        // Optional
#
#        timestamp: Date.now(),                              // A pre-calculated timestamp
#        nonce: '2334f34f',                                  // A pre-generated nonce
#        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
#    }
#
exports.message = (host, port, message, options) ->
  
  # Validate inputs
  return null  if not host or typeof host isnt "string" or not port or typeof port isnt "number" or message is null or message is `undefined` or typeof message isnt "string" or not options or typeof options isnt "object"
  
  # Application time
  timestamp = options.timestamp or Math.floor((Utils.now() + (options.localtimeOffsetMsec or 0)) / 1000)
  
  # Validate credentials
  credentials = options.credentials
  
  # Invalid credential object
  return null  if not credentials or not credentials.id or not credentials.key or not credentials.algorithm
  return null  if Crypto.algorithms.indexOf(credentials.algorithm) is -1
  
  # Calculate signature
  artifacts =
    ts: timestamp
    nonce: options.nonce or Cryptiles.randomString(6)
    host: host
    port: port
    hash: Crypto.calculatePayloadHash(message, credentials.algorithm)

  
  # Construct authorization
  result =
    id: credentials.id
    ts: artifacts.ts
    nonce: artifacts.nonce
    hash: artifacts.hash
    mac: Crypto.calculateMac("message", credentials, artifacts)

  result
