# Load modules
Crypto = require("crypto")
Url = require("url")
Utils = require("./utils")

# Declare internals
internals = {}

# MAC normalization format version
exports.headerVersion = "1" # Prevent comparison of mac values generated with different normalized string formats

# Supported HMAC algorithms
exports.algorithms = [
  "sha1"
  "sha256"
]

# Calculate the request MAC

#
#    type: 'header',                                 // 'header', 'bewit', 'response'
#    credentials: {
#        key: 'aoijedoaijsdlaksjdl',
#        algorithm: 'sha256'                         // 'sha1', 'sha256'
#    },
#    options: {
#        method: 'GET',
#        resource: '/resource?a=1&b=2',
#        host: 'example.com',
#        port: 8080,
#        ts: 1357718381034,
#        nonce: 'd3d345f',
#        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
#        ext: 'app-specific-data',
#        app: 'hf48hd83qwkj',                        // Application id (Oz)
#        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
#    }
#
exports.calculateMac = (type, credentials, options) ->
  normalized = exports.generateNormalizedString(type, options)
  hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized)
  digest = hmac.digest("base64")
  digest

exports.generateNormalizedString = (type, options) ->
  normalized = "hawk." + exports.headerVersion + "." + type + "\n" + options.ts + "\n" + options.nonce + "\n" + (options.method or "").toUpperCase() + "\n" + (options.resource or "") + "\n" + options.host.toLowerCase() + "\n" + options.port + "\n" + (options.hash or "") + "\n"
  normalized += options.ext.replace("\\", "\\\\").replace("\n", "\\n")  if options.ext
  normalized += "\n"
  normalized += options.app + "\n" + (options.dlg or "") + "\n"  if options.app
  normalized

exports.calculatePayloadHash = (payload, algorithm, contentType) ->
  hash = exports.initializePayloadHash(algorithm, contentType)
  hash.update payload or ""
  exports.finalizePayloadHash hash

exports.initializePayloadHash = (algorithm, contentType) ->
  hash = Crypto.createHash(algorithm)
  hash.update "hawk." + exports.headerVersion + ".payload\n"
  hash.update Utils.parseContentType(contentType) + "\n"
  hash

exports.finalizePayloadHash = (hash) ->
  hash.update "\n"
  hash.digest "base64"

exports.calculateTsMac = (ts, credentials) ->
  hmac = Crypto.createHmac(credentials.algorithm, credentials.key)
  hmac.update "hawk." + exports.headerVersion + ".ts\n" + ts + "\n"
  hmac.digest "base64"

exports.timestampMessage = (credentials, localtimeOffsetMsec) ->
  now = Math.floor((Utils.now() + (localtimeOffsetMsec or 0)) / 1000)
  tsm = exports.calculateTsMac(now, credentials)
  ts: now
  tsm: tsm
