# Load modules
Fs = require("fs")
Escape = require("./escape")

# Declare internals
internals = {}

# Clone object or array
exports.clone = (obj, seen) ->
  return obj  if typeof obj isnt "object" or obj is null
  seen = seen or
    orig: []
    copy: []

  lookup = seen.orig.indexOf(obj)
  return seen.copy[lookup]  if lookup isnt -1
  newObj = (if (obj instanceof Array) then [] else {})
  seen.orig.push obj
  seen.copy.push newObj
  for i of obj
    if obj.hasOwnProperty(i)
      if obj[i] instanceof Buffer
        newObj[i] = new Buffer(obj[i])
      else if obj[i] instanceof Date
        newObj[i] = new Date(obj[i].getTime())
      else if obj[i] instanceof RegExp
        flags = "" + ((if obj[i].global then "g" else "")) + ((if obj[i].ignoreCase then "i" else "")) + ((if obj[i].multiline then "m" else ""))
        newObj[i] = new RegExp(obj[i].source, flags)
      else
        newObj[i] = exports.clone(obj[i], seen)
  newObj


# Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied
exports.merge = (target, source, isNullOverride, isMergeArrays) -> # = true 
# = true
  exports.assert target and typeof target is "object", "Invalid target value: must be an object"
  exports.assert source is null or source is `undefined` or typeof source is "object", "Invalid source value: must be null, undefined, or an object"
  return target  unless source
  if source instanceof Array
    exports.assert target instanceof Array, "Cannot merge array onto an object"
    # isMergeArrays defaults to true
    target.length = 0  if isMergeArrays is false # Must not change target assignment
    i = 0
    il = source.length

    while i < il
      target.push source[i]
      ++i
    return target
  keys = Object.keys(source)
  k = 0
  kl = keys.length

  while k < kl
    key = keys[k]
    value = source[key]
    if value and typeof value is "object"
      if not target[key] or typeof target[key] isnt "object"
        target[key] = exports.clone(value)
      else
        exports.merge target[key], source[key], isNullOverride, isMergeArrays
    else
      if value isnt null and value isnt `undefined` # Explicit to preserve empty strings
        target[key] = value
      # Defaults to true
      else target[key] = value  if isNullOverride isnt false
    ++k
  target


# Apply options to a copy of the defaults
exports.applyToDefaults = (defaults, options) ->
  exports.assert defaults and typeof defaults is "object", "Invalid defaults value: must be an object"
  exports.assert not options or options is true or typeof options is "object", "Invalid options value: must be true, falsy or an object"
  # If no options, return null
  return null  unless options
  copy = exports.clone(defaults)
  # If options is set to true, use defaults
  return copy  if options is true
  exports.merge copy, options, false, false


# Remove duplicate items from array
exports.unique = (array, key) ->
  index = {}
  result = []
  i = 0
  il = array.length

  while i < il
    id = ((if key then array[i][key] else array[i]))
    if index[id] isnt true
      result.push array[i]
      index[id] = true
    ++i
  result


# Convert array into object
exports.mapToObject = (array, key) ->
  return null  unless array
  obj = {}
  i = 0
  il = array.length

  while i < il
    if key
      obj[array[i][key]] = true  if array[i][key]
    else
      obj[array[i]] = true
    ++i
  obj


# Find the common unique items in two arrays
exports.intersect = (array1, array2, justFirst) ->
  return []  if not array1 or not array2
  common = []
  hash = ((if array1 instanceof Array then exports.mapToObject(array1) else array1))
  found = {}
  i = 0
  il = array2.length

  while i < il
    if hash[array2[i]] and not found[array2[i]]
      return array2[i]  if justFirst
      common.push array2[i]
      found[array2[i]] = true
    ++i
  (if justFirst then null else common)


# Find which keys are present
exports.matchKeys = (obj, keys) ->
  matched = []
  i = 0
  il = keys.length

  while i < il
    matched.push keys[i]  if obj.hasOwnProperty(keys[i])
    ++i
  matched


# Flatten array
exports.flatten = (array, target) ->
  result = target or []
  i = 0
  il = array.length

  while i < il
    if Array.isArray(array[i])
      exports.flatten array[i], result
    else
      result.push array[i]
    ++i
  result


# Remove keys
exports.removeKeys = (object, keys) ->
  i = 0
  il = keys.length

  while i < il
    delete object[keys[i]]
    i++
  return


# Convert an object key chain string ('a.b.c') to reference (object[a][b][c])
exports.reach = (obj, chain) ->
  path = chain.split(".")
  ref = obj
  i = 0
  il = path.length

  while i < il
    ref = ref[path[i]]  if ref
    ++i
  ref


# Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors
exports.inheritAsync = (self, obj, keys) ->
  keys = keys or null
  for i of obj
    if obj.hasOwnProperty(i)
      continue  if keys instanceof Array and keys.indexOf(i) < 0
      self::[i] = ((fn) ->
        (next) ->
          result = null
          try
            result = fn()
          catch err
            return next(err)
          next null, result
      )(obj[i])
  return

exports.formatStack = (stack) ->
  trace = []
  i = 0
  il = stack.length

  while i < il
    item = stack[i]
    trace.push [
      item.getFileName()
      item.getLineNumber()
      item.getColumnNumber()
      item.getFunctionName()
      item.isConstructor()
    ]
    ++i
  trace

exports.formatTrace = (trace) ->
  display = []
  i = 0
  il = trace.length

  while i < il
    row = trace[i]
    display.push ((if row[4] then "new " else "")) + row[3] + " (" + row[0] + ":" + row[1] + ":" + row[2] + ")"
    ++i
  display

exports.callStack = (slice) ->
  
  # http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
  v8 = Error.prepareStackTrace
  Error.prepareStackTrace = (err, stack) ->
    stack

  capture = {}
  Error.captureStackTrace capture, arguments.callee
  stack = capture.stack
  Error.prepareStackTrace = v8
  trace = exports.formatStack(stack)
  return trace.slice(slice)  if slice
  trace

exports.displayStack = (slice) ->
  trace = exports.callStack((if slice is `undefined` then 1 else slice + 1))
  exports.formatTrace trace

exports.abortThrow = false
exports.abort = (message, hideStack) ->
  throw new Error(message or "Unknown error")  if process.env.NODE_ENV is "test" or exports.abortThrow is true
  stack = ""
  stack = exports.displayStack(1).join("\n\t")  unless hideStack
  console.log "ABORT: " + message + "\n\t" + stack
  process.exit 1
  return

exports.assert = (condition) -> #, msg1, msg2, msg3
  return  if condition
  msgs = Array::slice.call(arguments, 1)
  msgs = msgs.map((msg) ->
    (if typeof msg is "string" then msg else (if msg instanceof Error then msg.message else JSON.stringify(msg)))
  )
  throw new Error(msgs.join(" ") or "Unknown error")return

exports.loadDirModules = (path, excludeFiles, target) -> # target(filename, name, capName)
  exclude = {}
  i = 0
  il = excludeFiles.length

  while i < il
    exclude[excludeFiles[i] + ".js"] = true
    ++i
  files = Fs.readdirSync(path)
  i = 0
  il = files.length

  while i < il
    filename = files[i]
    if /\.js$/.test(filename) and not exclude[filename]
      name = filename.substr(0, filename.lastIndexOf("."))
      capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase()
      if typeof target isnt "function"
        target[capName] = require(path + "/" + name)
      else
        target path + "/" + name, name, capName
    ++i
  return

exports.rename = (obj, from, to) ->
  obj[to] = obj[from]
  delete obj[from]

  return

exports.Timer = ->
  @reset()
  return

exports.Timer::reset = ->
  @ts = Date.now()
  return

exports.Timer::elapsed = ->
  Date.now() - @ts


# Load and parse package.json process root or given directory
exports.loadPackage = (dir) ->
  result = {}
  filepath = (dir or process.env.PWD) + "/package.json"
  if Fs.existsSync(filepath)
    try
      result = JSON.parse(Fs.readFileSync(filepath))
  result


# Escape string for Regex construction
exports.escapeRegex = (string) ->
  
  # Escape ^$.*+-?=!:|\/()[]{},
  string.replace /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&"


# Return an error as first argument of a callback
exports.toss = (condition) -> #, [message], next
  message = ((if arguments.length is 3 then arguments[1] else ""))
  next = ((if arguments.length is 3 then arguments[2] else arguments[1]))
  err = ((if message instanceof Error then message else ((if message then new Error(message) else ((if condition instanceof Error then condition else new Error()))))))
  next err  if condition instanceof Error or not condition


# Base64url (RFC 4648) encode
exports.base64urlEncode = (value) ->
  (new Buffer(value, "binary")).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace /\=/g, ""


# Base64url (RFC 4648) decode
exports.base64urlDecode = (encoded) ->
  return new Error("Invalid character")  if encoded and not encoded.match(/^[\w\-]*$/)
  try
    return (new Buffer(encoded.replace(/-/g, "+").replace(/:/g, "/"), "base64")).toString("binary")
  catch err
    return err
  return


# Escape attribute value for use in HTTP header
exports.escapeHeaderAttribute = (attribute) ->
  
  # Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "
  exports.assert attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), "Bad attribute value (" + attribute + ")"
  attribute.replace(/\\/g, "\\\\").replace /\"/g, "\\\"" # Escape quotes and slash

exports.escapeHtml = (string) ->
  Escape.escapeHtml string

exports.escapeJavaScript = (string) ->
  Escape.escapeJavaScript string


#
#var event = {
#    timestamp: now.getTime(),
#    tags: ['tag'],
#    data: { some: 'data' }
#};
#
exports.consoleFunc = console.log
exports.printEvent = (event) ->
  pad = (value) ->
    ((if value < 10 then "0" else "")) + value

  now = new Date(event.timestamp)
  timestring = (now.getYear() - 100).toString() + pad(now.getMonth() + 1) + pad(now.getDate()) + "/" + pad(now.getHours()) + pad(now.getMinutes()) + pad(now.getSeconds()) + "." + now.getMilliseconds()
  data = event.data
  if typeof event.data isnt "string"
    try
      data = JSON.stringify(event.data)
    catch e
      data = "JSON Error: " + e.message
  output = timestring + ", " + event.tags[0] + ", " + data
  exports.consoleFunc output
  return

exports.nextTick = (callback) ->
  ->
    args = arguments
    process.nextTick ->
      callback.apply null, args
      return

    return
