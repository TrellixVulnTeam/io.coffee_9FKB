# Load modules
Dgram = require("dgram")
Dns = require("dns")
Hoek = require("hoek")

# Declare internals
internals = {}
exports.time = (options, callback) ->
  if arguments.length isnt 2
    callback = arguments[0]
    options = {}
  settings = Hoek.clone(options)
  settings.host = settings.host or "pool.ntp.org"
  settings.port = settings.port or 123
  settings.resolveReference = settings.resolveReference or false
  
  # Declare variables used by callback
  timeoutId = 0
  sent = 0
  
  # Ensure callback is only called once
  isFinished = false
  finish = (err, result) ->
    if timeoutId
      clearTimeout timeoutId
      timeoutId = 0
    unless isFinished
      isFinished = true
      socket.removeAllListeners()
      socket.close()
      callback err, result

  
  # Create UDP socket
  socket = Dgram.createSocket("udp4")
  socket.once "error", (err) ->
    finish err

  
  # Listen to incoming messages
  socket.on "message", (buffer, rinfo) ->
    received = Date.now()
    message = new internals.NtpMessage(buffer)
    return finish(new Error("Invalid server response"), message)  unless message.isValid
    return finish(new Error("Wrong originate timestamp"), message)  if message.originateTimestamp isnt sent
    
    # Timestamp Name          ID   When Generated
    # ------------------------------------------------------------
    # Originate Timestamp     T1   time request sent by client
    # Receive Timestamp       T2   time request received by server
    # Transmit Timestamp      T3   time reply sent by server
    # Destination Timestamp   T4   time reply received by client
    #
    # The roundtrip delay d and system clock offset t are defined as:
    #
    # d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2
    T1 = message.originateTimestamp
    T2 = message.receiveTimestamp
    T3 = message.transmitTimestamp
    T4 = received
    message.d = (T4 - T1) - (T3 - T2)
    message.t = ((T2 - T1) + (T3 - T4)) / 2
    message.receivedLocally = received
    return finish(null, message)  if not settings.resolveReference or message.stratum isnt "secondary"
    
    # Resolve reference IP address
    Dns.reverse message.referenceId, (err, domains) ->
      message.referenceHost = domains[0]  unless err
      finish null, message

    return

  
  # Set timeout
  if settings.timeout
    timeoutId = setTimeout(->
      timeoutId = 0
      finish new Error("Timeout")
    , settings.timeout)
  
  # Construct NTP message
  message = new Buffer(48)
  i = 0 # Zero message

  while i < 48
    message[i] = 0
    i++
  message[0] = (0 << 6) + (4 << 3) + (3 << 0) # Set version number to 4 and Mode to 3 (client)
  sent = Date.now()
  internals.fromMsecs sent, message, 40 # Set transmit timestamp (returns as originate)
  
  # Send NTP request
  socket.send message, 0, message.length, settings.port, settings.host, (err, bytes) ->
    finish err or new Error("Could not send entire message")  if err or bytes isnt 48

  return

internals.NtpMessage = (buffer) ->
  @isValid = false
  
  # Validate
  return  if buffer.length isnt 48
  
  # Leap indicator
  li = (buffer[0] >> 6)
  switch li
    when 0
      @leapIndicator = "no-warning"
    when 1
      @leapIndicator = "last-minute-61"
    when 2
      @leapIndicator = "last-minute-59"
    when 3
      @leapIndicator = "alarm"
  
  # Version
  vn = ((buffer[0] & 0x38) >> 3)
  @version = vn
  
  # Mode
  mode = (buffer[0] & 0x7)
  switch mode
    when 1
      @mode = "symmetric-active"
    when 2
      @mode = "symmetric-passive"
    when 3
      @mode = "client"
    when 4
      @mode = "server"
    when 5
      @mode = "broadcast"
    when 0, 6, 7
      @mode = "reserved"
  
  # Stratum
  stratum = buffer[1]
  if stratum is 0
    @stratum = "death"
  else if stratum is 1
    @stratum = "primary"
  else if stratum <= 15
    @stratum = "secondary"
  else
    @stratum = "reserved"
  
  # Poll interval (msec)
  @pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000
  
  # Precision (msecs)
  @precision = Math.pow(2, buffer[3]) * 1000
  
  # Root delay (msecs)
  rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7]
  @rootDelay = 1000 * (rootDelay / 0x10000)
  
  # Root dispersion (msecs)
  @rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000
  
  # Reference identifier
  @referenceId = ""
  switch @stratum
    when "death", "primary"
      @referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15])
    when "secondary"
      @referenceId = "" + buffer[12] + "." + buffer[13] + "." + buffer[14] + "." + buffer[15]
  
  # Reference timestamp
  @referenceTimestamp = internals.toMsecs(buffer, 16)
  
  # Originate timestamp
  @originateTimestamp = internals.toMsecs(buffer, 24)
  
  # Receive timestamp
  @receiveTimestamp = internals.toMsecs(buffer, 32)
  
  # Transmit timestamp
  @transmitTimestamp = internals.toMsecs(buffer, 40)
  
  # Validate
  @isValid = true  if @version is 4 and @stratum isnt "reserved" and @mode is "server" and @originateTimestamp and @receiveTimestamp and @transmitTimestamp
  this

internals.toMsecs = (buffer, offset) ->
  seconds = 0
  fraction = 0
  i = 0

  while i < 4
    seconds = (seconds * 256) + buffer[offset + i]
    ++i
  i = 4
  while i < 8
    fraction = (fraction * 256) + buffer[offset + i]
    ++i
  (seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000

internals.fromMsecs = (ts, buffer, offset) ->
  seconds = Math.floor(ts / 1000) + 2208988800
  fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32))
  buffer[offset + 0] = (seconds & 0xff000000) >> 24
  buffer[offset + 1] = (seconds & 0x00ff0000) >> 16
  buffer[offset + 2] = (seconds & 0x0000ff00) >> 8
  buffer[offset + 3] = (seconds & 0x000000ff)
  buffer[offset + 4] = (fraction & 0xff000000) >> 24
  buffer[offset + 5] = (fraction & 0x00ff0000) >> 16
  buffer[offset + 6] = (fraction & 0x0000ff00) >> 8
  buffer[offset + 7] = (fraction & 0x000000ff)
  return


# Offset singleton
internals.last =
  offset: 0
  expires: 0
  host: ""
  port: 0

exports.offset = (options, callback) ->
  if arguments.length isnt 2
    callback = arguments[0]
    options = {}
  now = Date.now()
  clockSyncRefresh = options.clockSyncRefresh or 24 * 60 * 60 * 1000 # Daily
  if internals.last.offset and internals.last.host is options.host and internals.last.port is options.port and now < internals.last.expires
    process.nextTick ->
      callback null, internals.last.offset
      return

    return
  exports.time options, (err, time) ->
    return callback(err, 0)  if err
    internals.last =
      offset: Math.round(time.t)
      expires: now + clockSyncRefresh
      host: options.host
      port: options.port

    callback null, internals.last.offset

  return


# Now singleton
internals.now = intervalId: 0
exports.start = (options, callback) ->
  if arguments.length isnt 2
    callback = arguments[0]
    options = {}
  if internals.now.intervalId
    process.nextTick ->
      callback()
      return

    return
  exports.offset options, (err, offset) ->
    internals.now.intervalId = setInterval(->
      exports.offset options, ->

      return
    , options.clockSyncRefresh or 24 * 60 * 60 * 1000) # Daily
    callback()

  return

exports.stop = ->
  return  unless internals.now.intervalId
  clearInterval internals.now.intervalId
  internals.now.intervalId = 0
  return

exports.isLive = ->
  !!internals.now.intervalId

exports.now = ->
  now = Date.now()
  return now  if not exports.isLive() or now >= internals.last.expires
  now + internals.last.offset
