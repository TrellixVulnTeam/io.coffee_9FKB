# Load modules
Dgram = require("dgram")
Lab = require("lab")
Sntp = require("../lib")

# Declare internals
internals = {}

# Test shortcuts
expect = Lab.expect
before = Lab.before
after = Lab.after
describe = Lab.experiment
it = Lab.test
describe "SNTP", ->
  describe "#time", ->
    it "returns consistent result over multiple tries", (done) ->
      Sntp.time (err, time) ->
        expect(err).to.not.exist
        expect(time).to.exist
        t1 = time.t
        Sntp.time (err, time) ->
          expect(err).to.not.exist
          expect(time).to.exist
          t2 = time.t
          expect(Math.abs(t1 - t2)).is.below 200
          done()
          return

        return

      return

    it "resolves reference IP", (done) ->
      Sntp.time
        host: "ntp.exnet.com"
        resolveReference: true
      , (err, time) ->
        expect(err).to.not.exist
        expect(time).to.exist
        expect(time.referenceHost).to.exist
        done()
        return

      return

    it "times out on no response", (done) ->
      Sntp.time
        port: 124
        timeout: 100
      , (err, time) ->
        expect(err).to.exist
        expect(time).to.not.exist
        expect(err.message).to.equal "Timeout"
        done()
        return

      return

    it "errors on error event", (done) ->
      orig = Dgram.createSocket
      Dgram.createSocket = (type) ->
        Dgram.createSocket = orig
        socket = Dgram.createSocket(type)
        process.nextTick ->
          socket.emit "error", new Error("Fake")
          return

        socket

      Sntp.time (err, time) ->
        expect(err).to.exist
        expect(time).to.not.exist
        expect(err.message).to.equal "Fake"
        done()
        return

      return

    it "times out on invalid host", (done) ->
      Sntp.time
        host: "error"
        timeout: 10000
      , (err, time) ->
        expect(err).to.exist
        expect(time).to.not.exist
        expect(err.message).to.equal "getaddrinfo ENOTFOUND"
        done()
        return

      return

    it "fails on bad response buffer size", (done) ->
      server = Dgram.createSocket("udp4")
      server.on "message", (message, remote) ->
        message = new Buffer(10)
        server.send message, 0, message.length, remote.port, remote.address, (err, bytes) ->
          server.close()
          return

        return

      server.bind 49123
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(err.message).to.equal "Invalid server response"
        done()
        return

      return

    messup = (bytes) ->
      server = Dgram.createSocket("udp4")
      server.on "message", (message, remote) ->
        message = new Buffer([
          0x24
          0x01
          0x00
          0xe3
          0x00
          0x00
          0x00
          0x00
          0x00
          0x00
          0x00
          0x00
          0x41
          0x43
          0x54
          0x53
          0xd4
          0xa8
          0x2d
          0xc7
          0x1c
          0x5d
          0x49
          0x1b
          0xd4
          0xa8
          0x2d
          0xe6
          0x67
          0xef
          0x9d
          0xb2
          0xd4
          0xa8
          0x2d
          0xe6
          0x71
          0xed
          0xb5
          0xfb
          0xd4
          0xa8
          0x2d
          0xe6
          0x71
          0xee
          0x6c
          0xc5
        ])
        i = 0
        il = bytes.length

        while i < il
          message[bytes[i][0]] = bytes[i][1]
          ++i
        server.send message, 0, message.length, remote.port, remote.address, (err, bytes) ->
          server.close()
          return

        return

      server.bind 49123
      return

    it "fails on bad version", (done) ->
      messup [[
        0
        (0 << 6) + (3 << 3) + (4 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.version).to.equal 3
        expect(err.message).to.equal "Invalid server response"
        done()
        return

      return

    it "fails on bad originate timestamp and alarm li", (done) ->
      messup [[
        0
        (3 << 6) + (4 << 3) + (4 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(err.message).to.equal "Wrong originate timestamp"
        expect(time.leapIndicator).to.equal "alarm"
        done()
        return

      return

    it "returns time with death stratum and last61 li", (done) ->
      messup [
        [
          0
          (1 << 6) + (4 << 3) + (4 << 0)
        ]
        [
          1
          0
        ]
      ]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(time.stratum).to.equal "death"
        expect(time.leapIndicator).to.equal "last-minute-61"
        done()
        return

      return

    it "returns time with reserved stratum and last59 li", (done) ->
      messup [
        [
          0
          (2 << 6) + (4 << 3) + (4 << 0)
        ]
        [
          1
          0x1f
        ]
      ]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(time.stratum).to.equal "reserved"
        expect(time.leapIndicator).to.equal "last-minute-59"
        done()
        return

      return

    it "fails on bad mode (symmetric-active)", (done) ->
      messup [[
        0
        (0 << 6) + (4 << 3) + (1 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.mode).to.equal "symmetric-active"
        done()
        return

      return

    it "fails on bad mode (symmetric-passive)", (done) ->
      messup [[
        0
        (0 << 6) + (4 << 3) + (2 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.mode).to.equal "symmetric-passive"
        done()
        return

      return

    it "fails on bad mode (client)", (done) ->
      messup [[
        0
        (0 << 6) + (4 << 3) + (3 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.mode).to.equal "client"
        done()
        return

      return

    it "fails on bad mode (broadcast)", (done) ->
      messup [[
        0
        (0 << 6) + (4 << 3) + (5 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.mode).to.equal "broadcast"
        done()
        return

      return

    it "fails on bad mode (reserved)", (done) ->
      messup [[
        0
        (0 << 6) + (4 << 3) + (6 << 0)
      ]]
      Sntp.time
        host: "localhost"
        port: 49123
      , (err, time) ->
        expect(err).to.exist
        expect(time.mode).to.equal "reserved"
        done()
        return

      return

    return

  describe "#offset", ->
    it "gets the current offset", (done) ->
      Sntp.offset (err, offset) ->
        expect(err).to.not.exist
        expect(offset).to.not.equal 0
        done()
        return

      return

    it "gets the current offset from cache", (done) ->
      Sntp.offset (err, offset) ->
        expect(err).to.not.exist
        expect(offset).to.not.equal 0
        offset1 = offset
        Sntp.offset {}, (err, offset) ->
          expect(err).to.not.exist
          expect(offset).to.equal offset1
          done()
          return

        return

      return

    it "fails getting the current offset on invalid server", (done) ->
      Sntp.offset
        host: "error"
      , (err, offset) ->
        expect(err).to.exist
        expect(offset).to.equal 0
        done()
        return

      return

    return

  describe "#now", ->
    it "starts auto-sync, gets now, then stops", (done) ->
      Sntp.stop()
      before = Sntp.now()
      expect(before).to.equal Date.now()
      Sntp.start ->
        now = Sntp.now()
        expect(now).to.not.equal Date.now()
        Sntp.stop()
        done()
        return

      return

    it "starts twice", (done) ->
      Sntp.start ->
        Sntp.start ->
          now = Sntp.now()
          expect(now).to.not.equal Date.now()
          Sntp.stop()
          done()
          return

        return

      return

    it "starts auto-sync, gets now, waits, gets again after timeout", (done) ->
      Sntp.stop()
      before = Sntp.now()
      expect(before).to.equal Date.now()
      Sntp.start
        clockSyncRefresh: 100
      , ->
        now = Sntp.now()
        expect(now).to.not.equal Date.now()
        expect(now).to.equal Sntp.now()
        setTimeout (->
          expect(Sntp.now()).to.not.equal now
          Sntp.stop()
          done()
          return
        ), 110
        return

      return

    return

  return

